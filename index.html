<!DOCTYPE html>
<html lang="pt-br" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PromptMana</title>
    <!-- Carregando Tailwind CSS e Google Fonts -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <!-- Bibliotecas Externas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- PDF.js for PDF text extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>if (window['pdfjsLib']) { pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; }</script>
    <!-- Mammoth for DOCX text extraction -->
    <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Roboto Mono', 'monospace'],
                    },
                },
            },
        }
    </script>
    <style>
    /* Force compact charts in Dashboard using a fixed-height wrapper */
    #dashboard-modal .chart-box { height: 350px; }
    #dashboard-modal .chart-box > canvas { height: 100% !important; width: 100% !important; display: block; }
        :root {
            --bg-dark: #121212; /* Cinza mais escuro */
            --card-bg-dark: #1E1E1E; /* Fundo do card mais escuro */
            --border-dark: #2E2E2E; /* Borda mais escura */
            --text-dark: #FFFDF2; /* Creme */
            --text-muted-dark: #808080; /* Cinza de texto mais escuro */
            --input-bg: #222222; /* Inputs/textarea fundo */
            --panel-bg: #121212; /* Painéis internos */
            --accent-fuchsia: #D8125B;
            --accent-fuchsia-hover: #b80f4d;
            --accent-mint: #0FFCBE;
            --accent-red: #dc2626;
            --accent-red-hover: #b91c1c;
            --diff-ins-bg: #517A18;
            --diff-del-bg: #CC5E5E;
            --highlight-bg: rgba(216, 18, 91, 0.4); /* Cor de destaque para busca */
            /* Theme-aware accents */
            --stat-color: var(--accent-mint); /* tokens/words/chars counters */
            --db-online-color: var(--accent-mint);
            --db-offline-color: var(--text-muted-dark);
        }
        /* Light theme: soft neutrals, lower contrast */
        [data-theme="light"] {
            --bg-dark: #F7F8FA; /* soft background */
            --card-bg-dark: #FFFFFF; /* modal shells/cards */
            --border-dark: #E5E7EB; /* light gray border */
            --text-dark: #1F2937; /* slate-700 */
            --text-muted-dark: #6B7280; /* gray-500 */
            --input-bg: #F9FAFB; /* light input bg */
            --panel-bg: #F9FAFB; /* subtle gray panels for separation */
            --diff-ins-bg: #DCFCE7; /* pastel green */
            --diff-del-bg: #FEE2E2; /* pastel red */
            /* In light mode, use a different accent for stats and DB online (not green) */
            --stat-color: #6366F1; /* indigo-500 */
            --db-online-color: #6366F1;
            --db-offline-color: var(--text-muted-dark);
        }

        /* Light theme overrides for dark-leaning components */
        [data-theme="light"] .action-button:hover { background-color: #F3F4F6; border-color: #E5E7EB; }
        [data-theme="light"] .prompt-group-header:hover { background-color: #F3F4F6; }
        [data-theme="light"] .filter-tag-btn { background-color: #F3F4F6; color: var(--text-muted-dark); border-color: var(--border-dark); }
        [data-theme="light"] .filter-tag-btn:hover { background-color: #E5E7EB; color: var(--text-dark); }
        [data-theme="light"] .xml-tag, [data-theme="light"] .dependency-tag, [data-theme="light"] .var-library-tag { background-color: #F3F4F6; color: var(--text-dark); }
        [data-theme="light"] .nav-map-tag { background-color: #F3F4F6; }
        [data-theme="light"] .status-selector { background-color: #F3F4F6; border-color: var(--border-dark); }
        [data-theme="light"] .gallery-card:hover { box-shadow: 0 8px 14px -6px rgba(216, 18, 91, 0.12), 0 3px 5px -3px rgba(216, 18, 91, 0.08); }
        /* Node Flow canvas grid on light */
        [data-theme="light"] #node-flow-canvas {
            background-color: #F8FAFC;
            background-image: radial-gradient(circle, rgba(0,0,0,0.08) 1px, transparent 1px);
            background-size: 16px 16px;
            background-position: 0 0;
        }
    /* Additional light theme softening */
    [data-theme="light"] .manager-tag span[contenteditable]:focus { background-color: #F3F4F6; }
    [data-theme="light"] .copy-snippet-btn { background-color: #F3F4F6; color: var(--text-muted-dark); border-color: var(--border-dark); }
    [data-theme="light"] .input-gallery-item:hover { background-color: #F3F4F6; }
    [data-theme="light"] .version-item:hover { background-color: #F3F4F6; }
    [data-theme="light"] .prompt-tag, [data-theme="light"] .manager-tag { background-color: #F3F4F6; color: var(--text-dark); }
    [data-theme="light"] .form-control { background-color: var(--input-bg); border: 1px solid var(--border-dark); color: var(--text-dark); }
    [data-theme="light"] .form-control::placeholder { color: var(--text-muted-dark); }
    [data-theme="light"] .form-control:focus, [data-theme="light"] #search-versions-input:focus { --tw-ring-color: #E5E7EB; border-color: #D1D5DB; }
    [data-theme="light"] input[type=range] { background: #E5E7EB; }
    [data-theme="light"] #projects-modal tr:hover { background-color: #F3F4F6 !important; }
    [data-theme="light"] #copy-prompt-btn:hover,
    [data-theme="light"] #find-btn:hover,
    [data-theme="light"] #toggle-comments-btn:hover,
    [data-theme="light"] #close-gallery-btn:hover,
    [data-theme="light"] #close-templates-btn:hover,
    [data-theme="light"] #close-projects-btn:hover,
    [data-theme="light"] #close-dependency-viewer-btn:hover,
    [data-theme="light"] #close-comments-viewer-btn:hover,
    [data-theme="light"] #close-diff-modal-btn:hover,
    [data-theme="light"] #close-dependency-graph-btn:hover,
    [data-theme="light"] #close-input-gallery-btn:hover,
    [data-theme="light"] #close-node-flow-btn:hover { background-color: #F3F4F6 !important; color: var(--text-dark); }
    [data-theme="light"] #close-dashboard-btn:hover { background-color: #F3F4F6 !important; color: var(--text-dark); }
    [data-theme="light"] #dashboard-btn:hover { background-color: #F3F4F6 !important; color: var(--text-dark); }
    [data-theme="light"] #close-api-console-btn:hover { background-color: #F3F4F6 !important; color: var(--text-dark); }
    [data-theme="light"] #api-console-btn:hover { background-color: #F3F4F6 !important; color: var(--text-dark); }
    /* Ensure Read Mode & Run buttons don't get dark bg on light mode */
    [data-theme="light"] #read-mode-btn:hover { background-color: #F3F4F6 !important; color: var(--text-dark); }
    [data-theme="light"] #run-prompt-btn:hover { background-color: #F3F4F6 !important; color: var(--text-dark); }
    /* Tailwind class badge override in light mode */
    [data-theme="light"] .bg-\[\#333\] { background-color: #F3F4F6 !important; color: var(--text-muted-dark) !important; }
    /* Light mode: soften diff panels to create clear separation */
    [data-theme="light"] .diff-view {
        background-color: var(--panel-bg);
        border: 1px solid var(--border-dark);
        box-shadow: 0 1px 2px rgba(0,0,0,0.03);
    }
    /* Light mode: cards inside gallery/templates should not blend with modal bg */
    [data-theme="light"] .gallery-card { background-color: #FFFFFF; border: 1px solid #E5E7EB; border-radius: 0.75rem; }
    [data-theme="light"] #gallery-grid > * { background-color: #FFFFFF; border: 1px solid #E5E7EB; border-radius: 0.75rem; }
    [data-theme="light"] #templates-grid-container > * { background-color: #FFFFFF; border: 1px solid #E5E7EB; border-radius: 0.75rem; }
    /* Light mode: input gallery list items need separation */
    [data-theme="light"] .input-gallery-item { background-color: #FFFFFF; border: 1px solid #E5E7EB; }
    /* Dependencies dropdown row hover */
    #dependencies-list > div:hover { background-color: #333333; }
    [data-theme="light"] #dependencies-list > div:hover { background-color: #F3F4F6 !important; color: var(--text-dark); }
    /* Dock icon hover */
    #config-dock button:hover { background-color: #333333; }
    [data-theme="light"] #config-dock button:hover { background-color: #F3F4F6 !important; color: var(--text-dark); }
    /* Dock icon selected state */
    
    /* Slightly increase spacing between dock icons */
    #config-dock .dock-item + .dock-item { margin-top: 6px; }
    /* Dock and Drawer backgrounds in light mode */
    [data-theme="light"] #config-dock { background-color: #F3F4F6 !important; }
    [data-theme="light"] #config-drawer { background-color: #F3F4F6 !important; }
        
        html, body { height: 100%; overflow: hidden; }
        body { background-color: var(--bg-dark); color: var(--text-dark); font-family: 'Inter', sans-serif; }
        #root { height: 100vh; }
        .sidebar { width: 320px; min-width: 320px; background-color: var(--card-bg-dark); border-right: 1px solid var(--border-dark); }
        .action-panel { width: 320px; min-width: 320px; background-color: var(--card-bg-dark); border-left: 1px solid var(--border-dark); }
        .main-editor-area { background-color: var(--bg-dark); }
        .editor-window { background-color: var(--card-bg-dark); border: 1px solid var(--border-dark); border-radius: 0.75rem; }
    .form-input, .llm-select { background-color: transparent; border: 0; color: var(--text-dark); }
        .form-input::placeholder { color: var(--text-muted-dark); }
    .form-input:focus, .llm-select:focus { outline: none; box-shadow: none; }
        
    .action-button { background-color: transparent; border: 1px solid var(--border-dark); font-size: 0.875rem; padding: 6px 12px; border-radius: 0.5rem; transition: background-color 0.2s, border-color 0.2s; }
    .action-button:hover { background-color: #333333; border-color: #444444; }
    /* Panels that previously used hardcoded bg should follow theme */
    .diff-view { background-color: var(--panel-bg); }
    /* Generic light-tone panel for viewer modals */
    .panel-soft { background-color: var(--panel-bg); border: 1px solid var(--border-dark); border-radius: 0.5rem; }
        .action-button:disabled { cursor: not-allowed; opacity: 0.5; }
        .action-button.primary { background-color: var(--accent-fuchsia); border-color: var(--accent-fuchsia-hover); color: white; }
        .action-button.primary:hover { background-color: var(--accent-fuchsia-hover); }
        .action-button.active {
            background-color: var(--accent-fuchsia);
            color: white;
            border-color: var(--accent-fuchsia-hover);
        }
    /* Compact inline field for top controls and managers */
    .compact-field { padding: 0.25rem 0.5rem; height: 2rem; line-height: 1.25rem; }
    .compact-width { width: 14rem; }

    /* Dock tooltip styles */
    .dock-item { position: relative; }
    .dock-tooltip {
        position: absolute;
        left: 52px; /* dock width (48px) + spacing */
        top: 50%;
        transform: translateY(-50%);
        background-color: var(--card-bg-dark);
        border: 1px solid var(--border-dark);
        color: var(--text-dark);
        padding: 2px 8px;
        font-size: 12px;
        line-height: 1.2;
        white-space: nowrap;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        opacity: 0;
        pointer-events: none;
        transition: opacity .15s ease-in-out;
        z-index: 50;
    }
    .dock-item:hover .dock-tooltip { opacity: 1; }

    /* Ensure drawer never overflows viewport */
    #config-drawer {
        width: 320px; /* default to match sidebar */
        max-width: calc(100vw - 56px); /* viewport minus dock(48px) and 8px breathing room */
    }
    /* Normalize select height */
    select.form-control.compact-field { height: 2rem; }
    /* Ensure internal text alignment */
    .form-control.compact-field { font-size: 0.875rem; }
    /* Consistent (slightly slimmer) height for left/right menu buttons */
    .nav-button { padding-top: 0.375rem; padding-bottom: 0.375rem; }
        
        .prompt-group-header { cursor: pointer; padding: 8px; border-radius: 0.5rem; display: flex; align-items: center; justify-content: space-between; font-size: 0.875rem; font-weight: 500; }
        .prompt-group-header:hover { background-color: #333333; }
        .prompt-group-header .toggle-icon { margin-right: 8px; transition: transform 0.2s; color: var(--text-muted-dark); }
        .prompt-group-header.expanded .toggle-icon { transform: rotate(90deg); }

        .version-sub-list { padding-left: 12px; display: none; }
        .version-sub-list.expanded { display: block; }
        .version-item { cursor: pointer; padding: 6px 12px; border-radius: 0.5rem; transition: background-color 0.2s; display: flex; justify-content: space-between; align-items: center; font-size: 0.875rem; }
        .version-item:hover { background-color: #333333; }
        .version-item.selected { background-color: var(--accent-fuchsia); color: white; }
        .version-item.selected .text-gray-400, .version-item.selected .text-gray-500 { color: white; }

        .status-selector { background-color: #333333; border: 1px solid var(--border-dark); }
        .status-option { border-right: 1px solid var(--border-dark); color: var(--text-muted-dark); transition: all 0.2s; }
        .status-option:last-child { border-right: none; }
        .status-option:hover { color: var(--text-dark); }
        .status-option.active { background-color: var(--accent-fuchsia); color: white; font-weight: 600; }

        /* Estilo unificado para botões de filtro (status e tags) */
        .filter-tag-btn {
            background-color: #333;
            color: var(--text-muted-dark);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            border: 1px solid var(--border-dark);
            cursor: pointer;
            transition: all 0.2s;
        }
        .filter-tag-btn:hover {
            color: var(--text-dark);
            background-color: #444444;
        }
        .filter-tag-btn.active {
            background-color: var(--accent-fuchsia);
            color: white;
            border-color: var(--accent-fuchsia-hover);
        }

    #editor-stats { color: var(--stat-color); }
    #read-mode-stats { color: var(--stat-color); }
    /* DB status pill color by state */
    #db-status-pill.online { color: var(--db-online-color); }
    #db-status-pill.offline { color: var(--db-offline-color); }
    #llm-status-pill.online { color: var(--accent-mint); }
    #llm-status-pill.offline { color: var(--accent-red); }

        .modal-overlay { transition: opacity 0.3s ease; }
        .modal-overlay.hidden { opacity: 0; pointer-events: none; }
        #confirm-modal { z-index: 60; } /* Z-index maior para o modal de confirmação */
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.75) !important;
        }

        .modal-overlay > div {
            background-color: var(--card-bg-dark) !important;
            border: 1px solid var(--border-dark) !important;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
            color: var(--text-dark);
        }
        
        .form-control {
            background-color: #222222;
            border: 1px solid #3a3a3a;
        }
        .form-control:focus, #search-versions-input:focus {
            --tw-ring-color: #444444;
            border-color: #555555;
        }

        /* Custom Range Slider Styles */
        input[type=range] { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #333; border-radius: 5px; outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: var(--accent-fuchsia); cursor: pointer; border-radius: 50%; }
        input[type=range]::-moz-range-thumb { width: 16px; height: 16px; background: var(--accent-fuchsia); cursor: pointer; border-radius: 50%; }

        .xml-tag, .dependency-tag, .var-library-tag {
            background-color: #333;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .xml-tag:hover, .dependency-tag:hover, .var-library-tag:hover {
            background-color: var(--accent-fuchsia);
        }
        .gallery-card {
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .gallery-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(216, 18, 91, 0.1), 0 4px 6px -2px rgba(216, 18, 91, 0.05);
        }
        /* Standard fixed-width card to match Node Flow node sizing */
        .standard-card {
            width: 280px; /* Match .flow-node width */
        }
        .read-mode-blur {
            filter: blur(5px);
            transition: filter 0.3s ease-in-out;
        }
        .diff-view del {
            background-color: var(--diff-del-bg);
            text-decoration: none;
            padding: 0.1em 0;
            border-radius: 2px;
        }
        .diff-view ins {
            background-color: var(--diff-ins-bg);
            text-decoration: none;
            padding: 0.1em 0;
            border-radius: 2px;
        }
        #find-replace-bar {
            transition: all 0.3s ease-in-out;
            max-height: 0;
            overflow: hidden;
            padding: 0;
            border-bottom: 0px solid var(--border-dark);
        }
        #find-replace-bar.visible {
             max-height: 100px; /* Altura suficiente para o conteúdo */
             padding: 0.5rem;
             border-bottom-width: 1px;
        }
        textarea::selection {
            background-color: var(--accent-fuchsia);
            color: white;
        }
        .highlight {
            background-color: var(--highlight-bg);
        }
        /* Estilos para o Gráfico de Dependências */
        #dependency-graph-svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #dependency-graph-svg:active {
            cursor: grabbing;
        }
        .graph-node {
             cursor: pointer;
        }
        .graph-node circle {
            stroke: var(--accent-fuchsia);
            stroke-width: 1.5px;
            transition: transform 0.2s, stroke-width 0.2s;
        }
        .graph-node:hover circle {
            transform: scale(1.2);
            stroke-width: 3px;
        }
        .graph-node.selected-for-connection circle {
            stroke: var(--accent-mint);
            stroke-width: 4px;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }
        .graph-node text {
            fill: var(--text-dark);
            font-size: 10px;
            pointer-events: none;
            text-anchor: middle;
            font-family: 'Inter', sans-serif;
        }
        .graph-link {
            stroke: var(--border-dark);
            stroke-opacity: 0.7;
            stroke-width: 1.5px;
            transition: stroke 0.2s, stroke-width 0.2s;
        }
        .graph-link:hover {
            stroke-width: 3px;
        }
        .graph-link.selected {
            stroke: var(--accent-red);
            stroke-width: 4px;
        }
        #graph-tooltip {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            background-color: var(--card-bg-dark);
            border: 1px solid var(--border-dark);
            border-radius: 0.5rem;
            padding: 0.75rem;
            font-size: 0.75rem;
            min-width: 250px;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3), 0 4px 6px -2px rgba(0,0,0,0.25);
            z-index: 100;
        }
        /* Estilos para Tags */
        .prompt-tag, .manager-tag {
            background-color: #333;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-family: 'Roboto Mono', monospace;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .manager-tag span[contenteditable]:focus {
            outline: 1px solid var(--accent-fuchsia);
            background-color: #444;
        }
        .prompt-tag .remove-tag-btn, .manager-tag .remove-tag-btn {
            cursor: pointer;
            color: var(--text-muted-dark);
        }
        .prompt-tag .remove-tag-btn:hover, .manager-tag .remove-tag-btn:hover {
            color: var(--accent-red);
        }
        .prompt-tag.auto-tag {
            background-color: #2a2a2a;
            color: var(--text-muted-dark);
        }
        [data-theme="light"] .prompt-tag.auto-tag {
            background-color: #E5E7EB;
            color: var(--text-muted-dark);
        }
        /* Dropdown customizado */
        .custom-dropdown {
            position: absolute;
            z-index: 10;
            width: 100%;
            max-height: 150px;
            overflow-y: auto;
            background-color: var(--card-bg-dark);
            border: 1px solid var(--border-dark);
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
        }
        .custom-dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.875rem;
        }
        .custom-dropdown-item:hover {
            background-color: var(--accent-fuchsia);
            color: white;
        }
        [data-theme="light"] .custom-dropdown-item:hover {
            background-color: #F3F4F6;
            color: var(--text-dark);
        }
        /* Estilos do Mapa de Navegação */
        #navigation-map {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        .nav-map-tag {
            background-color: #333;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-family: 'Roboto Mono', monospace;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 1px solid var(--border-dark);
        }
        .nav-map-tag:hover {
            background-color: var(--accent-fuchsia);
            color: white;
        }
        /* Estilos para a lista da galeria de inputs */
        .input-gallery-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .input-gallery-item:hover {
            background-color: #333;
        }
        .input-gallery-item.selected {
            background-color: var(--accent-fuchsia);
            color: white;
        }
        .input-gallery-item .remove-btn {
            visibility: hidden;
            color: var(--text-muted-dark);
        }
        .input-gallery-item:hover .remove-btn {
            visibility: visible;
        }
        .input-gallery-item .remove-btn:hover {
            color: var(--accent-red);
        }
        /* Drawer list row */
        .drawer-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid var(--border-dark);
            background-color: var(--card-bg-dark);
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        .drawer-row:hover { background-color: #333; }
        .drawer-row.selected { background-color: var(--accent-fuchsia); color: #fff; border-color: var(--accent-fuchsia-hover); }
        [data-theme="light"] .drawer-row:hover { background-color: #F3F4F6; }
        [data-theme="light"] .drawer-row { background-color: #fff; }
        /* Estilos para Snippet Copy Button */
        #editor-container {
            overflow: hidden; /* Garante que os botões não saiam da área */
        }
        #snippet-buttons-overlay {
            pointer-events: none; /* O overlay em si não é clicável */
        }
        .copy-snippet-btn {
            position: absolute;
            pointer-events: all; /* Torna o botão clicável */
            background-color: #333;
            color: var(--text-muted-dark);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 5; /* Garante que fique sobre o texto */
        }
        .copy-snippet-btn:hover {
            background-color: var(--accent-fuchsia);
            color: white;
        }
        .copy-snippet-btn.copied {
            background-color: var(--diff-ins-bg);
            color: white;
            border-color: #3f6212;
        }
        
        /* --- ESTILOS NODE FLOW --- */
        #node-flow-canvas {
            background-color: #0c0c0c;
            background-image:
                radial-gradient(circle, rgba(255,255,255,0.07) 1px, transparent 1px);
            background-size:
                16px 16px; /* pontos */
            background-position:
                0 0, 0 0, 0 0;
            overflow: hidden;
            position: relative;
        }
        #node-flow-canvas:active {
            cursor: grabbing;
        }
        .node-flow-prompt-card {
            background-color: var(--card-bg-dark);
            border: 1px solid var(--border-dark);
            cursor: grab;
        }
        .node-flow-prompt-card:active {
            cursor: grabbing;
        }
        #node-flow-content {
            position: absolute;
            width: 100%;
            height: 100%;
            /* O transform será aplicado via JS */
        }
        .flow-node {
            position: absolute;
            border: 1px solid var(--border-dark);
            background-color: var(--card-bg-dark); /* Adicionado fundo ao card */
            cursor: move;
            width: 280px; /* Largura fixa para consistência */
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            user-select: none;
            transition: border-color 0.2s;
        }
        .flow-node:hover {
            border-color: var(--accent-fuchsia);
        }
        .flow-node.selected {
            border-color: var(--accent-red);
            box-shadow: 0 0 0 1px var(--accent-red) inset, 0 4px 6px rgba(0,0,0,0.3);
        }
        .flow-node .connector {
            position: absolute;
            width: 14px;
            height: 14px;
            background-color: #444;
            border: 1px solid var(--text-muted-dark);
            border-radius: 50%;
            cursor: crosshair;
            transition: background-color 0.2s, transform 0.2s;
            z-index: 10;
        }
        .flow-node:hover .connector {
            transform: scale(1.2);
        }
        .flow-node .connector:hover {
            background-color: var(--accent-mint);
        }
        .flow-node .connector.output {
            right: -7px;
            top: 50%;
            transform: translateY(-50%);
        }
        #node-flow-connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* let underlying nodes receive events */
        }
        .connection-line {
            stroke: var(--accent-fuchsia);
            stroke-width: 2;
            fill: none;
            pointer-events: stroke; /* allow hitting the path without blocking entire overlay */
            cursor: pointer;
        }
        .connection-line:hover {
            stroke-width: 4;
            stroke: var(--accent-red);
        }
    </style>
</head>
<body>

    <div id="root" class="flex flex-col h-screen">
    <header id="main-header" class="bg-[--card-bg-dark] border-b border-[--border-dark] px-6 py-2 flex items-center justify-between relative z-20">
            <div class="flex items-center gap-3">
                <!-- LOGO SVG -->
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: rotate(15deg);">
                    <path d="M9 21C9 21.5523 8.55228 22 8 22H7C6.44772 22 6 21.5523 6 21V20H9V21Z" fill="#5A5A5A"/>
                    <path d="M10 4H14C14.5523 4 15 3.55228 15 3V2C15 1.44772 14.5523 1 14 1H10C9.44772 1 9 1.44772 9 2V3C9 3.55228 9.44772 4 10 4Z" fill="#A8763E"/>
                    <path d="M17 9V8C17 6.34315 15.6569 5 14 5H10C8.34315 5 7 6.34315 7 8V9C4.23858 9 2 11.2386 2 14V17C2 19.2091 3.79086 21 6 21H9V20H6C4.34315 20 3 18.6569 3 17V14C3 11.7909 4.79086 10 7 10H17C19.2091 10 21 11.7909 21 14V17C21 18.6569 19.6569 20 18 20H15V21H18C20.2091 21 22 19.2091 22 17V14C22 11.2386 19.7614 9 17 9Z" fill="#5A5A5A"/>
                    <path d="M18 11H6C5.44772 11 5 11.4477 5 12V17C5 18.1046 5.89543 19 7 19H17C18.1046 19 19 18.1046 19 17V12C19 11.4477 18.5523 11 18 11Z" fill="url(#potion-gradient)"/>
                    <defs>
                        <linearGradient id="potion-gradient" x1="12" y1="11" x2="12" y2="19" gradientUnits="userSpaceOnUse">
                            <stop stop-color="#D8125B"/>
                            <stop offset="1" stop-color="#F871B1"/>
                        </linearGradient>
                    </defs>
                </svg>
                <h1 class="text-xl font-bold font-mono" style="color: var(--accent-fuchsia);">PromptMana</h1>
            </div>
            <!-- Centered Read Mode button -->
            <div class="absolute inset-x-0 flex justify-center items-center gap-2 pointer-events-none">
                <button id="read-mode-btn" title="Read Mode" class="p-2 rounded-full hover:bg-[#333] pointer-events-auto">
                    <!-- Olho Fechado (Padrão) -->
                    <svg id="read-mode-icon-closed" class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M3.98 8.223A10.477 10.477 0 001.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.45 10.45 0 0112 4.5c4.756 0 8.773 3.162 10.065 7.498a10.522 10.522 0 01-4.293 5.774M6.228 6.228L3 3m3.228 3.228l3.65 3.65m7.894 7.894L21 21m-3.228-3.228l-3.65-3.65m0 0a3 3 0 10-4.243-4.243m4.243 4.243a3 3 0 01-4.243-4.243" />
                    </svg>
                    <!-- Olho Aberto (Oculto) -->
                    <svg id="read-mode-icon-open" class="w-6 h-6 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M2.036 12.322a1.012 1.012 0 010-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.432 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178z" />
                      <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                </button>
                <button id="run-prompt-btn" title="Run Prompt" class="p-2 rounded-full hover:bg-[#333] pointer-events-auto">
                    <!-- Play icon -->
                    <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M8 5.14v13.72c0 .79.86 1.27 1.54.84l10.62-6.86a1 1 0 000-1.68L9.54 4.3A1 1 0 008 5.14z" />
                    </svg>
                </button>
                <button id="dashboard-btn" title="Dashboard" class="p-2 rounded-full hover:bg-[#333] pointer-events-auto">
                    <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 3v18h18M7 15v3m5-7v7m5-11v11" />
                    </svg>
                </button>
            </div>
            <div class="flex items-center gap-2">
                <button id="theme-toggle" class="action-button p-1.5" aria-label="Toggle theme">
                    <!-- Sun (light mode indicator) - outline version -->
                    <svg id="icon-sun" class="w-4 h-4 hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m0 13.5V21m9-9h-2.25M5.25 12H3m15.364 6.364l-1.591-1.591M7.227 7.227L5.636 5.636m12.728 0l-1.591 1.591M7.227 16.773l-1.591 1.591M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
                    </svg>
                    <!-- Moon (dark mode indicator) -->
                    <svg id="icon-moon" class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/>
                    </svg>
                </button>
                <!-- Inline Auth (Magic Link) will render here -->
                                <div id="auth-inline" class="hidden items-center gap-2"></div>
                                <div id="profile-inline" class="hidden items-center gap-2 ml-2">
                                    <span id="profile-email" class="text-[10px] font-mono text-[--text-muted-dark]"></span>
                                    <input id="profile-fullname" type="text" placeholder="Full name" class="form-control compact-field rounded-md text-xs w-40 hidden"/>
                                    <button id="profile-edit-btn" class="action-button text-xs hidden">Edit</button>
                                    <button id="profile-save-btn" class="action-button text-xs hidden">Save</button>
                                </div>
            </div>
        </header>

                <!-- Login Modal (Magic Link) -->
                <div id="login-modal" class="fixed inset-0 bg-black/60 hidden flex items-center justify-center z-50">
                    <div class="bg-[--card-bg-dark] border border-[--border-dark] rounded-lg shadow-2xl w-full max-w-md p-5">
                        <div class="flex items-center justify-between mb-3">
                            <h2 id="login-modal-title" class="text-lg font-semibold">Sign in</h2>
                            <button id="login-modal-close" class="p-1 rounded hover:bg-[#333]" aria-label="Close">&times;</button>
                        </div>
                        <p id="login-modal-desc" class="text-xs text-[--text-muted-dark] mb-3">Enter your email and password to sign in.</p>
                        <div class="space-y-2">
                            <input id="login-email-input" type="email" autocomplete="email" placeholder="you@email.com" class="form-control w-full rounded-md py-2 px-3"/>
                            <input id="login-password-input" type="password" autocomplete="current-password" placeholder="Password" class="form-control w-full rounded-md py-2 px-3"/>
                            <input id="login-password-confirm" type="password" autocomplete="new-password" placeholder="Confirm password" class="form-control w-full rounded-md py-2 px-3 hidden"/>
                            <button id="login-submit-btn" class="action-button primary w-full">Sign in</button>
                            <div class="flex items-center justify-between text-xs text-[--text-muted-dark]">
                                <button id="login-toggle-mode" class="underline hover:text-white" type="button">Create account</button>
                                <button id="login-forgot" class="underline hover:text-white" type="button">Forgot password?</button>
                            </div>
                            <p id="login-status" class="text-xs text-[--text-muted-dark] mt-1"></p>
                        </div>
                    </div>
                </div>

                <!-- Security: Cloud-only data (guard localStorage to UI-only keys) -->
                <script>
                    (function() {
                        const LS_ALLOW = new Set(['pm_theme']);
                        const orig = {
                            getItem: localStorage.getItem.bind(localStorage),
                            setItem: localStorage.setItem.bind(localStorage),
                            removeItem: localStorage.removeItem.bind(localStorage),
                            clear: localStorage.clear.bind(localStorage),
                            key: localStorage.key ? localStorage.key.bind(localStorage) : null,
                            length: Object.getOwnPropertyDescriptor(Object.getPrototypeOf(localStorage) || {}, 'length')
                        };
                        // Expose originals for intentional admin cleanup
                        window.__ls_orig = orig;

                        localStorage.getItem = (k) => (LS_ALLOW.has(k) ? orig.getItem(k) : null);
                        localStorage.setItem = (k, v) => { if (LS_ALLOW.has(k)) orig.setItem(k, v); };
                        localStorage.removeItem = (k) => { if (LS_ALLOW.has(k)) orig.removeItem(k); };
                        localStorage.clear = () => {
                            try {
                                // Remove everything except allowed keys
                                const keys = [];
                                for (let i = 0; i < window.__ls_orig.clear.length; i++) {
                                    const key = window.__ls_orig.key ? window.__ls_orig.key(i) : null;
                                    if (key) keys.push(key);
                                }
                                keys.forEach(k => { if (!LS_ALLOW.has(k)) orig.removeItem(k); });
                            } catch (_) {
                                // Fallback: attempt common app keys wipe
                                const COMMON_KEYS = [
                                    'PROMPTS_STORAGE_KEY','TEMPLATES_STORAGE_KEY','INPUT_GALLERY_STORAGE_KEY','NODE_FLOWS_STORAGE_KEY',
                                    'XML_TAGS_STORAGE_KEY','VAR_LIBRARY_STORAGE_KEY','LLM_LIST_STORAGE_KEY','PROJECTS_STORAGE_KEY',
                                    'PROJECT_REPO_MAP_STORAGE_KEY','GENERAL_TAGS_LIB_KEY','github_repo_list','llm_multi','llm_active',
                                    'gh_multi','gh_active','gh_repo'
                                ];
                                COMMON_KEYS.forEach(k => orig.removeItem(k));
                            }
                        };

                        // One-time purge of legacy keys on load
                        try { localStorage.clear(); } catch {}
                        // Add a global helper to purge again after auth
                        window.clearAppLocalData = function() { try { localStorage.clear(); } catch {} };
                    })();
                </script>

        <div id="main-content" class="flex flex-grow overflow-hidden transition-filter duration-300">
            <!-- PAINEL ESQUERDO -->
          <aside class="sidebar p-4 flex flex-col">
              <button id="add-prompt-btn" class="action-button nav-button primary w-full text-center font-medium">Add Prompt</button>
              <hr class="border-[--border-dark] my-4">
                  <div class="space-y-2">
                            <button id="templates-btn" class="action-button nav-button w-full text-left font-medium">Templates</button>
                     <button id="projects-btn" class="action-button nav-button w-full text-left font-medium">Projects</button>
                     <button id="gallery-btn" class="action-button nav-button w-full text-left font-medium">Prompt Gallery</button>
                     <button id="input-gallery-btn" class="action-button nav-button w-full text-left font-medium">Input Gallery</button>
                     <button id="list-manager-btn" class="action-button nav-button w-full text-left font-medium">List Manager</button>
                 </div>
                 <hr class="border-[--border-dark] my-4">
                 <div class="space-y-2">
                     <button id="node-flow-btn" class="action-button nav-button w-full text-left font-medium">Node Flow</button>
                     <button id="graph-view-btn" class="action-button nav-button w-full text-left font-medium">Graph View</button>
                 </div>
                 <hr class="border-[--border-dark] my-4">

           <!-- Save actions moved to left panel -->
                                 <div class="space-y-2">
                             <button id="import-btn" class="action-button nav-button w-full text-left font-medium">Import</button>
                            <button id="import-from-git-btn" class="action-button nav-button w-full text-left font-medium">Import from Git</button>
                            <hr class="border-[--border-dark] my-2">
                             <button id="add-major-version-btn" class="action-button nav-button w-full text-left font-medium">Save Major Version</button>
               <button id="add-minor-version-btn" class="action-button nav-button w-full text-left font-medium">Save New Version</button>
               <button id="save-changes-btn" class="action-button nav-button w-full text-left font-medium">Save Changes</button>
               <button id="save-as-template-btn" class="action-button nav-button w-full text-left font-medium">Save as Template</button>
               <button id="fork-version-btn" class="action-button nav-button w-full text-left font-medium">Fork Version</button>
               <button id="delete-version-btn" class="action-button nav-button w-full text-left font-medium text-red-500 hover:bg-red-900/20 hover:border-red-800">Delete Version</button>
           </div>
            </aside>

            <!-- Config Dock (Photoshop-style) -->
            <div id="config-dock" class="relative border-r border-[--border-dark] flex flex-col items-center py-2" style="width: 48px; background-color: var(--panel-bg);">
                <!-- Icon buttons -->
                <div class="dock-item">
                <button id="dock-project-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="Project">
                    <!-- Folder icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12.75V8.25A2.25 2.25 0 014.5 6h3.879a2.25 2.25 0 001.59-.659l1.06-1.06A2.25 2.25 0 0112.62 3h6.88A2.25 2.25 0 0121.75 5.25V7.5m0 0v9A2.25 2.25 0 0119.5 18.75H4.5A2.25 2.25 0 012.25 16.5v-9A2.25 2.25 0 014.5 5.25H9"/></svg>
                </button>
                <span class="dock-tooltip">Project</span>
                </div>
                <div class="dock-item">
                <button id="dock-github-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="GitHub Repo">
                    <!-- GitHub icon -->
                    <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.477 2 2 6.486 2 12.019c0 4.425 2.865 8.178 6.839 9.504.5.092.682-.217.682-.483 0-.237-.009-.866-.013-1.7-2.782.604-3.369-1.342-3.369-1.342-.455-1.157-1.11-1.466-1.11-1.466-.907-.62.069-.607.069-.607 1.003.07 1.53 1.03 1.53 1.03.892 1.53 2.341 1.088 2.91.833.091-.647.35-1.088.636-1.339-2.22-.253-4.555-1.113-4.555-4.952 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.27.098-2.646 0 0 .84-.27 2.75 1.027A9.564 9.564 0 0 1 12 6.844c.851.004 1.707.115 2.506.338 1.909-1.297 2.748-1.027 2.748-1.027.546 1.376.203 2.393.1 2.646.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.696-4.566 4.944.359.31.678.92.678 1.854 0 1.338-.012 2.417-.012 2.746 0 .268.18.58.688.481C19.138 20.193 22 16.442 22 12.019 22 6.486 17.523 2 12 2Z"/>
                    </svg>
                </button>
                <span class="dock-tooltip">GitHub Repo</span>
                </div>
                <div class="dock-item">
                <button id="dock-tags-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="Tags">
                    <!-- Hashtag icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8 4v16M16 4v16M4 9h16M4 15h16"/>
                    </svg>
                </button>
                <span class="dock-tooltip">Tags</span>
                </div>
                <!-- Separator -->
                <div class="my-2 w-6 border-t border-[--border-dark] opacity-60"></div>
                <div class="dock-item">
                <button id="dock-llm-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="Target LLM">
                    <!-- Sparkles icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904l-1.06 3.181a.75.75 0 01-1.406 0l-1.06-3.181a4.5 4.5 0 00-2.847-2.847l-3.181-1.06a.75.75 0 010-1.406l3.181-1.06a4.5 4.5 0 002.847-2.847l1.06-3.181a.75.75 0 011.406 0l1.06 3.181a4.5 4.5 0 002.847 2.847l3.181 1.06a.75.75 0 010 1.406l-3.181 1.06a4.5 4.5 0 00-2.847 2.847zM16.5 4.5l.75-2.25.75 2.25L20.25 6l-2.25.75-.75 2.25-.75-2.25L15 6l1.5-1.5zm0 12l.75-2.25.75 2.25L20.25 18l-2.25.75-.75 2.25-.75-2.25L15 18l1.5-1.5z"/></svg>
                </button>
                <span class="dock-tooltip">Target LLM</span>
                </div>
                <div class="dock-item">
                <button id="dock-settings-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="Settings">
                    <!-- Sliders icon (clean and legible) -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 7h16M10 5v4M4 12h16M14 10v4M4 17h16M8 15v4"/>
                    </svg>
                </button>
                <span class="dock-tooltip">Settings</span>
                </div>
                <div class="dock-item">
                <button id="dock-input-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="Add Input">
                    <!-- Plus circle icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                </button>
                <span class="dock-tooltip">Add Input</span>
                </div>
                <div class="dock-item">
                <button id="dock-xml-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="XML Tags">
                    <!-- Code bracket icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 6.75L3 12l5.25 5.25m7.5-10.5L21 12l-5.25 5.25"/></svg>
                </button>
                <span class="dock-tooltip">XML Tags</span>
                </div>
                <div class="dock-item">
                <button id="dock-var-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="Var Library">
                    <!-- Stack icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3l8.485 4.243L12 11.485 3.515 7.243 12 3zm0 8.485l8.485 4.243L12 20 3.515 15.728 12 11.485z"/></svg>
                </button>
                <span class="dock-tooltip">Var Library</span>
                </div>

                <!-- Expanding drawer that opens to the left (right: full) -->
                <div id="config-drawer" class="absolute right-full top-0 h-full w-[320px] bg-[--card-bg-dark] border border-[--border-dark] rounded-md shadow-xl p-3 opacity-0 pointer-events-none transition-all duration-200 z-40">
                    <div class="flex items-center justify-between mb-2 gap-2">
                        <h3 id="config-drawer-title" class="text-sm font-semibold">Settings</h3>
                        <div class="flex items-center gap-1 ml-auto">
                            <!-- Header-scoped Add buttons (toggled per panel) -->
                            <button id="add-xml-tag-btn" class="hidden p-1 rounded hover:bg-[#333]" title="Add XML Tag">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6"/></svg>
                            </button>
                            <button id="add-var-library-btn" class="hidden p-1 rounded hover:bg-[#333]" title="Add Variable">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6"/></svg>
                            </button>
                            <button id="config-drawer-close" class="p-1 rounded hover:bg-[#333]" title="Close">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>
                            </button>
                        </div>
                    </div>
                    <hr class="border-[--border-dark] mb-2">
                    <div class="space-y-3 overflow-y-auto pr-1" style="max-height: calc(100% - 48px);">
                        <!-- Panel: Project (list only) -->
                        <div id="panel-project" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="project-search-input" placeholder="Search projects..." class="form-control compact-field rounded-md text-sm flex-1">
                                <button id="project-add-btn" class="p-1 rounded hover:bg-[#333]" title="Add Project">
                                    <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6"/></svg>
                                </button>
                            </div>
                            <div id="project-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                            <!-- keep hidden datalist for other UI parts that reference it -->
                            <datalist id="project-list-aside" class="hidden"></datalist>
                            <!-- hidden input kept for internal logic compatibility -->
                            <input id="project-name-input-aside" aria-label="Project" class="hidden">
                        </div>
                        <!-- Panel: LLM (list only) -->
                        <div id="panel-llm" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="llm-search-input" placeholder="Search models/groups..." class="form-control compact-field rounded-md text-sm flex-1">
                            </div>
                            <div id="llm-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                            <!-- hidden select kept for internal logic compatibility -->
                            <select id="llm-select" aria-label="Target LLM" class="hidden">
                                <option value="generic">Unspecified</option>
                            </select>
                        </div>
                        <!-- Panel: GitHub (repos assign) -->
                        <div id="panel-github" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="github-search-input" placeholder="Search repositories..." class="form-control compact-field rounded-md text-sm flex-1">
                            </div>
                            <div class="mt-1">
                                <div class="flex items-center justify-between mb-1">
                                    <button id="dock-github-repos-toggle" class="text-left text-xs font-semibold text-[--text-muted-dark] flex items-center gap-2">
                                        <span id="dock-github-repos-caret">▶</span> Repositories
                                    </button>
                                    <button id="dock-github-load-repos-btn" class="action-button text-xs">Load repos</button>
                                </div>
                                <div id="dock-github-available-repos" class="space-y-1 text-xs hidden"></div>
                            </div>
                            <div id="github-list-drawer" class="space-y-1 overflow-y-auto pr-1 mt-2"></div>
                            <p id="github-assign-hint" class="mt-2 text-[10px] text-[--text-muted-dark]"></p>
                        </div>
                        <!-- Panel: Tags (list only) -->
                        <div id="panel-tags" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="tags-search-input" placeholder="Search tags..." class="form-control compact-field rounded-md text-sm flex-1">
                                <button id="tags-add-btn" class="p-1 rounded hover:bg-[#333]" title="Add Tag">
                                    <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6"/></svg>
                                </button>
                            </div>
                            <div id="tags-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                            <!-- keep hidden chips container for internal logic; the list reflects its state -->
                            <div id="tags-container-aside" class="hidden"></div>
                            <!-- hidden input/dropdown kept for compatibility -->
                            <input id="tags-input-aside" class="hidden">
                            <div id="tags-dropdown-aside" class="hidden"></div>
                        </div>
                        <!-- Panel: XML Tags (list only) -->
                        <div id="panel-xml" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="xml-search-input" placeholder="Search XML tags..." class="form-control compact-field rounded-md text-sm flex-1">
                            </div>
                            <div id="xml-tags-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                        </div>
                        <!-- Panel: Var Library (list only) -->
                        <div id="panel-var" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="var-search-input" placeholder="Search variables..." class="form-control compact-field rounded-md text-sm flex-1">
                            </div>
                            <div id="var-library-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                        </div>
                        <!-- Panel: Add Input (list only) -->
                        <div id="panel-input" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="input-search-input" placeholder="Search inputs..." class="form-control compact-field rounded-md text-sm flex-1">
                            </div>
                            <div id="add-input-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                        </div>

                        <!-- Panel: Settings (dynamic per model) -->
                        <div id="panel-settings" class="hidden">
                            <div id="dynamic-settings-container" class="space-y-2"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Área Principal de Edição -->
            <main class="flex-grow p-6 flex flex-col main-editor-area">
                
                
                <!-- Mapa de Navegação -->
                <div id="navigation-map" class="mb-4 p-2 bg-[--card-bg-dark] border border-[--border-dark] rounded-lg hidden"></div>

                <div class="editor-window flex-grow flex flex-col">
                    <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                        <div class="flex items-center flex-grow">
                            <input id="prompt-title-input" placeholder="Your prompt title..." class="form-input font-mono w-full px-2 py-2 text-2xl font-medium">
                            <button id="copy-prompt-btn" title="Copy prompt content" class="ml-2 p-2 rounded-md text-[--text-muted-dark] hover:text-white hover:bg-[#333]">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                            </button>
                        </div>
                        <button id="find-btn" title="Find and Replace (Ctrl+F)" class="p-2 rounded-md text-[--text-muted-dark] hover:text-white hover:bg-[#333]">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                              <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" />
                            </svg>
                        </button>
                        <button id="toggle-comments-btn" title="Comments" class="p-2 rounded-md text-[--text-muted-dark] hover:text-white hover:bg-[#333]">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12c0 4.556-4.03 8.25-9 8.25a9.764 9.764 0 01-2.555-.337A5.972 5.972 0 015.41 20.97a5.969 5.969 0 01-.474-.065 4.48 4.48 0 00.978-2.025c.09-.457-.133-.901-.467-1.226C3.93 16.178 3 14.189 3 12c0-4.556 4.03-8.25 9-8.25s9 3.694 9 8.25z" />
                            </svg>
                        </button>
                    </div>
                    
                    <!-- Find and Replace Bar -->
                    <div id="find-replace-bar">
                        <div class="grid grid-cols-2 gap-2">
                            <input id="find-input" type="text" placeholder="Find..." class="form-control text-xs rounded-md py-1 px-2">
                            <input id="replace-input" type="text" placeholder="Replace with..." class="form-control text-xs rounded-md py-1 px-2">
                        </div>
                        <div class="flex items-center gap-2 mt-2">
                            <span id="find-counter" class="text-xs font-mono text-[--text-muted-dark]">0/0</span>
                            <button id="prev-btn" class="action-button text-xs p-1" disabled>Previous</button>
                            <button id="next-btn" class="action-button text-xs p-1" disabled>Next</button>
                            <button id="replace-btn" class="action-button text-xs" disabled>Replace</button>
                            <button id="replace-all-btn" class="action-button text-xs" disabled>Replace All</button>
                            <button id="close-find-btn" class="action-button text-xs p-1 ml-auto">&times;</button>
                        </div>
                    </div>
                    <div class="flex-grow p-1 relative" id="editor-container">
                        <textarea id="main-editor" placeholder="Have a new big idea to change the world with your prompt? 
Write, right here, right now. Show me your mana!" class="form-input font-mono w-full h-full p-4 text-base leading-relaxed resize-none"></textarea>
                        <div id="snippet-buttons-overlay" class="absolute top-0 left-0 w-full h-full p-4 pointer-events-none"></div>
                    </div>
                    <!-- Barra de Dependência -->
                    <div id="dependency-bar" class="p-2 border-t border-[--border-dark]">
                        <div class="flex items-center justify-between gap-3">
                            <div class="flex items-center gap-2 flex-wrap">
                                <span class="text-xs font-bold text-[--text-muted-dark]">Dependence</span>
                                <div id="dependency-tag-container" class="flex items-center gap-2 flex-wrap"></div>
                            </div>
                            <div class="relative" id="dependencies-popover">
                                <button id="edit-dependencies-btn" class="action-button text-xs">Manage</button>
                                <!-- Larger popover for dependencies management (opens upwards) -->
                                <div id="dependencies-dropdown" class="hidden absolute right-0 bottom-full mb-2 bg-[--card-bg-dark] border border-[--border-dark] rounded-md shadow-xl w-[640px] max-w-[90vw] z-50">
                                    <div class="p-2 border-b border-[--border-dark]">
                                        <input id="dependencies-search" type="text" placeholder="Search prompt..." class="form-control w-full rounded-md py-1.5 px-3 text-sm">
                                    </div>
                                    <div id="dependencies-list" class="max-h-96 overflow-y-auto"></div>
                                    <div class="p-2 border-t border-[--border-dark] flex justify-end gap-2">
                                        <button id="deps-cancel-btn" class="action-button text-xs">Cancel</button>
                                        <button id="deps-apply-btn" class="action-button primary text-xs">Apply</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- Seção de Variáveis -->
                     <div id="variables-section" class="p-4 border-t border-[--border-dark] hidden">
                         <h3 class="text-sm font-bold text-[--text-muted-dark] mb-2">Prompt Variables</h3>
                         <div id="variables-container" class="space-y-2"></div>
                     </div>
                    <!-- Seção de Comentários -->
                    <div id="comments-section" class="p-4 border-t border-[--border-dark] hidden">
                        <h3 class="text-sm font-bold text-[--text-muted-dark] mb-2">Version Comments</h3>
                        <textarea id="comments-textarea" placeholder="Note the purpose of the version, tests, results..." class="form-input font-sans w-full h-24 p-2 text-sm leading-relaxed resize-none rounded-md" style="background-color: var(--input-bg);"></textarea>
                    </div>
                     <div class="flex items-center justify-between p-2 border-t border-[--border-dark]">
                         <div id="status-selector-container" class="flex items-center justify-center">
                             <div class="status-selector flex rounded-lg overflow-hidden">
                                 <button class="status-option px-4 py-1.5 text-sm" data-status="write">Write</button>
                                 <button class="status-option px-4 py-1.5 text-sm" data-status="test">Test</button>
                                 <button class="status-option px-4 py-1.5 text-sm" data-status="edit">Edit</button>
                                 <button class="status-option px-4 py-1.5 text-sm" data-status="use">Use</button>
                             </div>
                         </div>
                         <div id="editor-stats" class="text-xs font-mono pr-4">0 tokens / 0 words / 0 characters</div>
                     </div>
                </div>
            </main>

            <!-- Painel de Ações (Direita) -->
            <aside class="action-panel p-4 flex flex-col">
                <div class="flex flex-col flex-grow overflow-hidden">
                    <div class="flex justify-between items-center mb-3">
                        <h2 class="text-base font-semibold">Versions</h2>
                        <button id="compare-versions-btn" class="action-button text-xs" disabled>Compare</button>
                    </div>

                    <div id="filters-container" class="space-y-3 mb-3 flex-shrink-0">
                        <div class="relative">
                            <input id="search-versions-input" placeholder="Search by title, project or #tag..." class="form-control w-full rounded-md py-1.5 px-3 text-sm focus:ring-2">
                        </div>
                        <div id="status-filter-container" class="flex flex-wrap gap-2">
                            <button class="filter-tag-btn active" data-filter="all">All</button>
                            <button class="filter-tag-btn" data-filter="write">Write</button>
                            <button class="filter-tag-btn" data-filter="test">Test</button>
                            <button class="filter-tag-btn" data-filter="edit">Edit</button>
                            <button class="filter-tag-btn" data-filter="use">Use</button>
                        </div>
                    </div>

                    <hr class="border-[--border-dark] mb-3">

                    <div id="versions-history-list" class="flex-grow overflow-y-auto space-y-1 pr-2">
                        <!-- Lista hierárquica de versões será inserida aqui -->
                    </div>
                </div>
                <div class="mt-auto space-y-2">
                    <hr class="border-[--border-dark] my-2">
                    <button id="commit-changes-btn" class="action-button nav-button primary w-full text-left font-medium">Commit Changes</button>
                    <button id="download-json-btn" class="action-button nav-button primary w-full text-left font-medium">Json Download</button>
                    <button id="download-md-btn" class="action-button nav-button primary w-full text-left font-medium">Markdown Download</button>
                    <button id="download-txt-btn" class="action-button nav-button primary w-full text-left font-medium">Text Download</button>
                </div>
            </aside>
        </div>
        <!-- API Console button + DB status (bottom-left corner) -->
        <div class="fixed bottom-3 left-4 z-30 flex flex-col items-start gap-2">
            <button id="api-console-btn" class="action-button nav-button text-xs px-2 py-1 font-medium hover:bg-[#333]">API Console</button>
            <div class="flex items-center gap-2">
                <span id="db-status-pill" class="text-xs font-mono px-2 py-0.5 border border-[--border-dark] rounded-md text-[--text-muted-dark]"></span>
                <span id="llm-status-pill" class="text-xs font-mono px-2 py-0.5 border border-[--border-dark] rounded-md text-[--text-muted-dark]"></span>
            </div>
            <input id="import-file-input" type="file" accept=".txt,.md,.pdf,.docx,.doc" class="hidden" />
        </div>
    </div>

    <!-- Modal: Run Prompt -->
    <div id="run-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center gap-3">
                <h2 class="text-xl font-bold">Run Prompt</h2>
                <div class="ml-auto flex items-center gap-2 text-xs text-[--text-muted-dark]">
                    <span id="run-active-llm" class="font-mono"></span>
                    <button id="close-run-modal" class="p-2 rounded-full hover:bg-[#333]" title="Close">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <div class="flex-1 grid grid-cols-2 gap-4 p-4 overflow-hidden">
                <div class="panel-soft p-3 rounded-md h-full flex flex-col overflow-hidden">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="font-semibold text-sm">Request</h3>
                        <div class="flex items-center gap-2">
                            <button id="copy-run-request-btn" class="action-button text-xs">Copy</button>
                        </div>
                    </div>
                    <pre id="run-request-view" class="font-mono text-xs whitespace-pre-wrap flex-1 overflow-auto"></pre>
                </div>
                <div class="panel-soft p-3 rounded-md h-full flex flex-col overflow-hidden">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="font-semibold text-sm">Response</h3>
                        <div class="flex items-center gap-2">
                            <button id="copy-run-response-btn" class="action-button text-xs">Copy</button>
                        </div>
                    </div>
                    <div id="run-loading" class="text-xs text-[--text-muted-dark] hidden">Running…</div>
                    <pre id="run-response-view" class="font-mono text-xs whitespace-pre-wrap flex-1 overflow-auto"></pre>
                </div>
            </div>
            <div class="p-3 border-t border-[--border-dark] flex items-center gap-3">
                <button id="run-cancel-btn" class="action-button">Close</button>
                <button id="run-execute-btn" class="action-button primary">Run</button>
                <span id="run-error" class="text-xs text-red-500 font-mono"></span>
            </div>
        </div>
    </div>

    <!-- Modal: Import from Git -->
    <div id="import-git-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center gap-3">
                <h2 class="text-xl font-bold">Import from GitHub</h2>
                <div class="ml-auto flex items-center gap-2">
                    <button id="refresh-git-browser-btn" class="action-button text-xs">Refresh</button>
                    <button id="close-import-git-modal" class="p-2 rounded-full hover:bg-[#333]" title="Close">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <div class="flex-1 grid grid-cols-2 gap-0 min-h-[360px] max-h-full">
                <div class="border-r border-[--border-dark] p-3 overflow-y-auto">
                    <div class="flex items-center justify-between mb-2">
                        <div class="text-xs font-semibold text-[--text-muted-dark]">Repositories</div>
                        <button id="git-browser-load-repos-btn" class="action-button text-xs">Load</button>
                    </div>
                    <div id="git-browser-repos" class="space-y-1 text-sm"></div>
                </div>
                <div class="p-3 overflow-y-auto">
                    <div class="flex items-center justify-between mb-2">
                        <div class="text-xs font-semibold text-[--text-muted-dark]">Markdown files</div>
                        <input id="git-files-filter" placeholder="Filter (*.md)" class="form-control compact-field rounded-md text-xs w-40">
                    </div>
                    <div id="git-browser-files" class="space-y-1 text-sm"></div>
                </div>
            </div>
            <div class="p-3 border-t border-[--border-dark] flex items-center gap-3">
                <div class="flex-1 flex items-center gap-2">
                    <input id="git-import-title" type="text" placeholder="Prompt title (optional)" class="form-control rounded-md py-1 px-2 text-sm flex-1">
                    <input id="git-import-project" list="project-list-aside" placeholder="Project (optional)" class="form-control rounded-md py-1 px-2 text-sm w-48">
                </div>
                <button id="git-import-cancel" class="action-button">Cancel</button>
                <button id="git-import-confirm" class="action-button primary" disabled>Load into editor</button>
            </div>
        </div>
    </div>

    <!-- Modal de Confirmação -->
    <div id="confirm-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-[--card-bg-dark] p-6 rounded-lg shadow-xl max-w-sm w-full border border-[--border-dark]">
            <h3 id="confirm-modal-title" class="text-lg font-bold mb-4"></h3>
            <p id="confirm-modal-text" class="text-[--text-muted-dark] mb-6"></p>
            <div id="confirm-modal-input-container" class="mb-4 hidden">
                <input id="confirm-modal-input" type="text" class="form-control w-full rounded-md py-1.5 px-3 text-sm">
            </div>
            <div id="confirm-modal-buttons" class="flex justify-end gap-4">
                <!-- Botões do modal serão inseridos aqui -->
            </div>
        </div>
    </div>

    <!-- Modal de Importação -->
    <div id="import-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-full max-w-lg rounded-lg shadow-xl border border-[--border-dark]">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">Import Document</h2>
                <button id="close-import-modal" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="p-4 space-y-3">
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Prompt name</label>
                    <input id="import-prompt-name" type="text" placeholder="Name..." class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Project</label>
                    <input id="import-project" list="project-list-aside" placeholder="Select or create..." class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Target LLM</label>
                    <select id="import-llm" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                        <option value="generic">Unspecified</option>
                    </select>
                </div>
            </div>
            <div class="p-4 border-t border-[--border-dark] flex justify-end gap-3">
                <button id="cancel-import" class="action-button">Cancel</button>
                <button id="confirm-import" class="action-button primary">Import</button>
            </div>
        </div>
    </div>

    <!-- Modal: Commit Changes -->
    <div id="commit-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-full max-w-md rounded-lg shadow-xl border border-[--border-dark]">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">Commit Changes</h2>
                <button id="close-commit-modal" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="p-4 space-y-3">
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Repository</label>
                    <div id="commit-repo-label" class="text-sm text-[--text-muted-dark] font-mono"></div>
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Branch</label>
                    <select id="commit-branch" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm"></select>
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">File path</label>
                    <input id="commit-file-path" type="text" placeholder="e.g. docs/prompt.md" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm">
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Commit message</label>
                    <input id="commit-message" type="text" placeholder="Describe your change" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm">
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Latest commit</label>
                    <div id="commit-latest-info" class="mt-1 text-xs text-[--text-muted-dark] font-mono break-words"></div>
                </div>
            </div>
            <div class="p-4 border-t border-[--border-dark] flex justify-end gap-3">
                <button id="cancel-commit" class="action-button">Cancel</button>
                <button id="confirm-commit" class="action-button primary">Commit</button>
            </div>
        </div>
    </div>

    <!-- Modal: API Console -->
    <div id="api-console-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">API Console</h2>
                <button id="close-api-console-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="flex flex-col md:flex-row flex-1 overflow-hidden">
                <!-- Left: Nav -->
                <div class="w-full md:w-56 border-r border-[--border-dark] p-4 space-y-2 flex-shrink-0">
                    <button data-api-tab="llm" class="action-button nav-button w-full text-left text-sm font-medium api-tab-btn">LLM</button>
                    <button data-api-tab="git" class="action-button nav-button w-full text-left text-sm font-medium api-tab-btn">GitHub</button>
                </div>
                <!-- Right: Content -->
                <div class="flex-1 p-4 overflow-y-auto">
                    
                    <!-- LLM -->
                    <div id="api-panel-llm" class="space-y-4 hidden">
                        <p class="text-[--text-muted-dark] text-sm">Set your LLM API to use in the app.</p>
                        <div class="grid md:grid-cols-2 gap-4">
                            <div class="panel-soft p-3 rounded-md space-y-3">
                                <div>
                                    <label class="text-xs font-medium text-[--text-muted-dark]">LLM API Base URL</label>
                                    <input id="llm-api-base-input" type="text" placeholder="https://api.openai.com/v1" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                                </div>
                                <div>
                                    <label class="text-xs font-medium text-[--text-muted-dark]">LLM API Key</label>
                                    <input id="llm-api-key-input" type="password" placeholder="sk-..." class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                                </div>
                                <label class="flex items-center gap-2 text-xs">
                                    <input id="llm-store-server-checkbox" type="checkbox" class="rounded" checked>
                                    <span>Store securely on server (requires proxy + Supabase)</span>
                                </label>
                                <div class="flex items-center gap-2">
                                    <button id="llm-test-btn" class="action-button">Test</button>
                                    <span id="llm-test-status" class="text-xs font-mono"></span>
                                </div>
                                <div class="mt-2 p-2 border border-[--border-dark] rounded-md bg-[--panel-bg]">
                                    <div class="flex items-center justify-between mb-1">
                                        <h4 class="text-xs font-semibold">Configure via curl</h4>
                                        <span id="llm-curl-status" class="text-[10px] font-mono"></span>
                                    </div>
                                    <textarea id="llm-curl-input" rows="4" placeholder="curl https://api.x.ai/v1/chat/completions -H 'Authorization: Bearer xai-...' -H 'Content-Type: application/json' -d '{ \"model\": \"grok-3-mini-beta\", \"messages\": [...] }'" class="form-control w-full rounded-md px-2 py-1 text-xs"></textarea>
                                    <div class="flex items-center gap-2 mt-2">
                                        <button id="llm-parse-curl-btn" class="action-button text-xs">Parse curl</button>
                                        <button id="llm-add-curl-btn" class="action-button text-xs">Add LLM from curl</button>
                                    </div>
                                    <div class="text-[--text-muted-dark] text-[11px] mt-1">We’ll extract the base URL and API key from your curl. Nothing is saved until you click “Add”.</div>
                                </div>
                            </div>
                            <div class="panel-soft p-3 rounded-md text-xs text-[--text-muted-dark]">
                                Security: Secrets are never stored in your browser. They must be stored securely on your Supabase project and used via Edge Functions—never exposed to the client at runtime.
                            </div>
                        </div>
                        <hr class="border-[--border-dark]">
                        <div class="flex items-center justify-between">
                            <h3 class="text-sm font-semibold">LLM Connections</h3>
                            <div class="flex items-center gap-2">
                                <button id="llm-rebuild-llm-list-btn" title="Rebuild Target LLM from saved model caches" class="action-button text-xs">Rebuild</button>
                                <button id="llm-add-api-btn" class="action-button text-xs">Add LLM API</button>
                            </div>
                        </div>
                        <div id="llm-api-list" class="space-y-2"></div>
                        <div class="mt-3">
                            <div class="flex items-center justify-between mb-1">
                                <button id="llm-provider-openai-toggle" class="text-left text-xs font-semibold text-[--text-muted-dark] flex items-center gap-2">
                                    <span id="llm-provider-openai-caret">▶</span> LLM Models
                                </button>
                                <button id="llm-load-models-btn" class="action-button text-xs">Load models</button>
                            </div>
                            <div id="llm-available-models" class="space-y-1 text-xs pl-4 hidden"></div>
                        </div>
                    </div>
                    <!-- Git -->
                    <div id="api-panel-git" class="space-y-4 hidden">
                        <p class="text-[--text-muted-dark] text-sm">Integrate your GitHub account to publish prompts to repositories.</p>
                        <div class="grid md:grid-cols-2 gap-4">
                            <div class="panel-soft p-3 rounded-md space-y-3">
                                <div>
                                    <label class="text-xs font-medium text-[--text-muted-dark]">GitHub Token</label>
                                    <input id="github-token-input" type="password" placeholder="ghp_..." class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                                </div>
                                <div>
                                    <label class="text-xs font-medium text-[--text-muted-dark]">Default Repo (owner/repo)</label>
                                    <input id="github-repo-input" type="text" placeholder="owner/repo" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                                </div>
                                <label class="flex items-center gap-2 text-xs">
                                    <input id="gh-store-server-checkbox" type="checkbox" class="rounded" checked>
                                    <span>Store securely on server (requires proxy + Supabase)</span>
                                </label>
                                <div class="flex items-center gap-2">
                                    <button id="github-test-btn" class="action-button">Test</button>
                                    <span id="github-test-status" class="text-xs font-mono"></span>
                                </div>
                            </div>
                            <div class="panel-soft p-3 rounded-md text-xs text-[--text-muted-dark]">
                                The token needs the repo scope to create/update files via the API. Tokens are never stored in your browser. They are stored securely on your Supabase project and requests go through Edge Functions.
                            </div>
                        </div>
                        <hr class="border-[--border-dark]">
                        <div class="flex items-center justify-between">
                            <h3 class="text-sm font-semibold">Repositories</h3>
                            <button id="github-add-repo-btn" class="action-button text-xs">Add repository</button>
                        </div>
                        <div id="github-repo-list" class="space-y-2"></div>
                        <div class="mt-3">
                            <div class="flex items-center justify-between mb-1">
                                <button id="github-repos-toggle" class="text-left text-xs font-semibold text-[--text-muted-dark] flex items-center gap-2">
                                    <span id="github-repos-caret">▶</span> Repositories
                                </button>
                                <button id="github-load-repos-btn" class="action-button text-xs">Load repos</button>
                            </div>
                            <div id="github-available-repos" class="space-y-1 text-xs hidden"></div>
                        </div>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal da Galeria -->
    <div id="gallery-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">Gallery</h2>
                <button id="close-gallery-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div id="gallery-grid" class="p-6 grid gap-3 overflow-y-auto justify-start" style="grid-template-columns: repeat(auto-fill, minmax(280px, 280px));">
                <!-- Cards da galeria serão inseridos aqui -->
            </div>
        </div>
    </div>

    <!-- Modal de Projetos -->
    <div id="projects-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">Projects</h2>
                <div class="flex items-center gap-4">
                    <button id="add-project-btn" class="action-button primary text-sm">Add Project</button>
                    <button id="close-projects-btn" class="p-2 rounded-full hover:bg-[#333]">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div id="projects-list-container" class="p-6 overflow-y-auto">
                <!-- Lista de projetos será inserida aqui -->
            </div>
            <div id="add-project-popup" class="modal-overlay hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
                <div class="bg-[--card-bg-dark] p-6 rounded-lg shadow-xl max-w-sm w-full border border-[--border-dark]">
                    <h3 class="text-lg font-bold mb-4">Add New Project</h3>
                    <p class="text-[--text-muted-dark] mb-6">Enter the name of the new project:</p>
                    <input id="new-project-name-input" type="text" placeholder="Project name..." class="form-control w-full rounded-md py-1.5 px-3 text-sm mb-4">
                    <div class="flex justify-end gap-4">
                        <button id="cancel-add-project-btn" class="action-button">Cancel</button>
                        <button id="confirm-add-project-btn" class="action-button primary">Add</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Templates -->
    <div id="templates-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <div class="flex items-center gap-4">
                    <h2 class="text-xl font-bold">Templates</h2>
                    <div class="hidden sm:block">
                        <label for="templates-project-filter" class="text-xs font-medium text-[--text-muted-dark]">Filter by Project:</label>
                        <select id="templates-project-filter" class="form-control w-auto mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2"></select>
                    </div>
                </div>
                <button id="close-templates-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div id="templates-grid-container" class="p-6 grid gap-3 overflow-y-auto justify-start" style="grid-template-columns: repeat(auto-fill, minmax(280px, 280px));">
                <!-- Cards de templates serão inseridos aqui -->
            </div>
        </div>
    </div>

    <!-- Modal Visualizador de Dependência -->
    <div id="dependency-viewer-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 id="dependency-viewer-title" class="text-xl font-bold">Dependency Viewer</h2>
                <button id="close-dependency-viewer-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="p-6 overflow-y-auto">
                <div class="panel-soft p-4">
                    <pre id="dependency-viewer-content" class="text-sm font-mono whitespace-pre-wrap"></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Visualizador de Comentários -->
    <div id="comments-viewer-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 id="comments-viewer-title" class="text-xl font-bold">Comments</h2>
                <button id="close-comments-viewer-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="p-6 overflow-y-auto">
                <div class="panel-soft p-4">
                    <pre id="comments-viewer-content" class="text-sm font-sans whitespace-pre-wrap leading-relaxed"></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Read Mode -->
    <div id="read-mode-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center hidden z-50 p-8 cursor-pointer">
        <div class="w-full max-w-4xl h-full max-h-[90vh] text-[--text-dark] p-8 overflow-hidden flex flex-col cursor-default">
            <div class="mb-3 flex items-start justify-between gap-4">
                <div>
                    <h2 id="read-mode-title" class="text-xl font-bold"></h2>
                    <div id="read-mode-meta" class="text-sm text-[--text-muted-dark] mt-1"></div>
                    <div id="read-mode-comments" class="text-sm text-[--text-muted-dark] mt-2 whitespace-pre-wrap"></div>
                </div>
                <div id="read-mode-stats" class="text-xs font-mono mt-1 text-right"></div>
            </div>
            <hr class="border-[--border-dark] my-2">
            <pre id="read-mode-content" class="flex-grow overflow-y-auto font-mono text-lg leading-relaxed whitespace-pre-wrap"></pre>
        </div>
    </div>

    <!-- Modal Dashboard -->
    <div id="dashboard-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-4">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-3 border-b border-[--border-dark] flex justify-between items-center flex-shrink-0">
                <div class="flex items-end gap-4">
                    <h2 class="text-xl font-bold">Dashboard</h2>
                    <div>
                        <label for="dashboard-period-select" class="text-xs font-medium text-[--text-muted-dark]">Group by:</label>
                        <select id="dashboard-period-select" class="form-control rounded-md py-1 px-2 text-xs focus:ring-2">
                            <option value="day">Day</option>
                            <option value="week">Week</option>
                            <option value="month" selected>Month</option>
                        </select>
                    </div>
                </div>
                <button id="close-dashboard-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="flex-grow p-3 overflow-auto">
                <div class="grid gap-3" style="grid-template-columns: repeat(3, minmax(0, 1fr));">
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Tokens / Words / Characters</h3>
                        <div class="chart-box"><canvas id="tokensChart"></canvas></div>
                    </div>
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Versions Created</h3>
                        <div class="chart-box"><canvas id="promptsChart"></canvas></div>
                    </div>
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Most Used Models</h3>
                        <div class="chart-box"><canvas id="modelsChart"></canvas></div>
                    </div>
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Prompts per Project</h3>
                        <div class="chart-box"><canvas id="projectsChart"></canvas></div>
                    </div>
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Status Distribution</h3>
                        <div class="chart-box"><canvas id="statusChart"></canvas></div>
                    </div>
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Top Tags</h3>
                        <div class="chart-box"><canvas id="tagsChart"></canvas></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Comparador de Versões -->
    <div id="diff-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 id="diff-modal-title" class="text-xl font-bold">Comparing Versions</h2>
                <button id="close-diff-modal-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="flex-grow grid grid-cols-2 gap-4 p-4 overflow-hidden w-full">
                <div class="diff-view p-4 rounded-md font-mono text-sm whitespace-pre-wrap h-full flex flex-col">
                    <h3 id="diff-title-a" class="font-bold text-lg mb-2"></h3>
                    <div id="diff-meta-a" class="text-xs font-sans text-[--text-muted-dark] mb-2"></div>
                    <div id="diff-comments-a" class="text-xs font-sans text-[--text-muted-dark] mb-2 whitespace-pre-wrap"></div>
                    <hr class="border-[--border-dark] my-2">
                    <div id="diff-panel-a" class="flex-grow overflow-auto"></div>
                </div>
                <div class="diff-view p-4 rounded-md font-mono text-sm whitespace-pre-wrap h-full flex flex-col">
                    <h3 id="diff-title-b" class="font-bold text-lg mb-2"></h3>
                    <div id="diff-meta-b" class="text-xs font-sans text-[--text-muted-dark] mb-2"></div>
                    <div id="diff-comments-b" class="text-xs font-sans text-[--text-muted-dark] mb-2 whitespace-pre-wrap"></div>
                    <hr class="border-[--border-dark] my-2">
                    <div id="diff-panel-b" class="flex-grow overflow-auto"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal Gráfico de Dependências -->
    <div id="dependency-graph-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">Graph View</h2>
                <button id="close-dependency-graph-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <!-- Seção de Filtros do Gráfico -->
            <div id="graph-filters" class="p-4 border-b border-[--border-dark] flex items-end gap-4 flex-shrink-0">
                <div>
                    <label for="graph-project-filter" class="text-xs font-medium text-[--text-muted-dark]">Filter by Project:</label>
                    <select id="graph-project-filter" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                        <!-- Opções populadas via JS -->
                    </select>
                </div>
                <button id="create-connection-btn" class="action-button text-sm">Create Connection</button>
                <button id="delete-connection-btn" class="action-button text-sm" disabled>Delete Connection</button>
            </div>
            <div class="flex-grow p-4 overflow-hidden relative">
                <svg id="dependency-graph-svg"></svg>
                <div id="graph-tooltip"></div>
            </div>
        </div>
    </div>

    <!-- Modal Gerenciador de Listas -->
    <div id="list-manager-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">List Manager</h2>
                <button id="close-list-manager-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="flex-grow grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 p-4 overflow-hidden w-full">
                <!-- Coluna XML Tags -->
                <div class="flex flex-col gap-3 p-3 rounded-md overflow-hidden" style="background-color: var(--panel-bg);">
                    <h3 class="font-semibold flex-shrink-0">XML Tags</h3>
                    <div class="flex gap-2 flex-shrink-0">
                        <input id="add-xml-tag-manager-input" type="text" placeholder="New XML tag..." class="form-control w-full rounded-md py-1 px-2 text-sm">
                        <button id="add-xml-tag-manager-btn" class="action-button primary px-3">+</button>
                    </div>
                    <div id="xml-tags-manager-container" class="flex-grow overflow-y-auto space-y-2 pr-2"></div>
                </div>
                <!-- Coluna Var Library -->
                <div class="flex flex-col gap-3 p-3 rounded-md overflow-hidden" style="background-color: var(--panel-bg);">
                    <h3 class="font-semibold flex-shrink-0">Variables (Var Library)</h3>
                    <div class="flex gap-2 flex-shrink-0">
                        <input id="add-var-library-manager-input" type="text" placeholder="New variable..." class="form-control w-full rounded-md py-1 px-2 text-sm">
                        <button id="add-var-library-manager-btn" class="action-button primary px-3">+</button>
                    </div>
                    <div id="var-library-manager-container" class="flex-grow overflow-y-auto space-y-2 pr-2"></div>
                </div>
                <!-- Coluna Tags Gerais -->
                <div class="flex flex-col gap-3 p-3 rounded-md overflow-hidden" style="background-color: var(--panel-bg);">
                    <h3 class="font-semibold flex-shrink-0">General Tags (#)</h3>
                    <p class="text-xs text-[--text-muted-dark] flex-shrink-0">Deleting a tag here will remove it from all prompts.</p>
                    <div class="flex gap-2 flex-shrink-0">
                        <input id="add-general-tag-manager-input" type="text" placeholder="New general tag..." class="form-control w-full rounded-md py-1 px-2 text-sm">
                        <button id="add-general-tag-manager-btn" class="action-button primary px-3">+</button>
                    </div>
                    <div id="general-tags-manager-container" class="flex-grow overflow-y-auto space-y-2 pr-2"></div>
                </div>
                <!-- Coluna Target LLM -->
                <div class="flex flex-col gap-3 p-3 rounded-md overflow-hidden" style="background-color: var(--panel-bg);">
                    <div class="flex-shrink-0">
                        <h3 class="font-semibold">Target LLM</h3>
                        <p class="text-xs text-[--text-muted-dark] mt-2">Models are loaded from the provider API. You can organize them by category. Manual model addition is disabled.</p>
                        <div class="flex gap-2 mt-3">
                            <input id="add-llm-category-manager-input" type="text" placeholder="New Category..." class="form-control w-full rounded-md py-1 px-2 text-sm">
                            <button id="add-llm-category-manager-btn" class="action-button primary px-3">+</button>
                        </div>
                    </div>
                    <div id="llm-manager-container" class="flex-grow overflow-y-auto space-y-2 pr-2 mt-2"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Input Gallery -->
    <div id="input-gallery-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center flex-shrink-0">
                <h2 class="text-xl font-bold">Input Gallery</h2>
                <div class="flex items-center gap-4">
                    <button id="save-input-gallery-btn" class="action-button primary">Save Input</button>
                    <button id="close-input-gallery-btn" class="p-2 rounded-full hover:bg-[#333]">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <div class="flex-grow flex overflow-hidden">
                <aside id="input-gallery-list-container" class="sidebar p-4 border-r border-[--border-dark] flex flex-col">
                    <div class="mb-3 flex-shrink-0">
                        <label for="input-gallery-project-filter" class="text-xs font-medium text-[--text-muted-dark]">Filter by Project:</label>
                        <select id="input-gallery-project-filter" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2"></select>
                    </div>
                    <button id="add-new-input-btn" class="action-button w-full mb-4">New Input</button>
                    <div id="input-gallery-list" class="flex-grow overflow-y-auto pr-2 space-y-2">
                        <!-- Lista de inputs será inserida aqui -->
                    </div>
                </aside>
                <main class="flex-grow p-4 flex flex-col">
                    <input type="hidden" id="input-gallery-id">
                    <div class="mb-3 flex-shrink-0">
                        <label for="input-gallery-project-assign" class="text-xs font-medium text-[--text-muted-dark]">Project:</label>
                        <select id="input-gallery-project-assign" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2"></select>
                    </div>
                    <input id="input-gallery-name" placeholder="Input name..." class="form-input font-sans w-full p-2 text-lg font-medium mb-4 rounded-md" style="background-color: var(--input-bg);">
                    <textarea id="input-gallery-editor" placeholder="Input content..." class="form-input font-mono w-full h-full p-4 text-base leading-relaxed resize-none rounded-md flex-grow" style="background-color: var(--input-bg);"></textarea>
                </main>
            </div>
        </div>
    </div>

    <!-- Modal Node Flow -->
    <div id="node-flow-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center flex-shrink-0">
                <div class="flex items-center gap-4">
                    <h2 class="text-xl font-bold">Node Flow</h2>
                    <select id="saved-flows-dropdown" class="form-control rounded-md py-1.5 px-3 text-sm focus:ring-2">
                         <option value="">Load a saved flow...</option>
                    </select>
                </div>
                <div class="flex items-center gap-4">
                    <button id="delete-flow-btn" class="action-button text-sm text-red-500 hover:bg-red-900/20 hover:border-red-800" disabled>Delete Flow</button>
                    <button id="save-flow-btn" class="action-button primary">Save Flow</button>
                    <button id="close-node-flow-btn" class="p-2 rounded-full hover:bg-[#333]">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <div class="flex-grow flex overflow-hidden">
                <aside id="node-flow-sidebar" class="sidebar p-4 border-r border-[--border-dark] flex flex-col">
                     <div class="mb-3 flex-shrink-0">
                        <label for="node-flow-project-filter" class="text-xs font-medium text-[--text-muted-dark]">Filter by Project:</label>
                        <select id="node-flow-project-filter" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                             <!-- Opções populadas via JS -->
                        </select>
                     </div>
                    <div id="node-flow-prompt-list" class="flex-grow overflow-y-auto pr-2 space-y-1">
                        <!-- Lista de prompts arrastáveis será inserida aqui -->
                    </div>
                </aside>
                <main id="node-flow-canvas" class="flex-grow relative">
                    <div id="node-flow-content">
                        <!-- Nós do fluxo serão inseridos aqui -->
                    </div>
                    <svg id="node-flow-connections" class="w-full h-full absolute top-0 left-0 pointer-events-none">
                        <g id="connections-group"></g>
                    </svg>
                </main>
            </div>
        </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Feature flags / runtime toggles
            const SHOW_AUTH_PANEL = false; // Disable minimal Auth overlay by default
            const hasChartJS = typeof Chart !== 'undefined';
            // --- Minimal Auth UI (Magic Link) ---
            (() => {
              try {
                // Do not render the small auth panel unless explicitly enabled
                if (!SHOW_AUTH_PANEL) return;
                // Avoid running before client exists
                if (typeof supabaseClient === 'undefined' || !supabaseClient || !window.document) return;

                // Create or reuse a small auth panel in the top-right corner
                let panel = document.getElementById('supabase-auth-panel');
                if (!panel) {
                  panel = document.createElement('div');
                  panel.id = 'supabase-auth-panel';
                  panel.style.position = 'fixed';
                  panel.style.top = '8px';
                  panel.style.right = '8px';
                  panel.style.zIndex = '9999';
                  panel.style.background = 'var(--panel-bg-dark, #0f1115)';
                  panel.style.border = '1px solid var(--border-dark, #2a2f3a)';
                  panel.style.padding = '8px';
                  panel.style.borderRadius = '6px';
                  panel.style.fontSize = '12px';
                  panel.style.color = 'var(--text-muted-dark, #c8d1e0)';
                  panel.style.display = 'flex';
                  panel.style.alignItems = 'center';
                  panel.style.gap = '6px';
                  panel.style.boxShadow = '0 2px 8px rgba(0,0,0,0.25)';

                  const email = document.createElement('input');
                  email.type = 'email';
                  email.placeholder = 'Seu e-mail';
                  email.id = 'auth-email-input';
                  email.style.padding = '4px 6px';
                  email.style.border = '1px solid var(--border-dark, #2a2f3a)';
                  email.style.background = 'transparent';
                  email.style.color = 'inherit';
                  email.style.borderRadius = '4px';
                  email.style.minWidth = '180px';

                  const sendBtn = document.createElement('button');
                  sendBtn.textContent = 'Enviar link';
                  sendBtn.id = 'auth-send-btn';
                  sendBtn.className = 'action-button text-xs';

                  const signOutBtn = document.createElement('button');
                  signOutBtn.textContent = 'Sair';
                  signOutBtn.id = 'auth-signout-btn';
                  signOutBtn.className = 'action-button text-xs';

                  const status = document.createElement('span');
                  status.id = 'auth-status-label';
                  status.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
                  status.style.fontSize = '11px';
                  status.style.opacity = '0.8';

                  panel.appendChild(email);
                  panel.appendChild(sendBtn);
                  panel.appendChild(signOutBtn);
                  panel.appendChild(status);
                  document.body.appendChild(panel);
                }

                const emailInput = panel.querySelector('#auth-email-input');
                const sendBtn = panel.querySelector('#auth-send-btn');
                const signOutBtn = panel.querySelector('#auth-signout-btn');
                const status = panel.querySelector('#auth-status-label');

                async function refreshAuthUI() {
                  try {
                    const { data } = await supabaseClient.auth.getUser();
                    const user = data?.user;
                    if (user) {
                      // Logged in: show status + Sign out; hide email + send
                      if (emailInput) emailInput.style.display = 'none';
                      if (sendBtn) sendBtn.style.display = 'none';
                      if (signOutBtn) signOutBtn.style.display = '';
                      if (status) status.textContent = user.email ? `Logado: ${user.email}` : 'Logado';
                    } else {
                      // Logged out: show email + send; hide Sign out
                      if (emailInput) emailInput.style.display = '';
                      if (sendBtn) sendBtn.style.display = '';
                      if (signOutBtn) signOutBtn.style.display = 'none';
                      if (status) status.textContent = '';
                    }
                  } catch (e) {
                    if (status) status.textContent = '';
                  }
                }

                if (sendBtn) {
                  sendBtn.addEventListener('click', async () => {
                    try {
                      const email = (emailInput?.value || '').trim();
                      if (!email) { if (status) status.textContent = 'Informe seu e-mail.'; return; }
                      const redirect = window.location.origin + window.location.pathname;
                      const { error } = await supabaseClient.auth.signInWithOtp({
                        email,
                        options: { emailRedirectTo: redirect }
                      });
                      if (error) { if (status) status.textContent = 'Erro ao enviar link.'; return; }
                      if (status) status.textContent = 'Link enviado. Verifique seu e-mail.';
                    } catch (e) {
                      if (status) status.textContent = 'Falha no envio.';
                    }
                  });
                }

                if (signOutBtn) {
                  signOutBtn.addEventListener('click', async () => {
                    try {
                      await supabaseClient.auth.signOut();
                      await refreshAuthUI();
                    } catch {}
                  });
                }

                try {
                  // Keep UI in sync with auth changes
                  supabaseClient.auth.onAuthStateChange(() => { refreshAuthUI(); });
                } catch {}

                refreshAuthUI();
              } catch {}
            })();
            // --- End Minimal Auth UI ---

                        // --- Inline Auth UI (header, beside theme toggle) ---
                        (() => {
                            try {
                                const SHOW_AUTH_INLINE = false; // prefer the Login Modal UX
                                const host = document.getElementById('auth-inline');
                                if (!SHOW_AUTH_INLINE || !host) return;

                                // If Supabase not configured, keep hidden
                                if (!supabaseClient) { host.classList.add('hidden'); return; }

                                // Build UI once
                                host.innerHTML = '';
                                host.classList.remove('hidden');
                                host.classList.add('flex');

                                const email = document.createElement('input');
                                email.type = 'email';
                                email.placeholder = 'email';
                                email.id = 'auth-email-inline';
                                email.className = 'form-control compact-field rounded-md text-xs w-44';

                                const sendBtn = document.createElement('button');
                                sendBtn.id = 'auth-send-inline';
                                sendBtn.textContent = 'Magic Link';
                                sendBtn.className = 'action-button text-xs';

                                const signOutBtn = document.createElement('button');
                                signOutBtn.id = 'auth-signout-inline';
                                signOutBtn.textContent = 'Sign out';
                                signOutBtn.className = 'action-button text-xs hidden';

                                const status = document.createElement('span');
                                status.id = 'auth-status-inline';
                                status.className = 'text-[10px] font-mono text-[--text-muted-dark]';

                                host.appendChild(email);
                                host.appendChild(sendBtn);
                                host.appendChild(signOutBtn);
                                host.appendChild(status);

                                async function refresh() {
                                    try {
                                        const { data } = await supabaseClient.auth.getUser();
                                        const user = data?.user;
                                        if (user) {
                                            email.classList.add('hidden');
                                            sendBtn.classList.add('hidden');
                                            signOutBtn.classList.remove('hidden');
                                            status.textContent = user.email || 'Logged in';
                                        } else {
                                            email.classList.remove('hidden');
                                            sendBtn.classList.remove('hidden');
                                            signOutBtn.classList.add('hidden');
                                            status.textContent = '';
                                        }
                                    } catch { status.textContent = ''; }
                                }

                                sendBtn.addEventListener('click', async () => {
                                    try {
                                        const value = (email.value || '').trim();
                                        if (!value) { status.textContent = 'Informe o e-mail'; return; }
                                        const redirect = window.location.origin + window.location.pathname;
                                        const { error } = await supabaseClient.auth.signInWithOtp({ email: value, options: { emailRedirectTo: redirect } });
                                        if (error) { status.textContent = 'Erro ao enviar link'; return; }
                                        status.textContent = 'Link enviado';
                                    } catch { status.textContent = 'Falha no envio'; }
                                });

                                signOutBtn.addEventListener('click', async () => {
                                    try { await supabaseClient.auth.signOut(); await refresh(); } catch {}
                                });

                                try { supabaseClient.auth.onAuthStateChange(() => { refresh(); }); } catch {}
                                refresh();
                            } catch {}
                        })();
                        // --- End Inline Auth UI ---
            // Helper: UUID that works offline/older browsers
            const getUUID = () => (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function')
                ? crypto.randomUUID()
                : `id-${Math.random().toString(36).slice(2)}${Date.now().toString(36)}`;

            // --- CONFIG DOCK LOGIC ---
            const dock = document.getElementById('config-dock');
            const drawer = document.getElementById('config-drawer');
            const drawerTitle = document.getElementById('config-drawer-title');
            const drawerClose = document.getElementById('config-drawer-close');
            let currentDrawerKey = null; // track open panel for toggle behavior
            const panels = {
                project: document.getElementById('panel-project'),
                github: document.getElementById('panel-github'),
                llm: document.getElementById('panel-llm'),
                tags: document.getElementById('panel-tags'),
                xml: document.getElementById('panel-xml'),
                var: document.getElementById('panel-var'),
                input: document.getElementById('panel-input'),
                settings: document.getElementById('panel-settings'),
            };
            const openDrawer = (which, title) => {
                if (!drawer) return;
                // Hide all panels
                Object.values(panels).forEach(p => p && p.classList.add('hidden'));
                // Show selected
                const panel = panels[which];
                if (panel) panel.classList.remove('hidden');
                if (drawerTitle) drawerTitle.textContent = title || 'Settings';
                currentDrawerKey = which;
                // Toggle header add buttons per panel
                try {
                    const headerAddXml = document.getElementById('add-xml-tag-btn');
                // Ensure Target LLM reflects only current connections
                syncLlmListWithConnections();
                    const headerAddVar = document.getElementById('add-var-library-btn');
                    if (headerAddXml) headerAddXml.classList.toggle('hidden', which !== 'xml');
                    if (headerAddVar) headerAddVar.classList.toggle('hidden', which !== 'var');
                } catch {}
                // Render the corresponding list
                try {
                    if (which === 'project') renderProjectListDrawer();
                    if (which === 'github') {
                        renderGithubListDrawer();
                        // Auto-open and load provider repos section in Dock > GitHub
                        const box = document.getElementById('dock-github-available-repos');
                        const caret = document.getElementById('dock-github-repos-caret');
                        if (box) box.classList.remove('hidden');
                        if (caret) caret.textContent = '▼';
                        try { loadAccessibleRepos(document.getElementById('dock-github-available-repos')); } catch {}
                    }
                    if (which === 'llm') renderLlmListDrawer();
                    if (which === 'tags') renderTagsListDrawer();
                    if (which === 'xml') renderXmlTagsListDrawer();
                    if (which === 'var') renderVarLibraryListDrawer();
                    if (which === 'input') renderAddInputListDrawer();
                } catch {}
                drawer.classList.remove('pointer-events-none');
                drawer.style.opacity = '1';
                drawer.style.transform = 'translateX(0)';
                // No focus needed; lists are visible
            };
            const closeDrawer = () => {
                if (!drawer) return;
                drawer.style.opacity = '0';
                drawer.style.transform = 'translateX(8px)';
                // Delay pointer-events to allow transition
                setTimeout(() => drawer.classList.add('pointer-events-none'), 180);
                currentDrawerKey = null;
            };
            if (drawerClose) drawerClose.addEventListener('click', closeDrawer);
            const bind = (btnId, key, title) => {
                const btn = document.getElementById(btnId);
                if (!btn) return;
                btn.addEventListener('click', () => {
                    const isOpen = !drawer.classList.contains('pointer-events-none') && currentDrawerKey === key;
                    if (isOpen) {
                        closeDrawer();
                    } else {
                        openDrawer(key, title);
                    }
                });
            };
            bind('dock-project-btn', 'project', 'Project');
            bind('dock-github-btn', 'github', 'GitHub Repo');
            bind('dock-llm-btn', 'llm', 'Target LLM');
            bind('dock-tags-btn', 'tags', 'Tags');
            bind('dock-xml-btn', 'xml', 'XML Tags');
            bind('dock-var-btn', 'var', 'Var Library');
            bind('dock-input-btn', 'input', 'Add Input');
            bind('dock-settings-btn', 'settings', 'Settings');

            // Initialize closed state
            if (drawer) {
                drawer.style.opacity = '0';
                drawer.style.transform = 'translateX(8px)';
                drawer.classList.add('pointer-events-none');
            }

            // Header add buttons will be bound after elements are declared below

            // Close drawer on outside click
            document.addEventListener('click', (e) => {
                if (!drawer) return;
                const withinDock = dock && dock.contains(e.target);
                const withinDrawer = drawer.contains(e.target);
                if (!withinDock && !withinDrawer) closeDrawer();
            });

            // --- CONFIGURAÇÃO DO SUPABASE ---
        // Projeto ativo (Studio > Project Settings > API)
        const SUPABASE_URL = 'https://bwhalclycvkiifgyvuup.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJ3aGFsY2x5Y3ZraWlmZ3l2dXVwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU5MTEzODMsImV4cCI6MjA3MTQ4NzM4M30.OP2YnoR-5zCRJxAQBuk9h5gbGewsWaWICpISLbE5gpQ';

        // Valores finais (não editar via UI)
        const FINAL_SUPABASE_URL = SUPABASE_URL;
        const FINAL_SUPABASE_KEY = SUPABASE_ANON_KEY;

                        let supabaseClient = null;
            let dbOnline = false;
            try {
                if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) {
                    console.warn('Supabase não configurado: defina SUPABASE_URL e SUPABASE_ANON_KEY no código antes de usar recursos protegidos.');
                } else if (window.supabase && typeof window.supabase.createClient === 'function') {
                    const { createClient } = window.supabase;
                    supabaseClient = createClient(FINAL_SUPABASE_URL, FINAL_SUPABASE_KEY);
                    dbOnline = true;
                } else {
                    console.warn('Supabase SDK not available. Running in offline mode.');
                }
            } catch (e) {
                console.warn('Supabase init failed, switching to offline mode:', e);
                supabaseClient = null;
                dbOnline = false;
            }

                        // Handle password recovery tokens from URL fragment
                        (function() {
                            try {
                                if (!supabaseClient) return;
                                const hash = window.location.hash || '';
                                if (!hash || hash.indexOf('access_token=') === -1) return;
                                const params = new URLSearchParams(hash.replace(/^#/, ''));
                                const access_token = params.get('access_token');
                                const refresh_token = params.get('refresh_token');
                                const type = params.get('type');
                                if (access_token && refresh_token) {
                                    supabaseClient.auth.setSession({ access_token, refresh_token }).then(() => {
                                        try { history.replaceState(null, '', window.location.pathname + window.location.search); } catch {}
                                        if (type === 'recovery' && typeof window.openLoginModal === 'function') {
                                            window.openLoginModal();
                                            try { window.setMode && window.setMode('newpass'); } catch {}
                                        }
                                    }).catch(() => {});
                                }
                            } catch {}
                        })();

                                    // --- Login Modal Wiring (Email + Password) ---
                        (function() {
                            try {
                                const modal = document.getElementById('login-modal');
                                const emailInput = document.getElementById('login-email-input');
                                            const pwdInput = document.getElementById('login-password-input');
                                            const pwdConfirm = document.getElementById('login-password-confirm');
                                            const submitBtn = document.getElementById('login-submit-btn');
                                const statusEl = document.getElementById('login-status');
                                const closeBtn = document.getElementById('login-modal-close');
                                            const toggleModeBtn = document.getElementById('login-toggle-mode');
                                            const forgotBtn = document.getElementById('login-forgot');
                                            const titleEl = document.getElementById('login-modal-title');
                                            const descEl = document.getElementById('login-modal-desc');

                                                            // mode: 'signin' | 'signup' | 'reset' | 'newpass'
                                                            let loginMode = 'signin';
                                            function setMode(mode) {
                                                loginMode = mode;
                                                if (mode === 'signin') {
                                                    titleEl.textContent = 'Sign in';
                                                    descEl.textContent = 'Enter your email and password to sign in.';
                                                    submitBtn.textContent = 'Sign in';
                                                pwdInput.classList.remove('hidden');
                                                    pwdConfirm.classList.add('hidden');
                                                    toggleModeBtn.textContent = 'Create account';
                                                } else if (mode === 'signup') {
                                                    titleEl.textContent = 'Create account';
                                                    descEl.textContent = 'Enter your email and a new password to create an account.';
                                                    submitBtn.textContent = 'Create account';
                                                pwdInput.classList.remove('hidden');
                                                    pwdConfirm.classList.remove('hidden');
                                                    toggleModeBtn.textContent = 'Have an account? Sign in';
                                                                } else if (mode === 'reset') {
                                                    titleEl.textContent = 'Reset password';
                                                    descEl.textContent = 'Enter your email to receive a reset link.';
                                                    submitBtn.textContent = 'Send reset link';
                                                pwdInput.classList.add('hidden');
                                                    pwdConfirm.classList.add('hidden');
                                                                } else if (mode === 'newpass') {
                                                                    titleEl.textContent = 'Set new password';
                                                                    descEl.textContent = 'Enter and confirm your new password.';
                                                                    submitBtn.textContent = 'Update password';
                                                pwdInput.classList.remove('hidden');
                                                                    pwdConfirm.classList.remove('hidden');
                                                }
                                                statusEl.textContent = '';
                                            }

                                function openLoginModal() {
                                    if (!modal) return;
                                    modal.classList.remove('hidden');
                                    // focus input shortly after open
                                                setTimeout(() => { try { emailInput && emailInput.focus(); } catch {} }, 50);
                                }
                                function closeLoginModal() {
                                    if (!modal) return;
                                    modal.classList.add('hidden');
                                    if (statusEl) statusEl.textContent = '';
                                }
                                // expose globally for other handlers
                                window.openLoginModal = openLoginModal;
                                window.closeLoginModal = closeLoginModal;

                                // Close interactions
                                if (closeBtn) closeBtn.addEventListener('click', closeLoginModal);
                                if (modal) {
                                    modal.addEventListener('click', (e) => {
                                        if (e.target === modal) closeLoginModal();
                                    });
                                }
                                document.addEventListener('keydown', (e) => {
                                    if (e.key === 'Escape' && modal && !modal.classList.contains('hidden')) closeLoginModal();
                                });

                                                // Toggle modes
                                                if (toggleModeBtn) {
                                                    toggleModeBtn.addEventListener('click', () => {
                                                        if (loginMode === 'signin') setMode('signup');
                                                        else setMode('signin');
                                                    });
                                                }
                                                if (forgotBtn) {
                                                    forgotBtn.addEventListener('click', () => setMode('reset'));
                                                }

                                                // Submit
                                                if (submitBtn) {
                                                    submitBtn.addEventListener('click', async () => {
                                                        try {
                                                            if (!supabaseClient) { statusEl.textContent = 'Supabase indisponível'; return; }
                                                            const email = (emailInput?.value || '').trim();
                                                            if (!email) { statusEl.textContent = 'Informe seu e-mail'; return; }
                                                            submitBtn.disabled = true;

                                                            if (loginMode === 'signin') {
                                                                const password = (pwdInput?.value || '').trim();
                                                                if (!password) { statusEl.textContent = 'Informe sua senha'; submitBtn.disabled = false; return; }
                                                                const { error } = await supabaseClient.auth.signInWithPassword({ email, password });
                                                                if (error) { statusEl.textContent = 'Login inválido'; submitBtn.disabled = false; return; }
                                                                statusEl.textContent = 'Signed in';
                                                            } else if (loginMode === 'signup') {
                                                                const password = (pwdInput?.value || '').trim();
                                                                const confirm = (pwdConfirm?.value || '').trim();
                                                                if (!password || password.length < 6) { statusEl.textContent = 'Senha deve ter 6+ caracteres'; submitBtn.disabled = false; return; }
                                                                if (password !== confirm) { statusEl.textContent = 'Senhas não coincidem'; submitBtn.disabled = false; return; }
                                                                const { error } = await supabaseClient.auth.signUp({ email, password });
                                                                if (error) { statusEl.textContent = 'Falha ao criar conta'; submitBtn.disabled = false; return; }
                                                                statusEl.textContent = 'Conta criada. Verifique seu e-mail para confirmar.';
                                                                // switch back to sign-in
                                                                setMode('signin');
                                                                                    } else if (loginMode === 'reset') {
                                                                const redirect = window.location.origin + window.location.pathname;
                                                                const { error } = await supabaseClient.auth.resetPasswordForEmail(email, { redirectTo: redirect });
                                                                if (error) { statusEl.textContent = 'Falha ao enviar reset'; submitBtn.disabled = false; return; }
                                                                statusEl.textContent = 'Link de reset enviado.';
                                                                setMode('signin');
                                                                                    } else if (loginMode === 'newpass') {
                                                                                        const password = (pwdInput?.value || '').trim();
                                                                                        const confirm = (pwdConfirm?.value || '').trim();
                                                                                        if (!password || password.length < 6) { statusEl.textContent = 'Senha deve ter 6+ caracteres'; submitBtn.disabled = false; return; }
                                                                                        if (password !== confirm) { statusEl.textContent = 'Senhas não coincidem'; submitBtn.disabled = false; return; }
                                                                                        const { data, error } = await supabaseClient.auth.updateUser({ password });
                                                                                        if (error) { statusEl.textContent = 'Falha ao atualizar senha'; submitBtn.disabled = false; return; }
                                                                                        statusEl.textContent = 'Senha atualizada. Entre novamente.';
                                                                                        setMode('signin');
                                                            }
                                                        } catch {
                                                            statusEl.textContent = 'Erro inesperado';
                                                        } finally {
                                                            setTimeout(() => { try { submitBtn.disabled = false; } catch {} }, 1200);
                                                        }
                                                    });
                                                }

                                // If already logged in, ensure modal stays closed
                                if (supabaseClient) {
                                    try {
                                                                                supabaseClient.auth.onAuthStateChange((evt) => {
                                                                                    if (evt === 'PASSWORD_RECOVERY') {
                                                                                        openLoginModal();
                                                                                        setMode('newpass');
                                                                                        try { pwdInput?.focus(); } catch {}
                                                                                    } else if (evt === 'SIGNED_IN') {
                                                try { window.clearAppLocalData && window.clearAppLocalData(); } catch {}
                                                closeLoginModal();
                                                // Reload to re-init app state with session
                                                window.location.reload();
                                                                }
                                        });
                                        // Also close if a session already exists on load
                                        supabaseClient.auth.getSession().then(({ data }) => {
                                            if (data?.session) closeLoginModal();
                                        }).catch(() => {});
                                    } catch {}
                                }
                                                    // expose mode setter globally for URL-based handlers
                                                    window.setMode = setMode;
                                                    // default mode
                                                    setMode('signin');
                            } catch {}
                        })();
                                            // --- End Login Modal Wiring ---

                                    // --- Compact header Sign in/Sign out toggle ---
                                    (function() {
                                        try {
                                            const host = document.getElementById('auth-inline');
                                            if (!host) return;
                                            host.classList.remove('hidden');
                                            host.classList.add('flex');
                                            host.innerHTML = '';

                                            const signInBtn = document.createElement('button');
                                            signInBtn.id = 'btn-open-login';
                                            signInBtn.textContent = 'Sign in';
                                            signInBtn.className = 'action-button text-xs';

                                            const signOutBtn = document.createElement('button');
                                            signOutBtn.id = 'btn-sign-out';
                                            signOutBtn.textContent = 'Sign out';
                                            signOutBtn.className = 'action-button text-xs hidden';

                                            host.appendChild(signInBtn);
                                            host.appendChild(signOutBtn);

                                            signInBtn.addEventListener('click', () => {
                                                try { window.openLoginModal && window.openLoginModal(); } catch {}
                                            });
                                            signOutBtn.addEventListener('click', async () => {
                                                try { await supabaseClient?.auth?.signOut(); } catch {}
                                            });

                                            async function refresh() {
                                                try {
                                                    const { data } = await supabaseClient.auth.getUser();
                                                    const logged = !!data?.user;
                                                    signInBtn.classList.toggle('hidden', logged);
                                                    signOutBtn.classList.toggle('hidden', !logged);
                                                } catch {}
                                            }
                                            if (supabaseClient) {
                                                try { supabaseClient.auth.onAuthStateChange(() => { refresh(); }); } catch {}
                                                refresh();
                                            }
                                        } catch {}
                                    })();
                                    // --- End compact header toggle ---

                                                // --- Profiles inline UI (email + editable full_name) ---
                                                (function() {
                                                    try {
                                                        const host = document.getElementById('profile-inline');
                                                        const emailEl = document.getElementById('profile-email');
                                                        const fullnameInput = document.getElementById('profile-fullname');
                                                        const editBtn = document.getElementById('profile-edit-btn');
                                                        const saveBtn = document.getElementById('profile-save-btn');

                                                        async function refresh() {
                                                            if (!supabaseClient) { host.classList.add('hidden'); return; }
                                                            const { data } = await supabaseClient.auth.getUser();
                                                            const user = data?.user;
                                                            if (!user) { host.classList.add('hidden'); return; }
                                                            host.classList.remove('hidden');
                                                            emailEl.textContent = user.email || '';
                                                            // Load profile.full_name
                                                            try {
                                                                const { data: prof } = await supabaseClient.from('profiles').select('full_name').single();
                                                                const fullname = prof?.full_name || '';
                                                                fullnameInput.value = fullname;
                                                                editBtn.classList.remove('hidden');
                                                                fullnameInput.classList.add('hidden');
                                                                saveBtn.classList.add('hidden');
                                                            } catch {
                                                                // If RLS blocks or row missing, attempt create on save
                                                                editBtn.classList.remove('hidden');
                                                            }
                                                        }

                                                        if (editBtn) editBtn.addEventListener('click', () => {
                                                            fullnameInput.classList.remove('hidden');
                                                            saveBtn.classList.remove('hidden');
                                                            editBtn.classList.add('hidden');
                                                            try { fullnameInput.focus(); } catch {}
                                                        });

                                                        if (saveBtn) saveBtn.addEventListener('click', async () => {
                                                            try {
                                                                const name = (fullnameInput.value || '').trim();
                                                                const { data: userData } = await supabaseClient.auth.getUser();
                                                                const id = userData?.user?.id;
                                                                if (!id) return;
                                                                const { error } = await supabaseClient.from('profiles').upsert({ id, full_name: name }).select().single();
                                                                if (!error) {
                                                                    fullnameInput.classList.add('hidden');
                                                                    saveBtn.classList.add('hidden');
                                                                    editBtn.classList.remove('hidden');
                                                                }
                                                            } catch {}
                                                        });

                                                        if (supabaseClient) {
                                                            try { supabaseClient.auth.onAuthStateChange(() => { refresh(); }); } catch {}
                                                            refresh();
                                                        }
                                                    } catch {}
                                                })();
                                                // --- End profiles inline UI ---

            const PROMPTS_STORAGE_KEY = 'promptManagerApp_prompts';
            const XML_TAGS_STORAGE_KEY = 'promptManagerApp_xmlTags';
            const TEMPLATES_STORAGE_KEY = 'promptManagerApp_templates';
            const VAR_LIBRARY_STORAGE_KEY = 'promptManagerApp_varLibrary';
            const LLM_LIST_STORAGE_KEY = 'promptManagerApp_llmList';
            const PROJECT_REPO_MAP_STORAGE_KEY = 'promptManagerApp_projectRepoMap';
            const INPUT_GALLERY_STORAGE_KEY = 'promptManagerApp_inputGallery';
            const NODE_FLOWS_STORAGE_KEY = 'promptManagerApp_nodeFlows';
            const PROJECTS_STORAGE_KEY = 'promptManagerApp_projects';
            // Provider/docs helpers
            const DOC_LINKS = {
                openai: 'https://platform.openai.com/docs/api-reference/introduction',
                xai: 'https://docs.x.ai/docs/overview/',
                
            };
            
            
            // --- ESTADO DA APLICAÇÃO ---
            let prompts = [];
            let xmlTags = [];
            let templates = [];
            let varLibrary = [];
            let llmList = {};
            let inputGallery = [];
            let savedFlows = [];
            let projectNames = [];
            let projectRepoMap = {};
            let selectedVersionId = null;
            let selectedInputId = null; // Para o modal Input Gallery
            let expandedPromptGroups = new Set();
            let itemToDelete = { type: null, id: null };
            let activeStatusFilter = 'all';
            const effortLevels = ['Low', 'Medium', 'High'];
            let versionsToCompare = new Set();
            let activeComparisonPromptId = null;
            let findState = {
                matches: [],
                currentIndex: -1,
                query: ''
            };
            let snippets = []; // Para a função de copiar snippet
            // Prompt-level GitHub repo selection for current editor
            let currentGithubRepo = null; // { id, full }
            // Estado do Gráfico
            let isCreatingConnection = false;
            let firstNodeForConnection = null;
            let selectedLinkForDeletion = null;
            // Estado do Node Flow
            let flowNodes = [];
            let flowConnections = [];
            let isDraggingNode = false;
            let isDrawingConnection = false;
            let connectionStartNodeId = null;
            let tempLine = null;
            const hasD3 = typeof window.d3 !== 'undefined';
            const hasDiff = typeof window.diff_match_patch === 'function';
            let currentTransform = hasD3 ? d3.zoomIdentity : { x: 0, y: 0, k: 1, apply: ([x, y]) => [x, y] };

            // --- THEME SETUP ---
            const rootEl = document.documentElement;
            const themeToggleBtn = document.getElementById('theme-toggle');
            const iconSun = document.getElementById('icon-sun');
            const iconMoon = document.getElementById('icon-moon');
            const savedTheme = localStorage.getItem('pm_theme') || 'dark';
            const applyTheme = (theme) => {
                if (theme === 'light') {
                    rootEl.setAttribute('data-theme', 'light');
                    // Show sun icon for light, hide moon
                    if (iconSun) iconSun.classList.remove('hidden');
                    if (iconMoon) iconMoon.classList.add('hidden');
                    themeToggleBtn.setAttribute('aria-label', 'Switch to dark mode');
                } else {
                    rootEl.removeAttribute('data-theme');
                    // Show moon icon for dark, hide sun
                    if (iconSun) iconSun.classList.add('hidden');
                    if (iconMoon) iconMoon.classList.remove('hidden');
                    themeToggleBtn.setAttribute('aria-label', 'Switch to light mode');
                }
                // Update DB status pill colors on theme change
                const dbStatus = document.getElementById('db-status-pill');
                if (dbStatus) {
                    dbStatus.classList.remove('online', 'offline');
                    dbStatus.classList.add(dbOnline ? 'online' : 'offline');
                }
                // Re-render dashboard charts with theme-aware colors if modal is open
                setTimeout(() => {
                    const dashboardModalEl = document.getElementById('dashboard-modal');
                    if (dashboardModalEl && !dashboardModalEl.classList.contains('hidden') && typeof Chart !== 'undefined') {
                        const sel = document.getElementById('dashboard-period-select');
                        const period = sel ? sel.value : 'month';
                        if (typeof renderDashboardCharts === 'function') {
                            renderDashboardCharts(period);
                        }
                    }
                }, 0);
            };
            applyTheme(savedTheme);
            themeToggleBtn.addEventListener('click', () => {
                const next = rootEl.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
                localStorage.setItem('pm_theme', next);
                applyTheme(next);
            });


            // --- ELEMENTOS DO DOM ---
            const mainHeader = document.getElementById('main-header');
            const mainContent = document.getElementById('main-content');
            const mainEditor = document.getElementById('main-editor');
            const snippetButtonsOverlay = document.getElementById('snippet-buttons-overlay');
            const titleInput = document.getElementById('prompt-title-input');
            const projectInput = document.getElementById('project-name-input-aside');
            const versionsHistoryList = document.getElementById('versions-history-list');
            const statusContainer = document.getElementById('status-selector-container');
            const searchInput = document.getElementById('search-versions-input');
            const editorStats = document.getElementById('editor-stats');
            const copyPromptBtn = document.getElementById('copy-prompt-btn');
            const llmSelect = document.getElementById('llm-select');
            const statusFilterContainer = document.getElementById('status-filter-container');
            const variablesSection = document.getElementById('variables-section');
            const variablesContainer = document.getElementById('variables-container');
            // Dependencies UI (moved to bottom bar)
            const editDependenciesBtn = document.getElementById('edit-dependencies-btn');
            const dependenciesDropdown = document.getElementById('dependencies-dropdown');
            const dependenciesSearch = document.getElementById('dependencies-search');
            const dependenciesList = document.getElementById('dependencies-list');
            const depsCancelBtn = document.getElementById('deps-cancel-btn');
            const depsApplyBtn = document.getElementById('deps-apply-btn');
            // Drawer lists (new)
            const projectListDrawer = document.getElementById('project-list-drawer');
            const llmListDrawer = document.getElementById('llm-list-drawer');
            const tagsListDrawer = document.getElementById('tags-list-drawer');
            const xmlTagsListDrawer = document.getElementById('xml-tags-list-drawer');
            const varLibraryListDrawer = document.getElementById('var-library-list-drawer');
            const addInputListDrawer = document.getElementById('add-input-list-drawer');

            // Legacy hidden inputs kept for compatibility
            const xmlTagInput = document.getElementById('xml-tag-input');
            const addXmlTagBtn = document.getElementById('add-xml-tag-btn');
            const xmlTagDropdown = document.getElementById('xml-tag-dropdown');
            const dependencyBar = document.getElementById('dependency-bar');
            const dependencyTagContainer = document.getElementById('dependency-tag-container');
            const compareVersionsBtn = document.getElementById('compare-versions-btn');
            const toggleCommentsBtn = document.getElementById('toggle-comments-btn');
            const commentsSection = document.getElementById('comments-section');
            const commentsTextarea = document.getElementById('comments-textarea');
            const navigationMap = document.getElementById('navigation-map');
            
            const addPromptBtn = document.getElementById('add-prompt-btn');
            const addMajorVersionBtn = document.getElementById('add-major-version-btn');
            const addMinorVersionBtn = document.getElementById('add-minor-version-btn');
            const saveAsTemplateBtn = document.getElementById('save-as-template-btn');
            const forkVersionBtn = document.getElementById('fork-version-btn');
            const deleteVersionBtn = document.getElementById('delete-version-btn');
            const downloadJsonBtn = document.getElementById('download-json-btn');
            const downloadMdBtn = document.getElementById('download-md-btn');
            const downloadTxtBtn = document.getElementById('download-txt-btn');

            // Run Prompt UI
            const runPromptBtn = document.getElementById('run-prompt-btn');
            const runModal = document.getElementById('run-modal');
            const closeRunModalBtn = document.getElementById('close-run-modal');
            const runCancelBtn = document.getElementById('run-cancel-btn');
            const runExecuteBtn = document.getElementById('run-execute-btn');
            const runRequestView = document.getElementById('run-request-view');
            const runResponseView = document.getElementById('run-response-view');
            const runLoading = document.getElementById('run-loading');
            const runError = document.getElementById('run-error');
            const runActiveLlm = document.getElementById('run-active-llm');
            const copyRunReqBtn = document.getElementById('copy-run-request-btn');
            const copyRunResBtn = document.getElementById('copy-run-response-btn');

            // Modais
            const confirmModal = document.getElementById('confirm-modal');
            const confirmModalTitle = document.getElementById('confirm-modal-title');
            const confirmModalText = document.getElementById('confirm-modal-text');
            const confirmModalInputContainer = document.getElementById('confirm-modal-input-container');
            const confirmModalInput = document.getElementById('confirm-modal-input');
            const confirmModalButtons = document.getElementById('confirm-modal-buttons');
            
            const galleryModal = document.getElementById('gallery-modal');
            const galleryBtn = document.getElementById('gallery-btn');
            const closeGalleryBtn = document.getElementById('close-gallery-btn');
            const galleryGrid = document.getElementById('gallery-grid');
            
            const projectsModal = document.getElementById('projects-modal');
            const projectsBtn = document.getElementById('projects-btn');
            const closeProjectsBtn = document.getElementById('close-projects-btn');
            const addProjectBtn = document.getElementById('add-project-btn');
            addProjectBtn.addEventListener('click', () => {
                const addProjectPopup = document.getElementById('add-project-popup');
                const newProjectNameInput = document.getElementById('new-project-name-input');
                const cancelAddProjectBtn = document.getElementById('cancel-add-project-btn');
                const confirmAddProjectBtn = document.getElementById('confirm-add-project-btn');

                // Exibir o popup
                addProjectPopup.classList.remove('hidden');
                newProjectNameInput.value = '';
                newProjectNameInput.focus();

                // Cancelar adição
                cancelAddProjectBtn.addEventListener('click', () => {
                    addProjectPopup.classList.add('hidden');
                });

                // Confirmar adição
                confirmAddProjectBtn.addEventListener('click', async() => {
                    const newProjectName = newProjectNameInput.value.trim();
                    if (newProjectName) {
                        const datalist = document.getElementById('project-list-aside');
                        const exists = [...datalist.options].some(option => option.value === newProjectName);
                        if (!exists) {
                            const option = document.createElement('option');
                            option.value = newProjectName;
                            datalist.appendChild(option);

                            // Track in persistent project list
                            if (!projectNames.includes(newProjectName)) {
                                projectNames.push(newProjectName);
                                saveProjectNamesToStorage();
                                // Persist to Supabase global_lists
                                updateGlobalList('projects', projectNames);
                            }

                            // Update modal list immediately
                            renderProjectsView();

                            // Exibir modal estilizado
                            showModal(
                                'Success',
                                `Project "${newProjectName}" added successfully.`,
                                [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]
                            );
                        } else {
                            showModal(
                                'Error',
                                'This project already exists.',
                                [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]
                            );
                        }
                    }
                    addProjectPopup.classList.add('hidden');
                });
            });
            // ===== Run Prompt feature =====
            function resolveConnForModel(modelId) {
                try {
                    if (!modelId || modelId === 'generic') return null;
                    const groupName = Object.keys(llmList || {}).find(g => (llmList[g] || []).includes(modelId));
                    if (!groupName) return null;
                    const conns = (typeof getLlmConnections === 'function') ? getLlmConnections() : [];
                    // 1) Exact match via computeConnGroup
                    const exact = conns.find(c => { try { return (typeof computeConnGroup === 'function') && computeConnGroup(c) === groupName; } catch { return false; } });
                    if (exact) return exact;
                    // 2) Fallback: parse provider and label from group and match by label and provider
                    let parsedProv = null, parsedLabel = null;
                    try { const parts = groupName.split(' — '); parsedProv = (parts[0] || '').trim(); parsedLabel = (parts[1] || '').trim(); } catch {}
                    if (parsedLabel) {
                        const byLabel = conns.filter(c => {
                            try { return (c.label || (c.base ? new URL(c.base).hostname : '')) === parsedLabel; } catch { return false; }
                        });
                        if (byLabel.length === 1) return byLabel[0];
                        if (byLabel.length > 1 && parsedProv) {
                            const byLabelProv = byLabel.find(c => { try { return (typeof detectProvider === 'function') && detectProvider(c.base || '') === (parsedProv === 'openai' ? 'openai' : parsedProv); } catch { return false; } });
                            if (byLabelProv) return byLabelProv;
                        }
                    }
                    // 3) Last resort: match any connection by provider from group
                    if (parsedProv) {
                        const anyProv = conns.find(c => { try { return (typeof detectProvider === 'function') && detectProvider(c.base || '') === (parsedProv === 'openai' ? 'openai' : parsedProv); } catch { return false; } });
                        if (anyProv) return anyProv;
                    }
                    return null;
                } catch { return null; }
            }

            async function storeLocalConnOnServer(conn) {
                try {
                    if (!conn || conn.server) return conn;
                    if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return conn;
                    const provider = (typeof detectProvider === 'function') ? detectProvider(conn.base || '') : 'openai';
                    const label = (() => { try { return conn.label || new URL(conn.base).hostname; } catch { return conn.label || 'LLM'; } })();
                    await detectFnVariants();
                    const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                    const headers = await buildFnHeaders();
                    let res;
                    if (FN_VARIANTS.saveConfig === 'new') {
                        res = await fetch(baseFn + '/save-ai-api-config', { method: 'POST', headers, body: JSON.stringify({ name: label, provider, base_url: conn.base, api_key: conn.key }) });
                    } else {
                        res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers, body: JSON.stringify({ type: 'llm', label, base_url: conn.base, api_key: conn.key, provider }) });
                    }
                    if (!res.ok) return conn;
                    const { id: newId } = await res.json();
                    const list = JSON.parse(localStorage.getItem(API_KEYS.llm_multi) || '[]');
                    // Migrate models cache
                    const cached = getModelsCache(conn.id);
                    if (cached && cached.length) {
                        try { localStorage.setItem(modelsCacheKey(newId), JSON.stringify(cached)); } catch {}
                        try { localStorage.removeItem(modelsCacheKey(conn.id)); } catch {}
                    }
                    // Replace the local entry with server entry
                    const idx = list.findIndex(i => i.id === conn.id);
                    const serverEntry = { id: newId, base: conn.base, label, server: true };
                    if (idx >= 0) { list.splice(idx, 1, serverEntry); } else { list.push(serverEntry); }
                    localStorage.setItem(API_KEYS.llm_multi, JSON.stringify(list));
                    localStorage.setItem(API_KEYS.llm_active, newId);
                    // Persist caches and rebuild Target LLM from connections
                    try { await persistAllModelCachesToServer(); } catch {}
                    try { if (typeof rebuildLlmListFromConnections === 'function') rebuildLlmListFromConnections(); } catch {}
                    return serverEntry;
                } catch { return conn; }
            }
            function buildRunPayload() {
                const llmId = llmSelect?.value || 'generic';
                const dyn = collectDynamicSettings();
                const content = (mainEditor?.value || '').trim();
                // Detect provider from the connection that owns the selected model (fallback to active/base)
                let provider = 'openai';
                try {
                    const conn = (typeof resolveConnForModel === 'function') ? resolveConnForModel(llmId) : null;
                    const base = conn?.base || (typeof getActiveLlmConn === 'function' ? (getActiveLlmConn()?.base || '') : '') || (localStorage.getItem(API_KEYS.llm_base) || '');
                    if (typeof detectProvider === 'function') provider = detectProvider(base);
                } catch {}

                let messages = Array.isArray(dyn.messages) && dyn.messages.length
                    ? dyn.messages.filter(m => (m.content||'').trim().length)
                    : [];
                if (!messages.length && content) messages = [{ role: 'user', content }];

                // System messages remain inline; no provider-specific lifting

                const body = { model: llmId === 'generic' ? undefined : llmId, messages };
                // Common knobs
                if (dyn.maxTokens !== '' && typeof dyn.maxTokens !== 'undefined') body.max_tokens = Number(dyn.maxTokens);
                if (dyn.dimensions !== '' && typeof dyn.dimensions !== 'undefined') body.dimensions = Number(dyn.dimensions);
                if (typeof dyn.temperature === 'number') body.temperature = dyn.temperature;
                if (typeof dyn.topP === 'number') body.top_p = dyn.topP;
                if (dyn.stopSequences && String(dyn.stopSequences).trim()) {
                    body.stop = String(dyn.stopSequences).split(/\r?\n/).map(s => s.trim()).filter(Boolean);
                }
                // OpenAI-compatible knobs only
                if (typeof dyn.presencePenalty === 'number') body.presence_penalty = dyn.presencePenalty;
                if (typeof dyn.frequencyPenalty === 'number') body.frequency_penalty = dyn.frequencyPenalty;
                if (dyn.seed !== '' && typeof dyn.seed !== 'undefined') body.seed = Number(dyn.seed);
                if (dyn.responseFormat && dyn.responseFormat !== 'text') body.response_format = { type: dyn.responseFormat };
                // Pre-sanitize per model/provider to avoid 400s
                const { body: sanitized } = sanitizeRequestForModel({ body, provider, model: llmId });
                return { body: sanitized, messages, provider };
            }

            async function executeRunPrompt() {
                if (!runModal) return;
                runError.textContent = '';
                runResponseView.textContent = '';
                runLoading.classList.remove('hidden');
                try {
                    // Require a model chosen in Dock > Target LLM; transport (proxy/direct) is auto-resolved in llmRequest
                    if (!llmSelect || llmSelect.value === 'generic') throw new Error('Select a Target LLM in the Dock first.');
                    // Proxy-only: ensure active connection is server-stored
                    try {
                        const selModel = llmSelect?.value;
                        const selConn = resolveConnForModel(selModel);
                        if (!selConn || !selConn.server) {
                            throw new Error('Active LLM connection must be stored on server. Open API Console > LLM and add the API with "Store securely on server" enabled.');
                        }
                    } catch (e) { throw e; }
                    const { body, provider } = buildRunPayload();
                    const selModel = llmSelect?.value;
                    let selConn = resolveConnForModel(selModel);
                    // Proxy-only pre-check
                    if (!selConn || !selConn.server) {
                        throw new Error('Active LLM connection must be stored on server. Open API Console > LLM and add the API with "Store securely on server" enabled.');
                    }
                    // Check capabilities and choose endpoint upfront
                    const capsInfo = sanitizeRequestForModel({ body, provider, model: selModel });
                    if (capsInfo.unsupportedReason === 'image_generation') {
                        throw new Error('This model is for image generation and is not supported by Run Request.');
                    }
                    if (capsInfo.unsupportedReason === 'specialized_api') {
                        throw new Error('This model requires a specialized API (audio/realtime/transcribe/tts) and is not supported by this Run flow.');
                    }
                    // Convert messages->input for Responses API and prepare embeddings body when needed
                    let initialBody = capsInfo.body || body;
                    let path = 'chat/completions';
                    if (provider === 'openai' && capsInfo.preferEndpoint === 'responses') {
                        path = 'responses';
                        const inputText = (Array.isArray(initialBody.messages) ? initialBody.messages.map(m => m.content).join('\n\n') : (initialBody.input || '')) || 'ping';
                        const out = { model: initialBody.model, input: inputText };
                        if (typeof body.max_tokens === 'number') out.max_output_tokens = body.max_tokens;
                        initialBody = out;
                    }
                    if (provider === 'openai' && capsInfo.preferEndpoint === 'embeddings') {
                        path = 'embeddings';
                        const inputText = (Array.isArray(initialBody.messages) ? initialBody.messages.map(m => m.content).join('\n\n') : (initialBody.input || '')) || 'ping';
                        const out = { model: initialBody.model, input: inputText };
                        if (typeof body.dimensions === 'number') out.dimensions = body.dimensions;
                        initialBody = out;
                    }
                    // Deep research: ensure a minimal tool
                    if (provider === 'openai' && capsInfo.ensureTools) {
                        const tools = Array.isArray(initialBody.tools) ? initialBody.tools.slice(0) : [];
                        const hasTool = tools.some(t => t?.type === capsInfo.ensureTools);
                        if (!hasTool) tools.push({ type: capsInfo.ensureTools });
                        initialBody.tools = tools;
                    }
                    runRequestView.textContent = JSON.stringify(initialBody, null, 2);
                    // Add provider-specific headers when needed (llmRequest will also handle direct mode)
                    const headers = {};
                    let res = await llmRequest(path, { method: 'POST', body: initialBody, headers, connId: selConn?.id });
                    // If OpenAI/x.ai returns an unsupported parameter, strip it and retry once
                    if (!res.ok && (provider === 'openai' || provider === 'xai') && res.status === 400) {
                        try {
                            const errJson = await res.json();
                            const code = errJson?.error?.code;
                            const param = errJson?.error?.param;
                            if ((code === 'unsupported_value' || code === 'unsupported_parameter') && param) {
                                const retryBody = Object.assign({}, initialBody);
                                delete retryBody[param];
                                res = await llmRequest(path, { method: 'POST', body: retryBody, headers, connId: selConn?.id });
                            } else if (/Unsupported parameter/i.test(errJson?.error?.message || '')) {
                                const retryBody = Object.assign({}, initialBody);
                                ['top_p','temperature','presence_penalty','frequency_penalty','seed','stop','response_format'].forEach(k => { if (k in retryBody) delete retryBody[k]; });
                                res = await llmRequest(path, { method: 'POST', body: retryBody, headers, connId: selConn?.id });
                            }
                        } catch {}
                    }
                    // If OpenAI indicates a different endpoint is required, follow docs and retry accordingly
                    if (!res.ok && provider === 'openai' && (res.status === 404 || res.status === 400)) {
                        let text = '';
                        try { text = await res.clone().text(); } catch {}
                        // responses API
                        if (/only supported in v1\/responses/i.test(text)) {
                            const inputText = (Array.isArray(initialBody.messages) ? initialBody.messages.filter(m=>m.role==='user').map(m=>m.content).join('\n\n') : (initialBody.input || '')) || 'ping';
                            const respBody = { model: initialBody.model, input: inputText };
                            res = await llmRequest('responses', { method: 'POST', body: respBody, connId: selConn?.id });
                        }
                        // legacy completions API
                        else if (/not supported in the v1\/chat\/completions endpoint\..*v1\/completions/i.test(text)) {
                            const prompt = (Array.isArray(initialBody.messages) ? initialBody.messages.map(m => `${m.role}: ${m.content}`).join('\n') : '') || 'ping';
                            const compBody = { model: initialBody.model, prompt };
                            res = await llmRequest('completions', { method: 'POST', body: compBody, connId: selConn?.id });
                        }
                    }
                    if (!res.ok) {
                        let msg = `HTTP ${res.status}`;
                        try { const t = await res.text(); msg += ` - ${t}`; } catch {}
                        throw new Error(msg);
                    }
                    const data = await res.json();
                    let text = '';
                    // OpenAI Chat/Completions style
                    if (data?.choices?.length) {
                        const c = data.choices[0];
                        // If content is array of parts, join text parts
                        if (Array.isArray(c.message?.content)) {
                            text = c.message.content.map(p => typeof p === 'string' ? p : (p?.text || '')).filter(Boolean).join('\n');
                        } else {
                            text = c.message?.content || c.text || '';
                        }
                    }
                    // OpenAI Responses style – prefer output_text (plain) if present
                    else if (Array.isArray(data?.output_text) && data.output_text.length) {
                        text = data.output_text.join('\n');
                    }
                    // Some Responses return message/content arrays
                    else if (data?.message?.content) {
                        const mc = data.message.content;
                        text = Array.isArray(mc) ? mc.map(p => p?.text || '').filter(Boolean).join('\n') : mc;
                    }
                    // Anthropic messages content
                    else if (Array.isArray(data?.content) && data.content.length && data.content[0]?.text) {
                        try { text = data.content.map(p => p.text).filter(Boolean).join('\n\n'); } catch { text = data.content[0]?.text || ''; }
                    }
                    // Fallback: stringify only if explicitly requested JSON response
                    else {
                        // If the request specified response_format: json_object, keep JSON; else keep as empty string
                        const reqPreview = runRequestView.textContent || '';
                        if (/"response_format"\s*:\s*\{\s*"type"\s*:\s*"json_object"/i.test(reqPreview)) {
                            text = JSON.stringify(data, null, 2);
                        } else {
                            // try common fields
                            text = data?.text || '';
                        }
                    }
                    runResponseView.textContent = text;
                } catch (e) {
                    const msg = e?.message || String(e);
                    if (/Failed to fetch/i.test(msg)) {
                        let hint = 'Network/CORS blocked. ';
                        try {
                            const conn = (typeof getActiveLlmConn === 'function') ? getActiveLlmConn() : null;
                            const prov = conn && conn.base && typeof detectProvider === 'function' ? detectProvider(conn.base) : 'openai';
                            hint += 'Proxy is ON and this connection is server-stored; please verify your Supabase URL/KEY and function deployments.';
                        } catch {}
                        runError.textContent = `${msg}. ${hint}`;
                    } else {
                        runError.textContent = msg;
                    }
                } finally {
                    runLoading.classList.add('hidden');
                }
            }

            function openRunModal() {
                if (!runModal) return;
                runError.textContent = '';
                runResponseView.textContent = '';
                const { body } = buildRunPayload();
                runRequestView.textContent = JSON.stringify(body, null, 2);
                try {
                    const selModel = llmSelect?.value || 'generic';
                    const conn = resolveConnForModel(selModel) || ((typeof getActiveLlmConn === 'function') ? getActiveLlmConn() : null);
                    const base = conn?.base || (localStorage.getItem(API_KEYS.llm_base) || '');
                    let host = '';
                    try { host = base ? new URL(base).hostname : ''; } catch {}
                    const model = selModel;
                    const serverBadge = conn && conn.server ? ' • server' : ' • not server';
                    runActiveLlm.textContent = `Model: ${model}${host ? ' • ' + host : ''}${serverBadge}`;
                } catch { runActiveLlm.textContent = ''; }
                // If no model is selected, surface the LLM drawer to help selection
                if (!llmSelect || llmSelect.value === 'generic') {
                    try { if (typeof openDrawer === 'function') openDrawer('llm', 'Target LLM'); } catch {}
                }
                runModal.classList.remove('hidden');
            }
            function closeRunModal() { if (runModal) runModal.classList.add('hidden'); }
            if (runPromptBtn) runPromptBtn.addEventListener('click', openRunModal);
            if (runExecuteBtn) runExecuteBtn.addEventListener('click', executeRunPrompt);
            if (runCancelBtn) runCancelBtn.addEventListener('click', closeRunModal);
            if (closeRunModalBtn) closeRunModalBtn.addEventListener('click', closeRunModal);
            if (runModal) runModal.addEventListener('click', (e) => { if (e.target === runModal) closeRunModal(); });
            if (copyRunReqBtn) copyRunReqBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText(runRequestView.textContent || ''); } catch {} });
            if (copyRunResBtn) copyRunResBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText(runResponseView.textContent || ''); } catch {} });

            const projectsListContainer = document.getElementById('projects-list-container');

            const templatesModal = document.getElementById('templates-modal');
            const templatesBtn = document.getElementById('templates-btn');
            const closeTemplatesBtn = document.getElementById('close-templates-btn');
            const templatesGridContainer = document.getElementById('templates-grid-container');
            const templatesProjectFilter = document.getElementById('templates-project-filter');
            
            const dependencyViewerModal = document.getElementById('dependency-viewer-modal');
            const dependencyViewerTitle = document.getElementById('dependency-viewer-title');
            const dependencyViewerContent = document.getElementById('dependency-viewer-content');
            const closeDependencyViewerBtn = document.getElementById('close-dependency-viewer-btn');
            
            const commentsViewerModal = document.getElementById('comments-viewer-modal');
            const commentsViewerTitle = document.getElementById('comments-viewer-title');
            const commentsViewerContent = document.getElementById('comments-viewer-content');
            const closeCommentsViewerBtn = document.getElementById('close-comments-viewer-btn');

            const readModeBtn = document.getElementById('read-mode-btn');
            const readModeIconClosed = document.getElementById('read-mode-icon-closed');
            const readModeIconOpen = document.getElementById('read-mode-icon-open');
            const readModeModal = document.getElementById('read-mode-modal');
            const readModeContent = document.getElementById('read-mode-content');

            // Dashboard
            const dashboardBtn = document.getElementById('dashboard-btn');
            const dashboardModal = document.getElementById('dashboard-modal');
            const closeDashboardBtn = document.getElementById('close-dashboard-btn');
            const dashboardPeriodSelect = document.getElementById('dashboard-period-select');
            let tokensChart, promptsChart, modelsChart, projectsChart, statusChart, tagsChart;

            const diffModal = document.getElementById('diff-modal');
            const diffModalTitle = document.getElementById('diff-modal-title');
            const closeDiffModalBtn = document.getElementById('close-diff-modal-btn');
            const diffPanelA = document.getElementById('diff-panel-a');
            const diffPanelB = document.getElementById('diff-panel-b');
            const diffTitleA = document.getElementById('diff-title-a');
            const diffTitleB = document.getElementById('diff-title-b');

            // Modal Gráfico
            const graphViewBtn = document.getElementById('graph-view-btn');
            const dependencyGraphModal = document.getElementById('dependency-graph-modal');
            const closeDependencyGraphBtn = document.getElementById('close-dependency-graph-btn');
            const dependencyGraphSvg = document.getElementById('dependency-graph-svg');
            const graphProjectFilter = document.getElementById('graph-project-filter');
            const createConnectionBtn = document.getElementById('create-connection-btn');
            const deleteConnectionBtn = document.getElementById('delete-connection-btn');
            const graphTooltip = document.getElementById('graph-tooltip');
            
            // Modal Gerenciador de Listas
            const listManagerBtn = document.getElementById('list-manager-btn');
            const listManagerModal = document.getElementById('list-manager-modal');
            const closeListManagerBtn = document.getElementById('close-list-manager-btn');
            const xmlTagsManagerContainer = document.getElementById('xml-tags-manager-container');
            const varLibraryManagerContainer = document.getElementById('var-library-manager-container');
            const generalTagsManagerContainer = document.getElementById('general-tags-manager-container');
            const addGeneralTagManagerInput = document.getElementById('add-general-tag-manager-input');
            const addGeneralTagManagerBtn = document.getElementById('add-general-tag-manager-btn');
            const addXmlTagManagerInput = document.getElementById('add-xml-tag-manager-input');
            const addXmlTagManagerBtn = document.getElementById('add-xml-tag-manager-btn');
            const addVarLibraryManagerInput = document.getElementById('add-var-library-manager-input');
            const addVarLibraryManagerBtn = document.getElementById('add-var-library-manager-btn');
            const llmManagerContainer = document.getElementById('llm-manager-container');
            const addLlmCategoryManagerInput = document.getElementById('add-llm-category-manager-input');
            const addLlmCategoryManagerBtn = document.getElementById('add-llm-category-manager-btn');

            // Modal Input Gallery
            const inputGalleryBtn = document.getElementById('input-gallery-btn');
            const inputGalleryModal = document.getElementById('input-gallery-modal');
            const closeInputGalleryBtn = document.getElementById('close-input-gallery-btn');
            const inputGalleryList = document.getElementById('input-gallery-list');
            const inputGalleryProjectFilter = document.getElementById('input-gallery-project-filter');
            const inputGalleryProjectAssign = document.getElementById('input-gallery-project-assign');
            const inputGalleryEditor = document.getElementById('input-gallery-editor');
            const saveInputGalleryBtn = document.getElementById('save-input-gallery-btn');
            const inputGalleryName = document.getElementById('input-gallery-name');
            const inputGalleryId = document.getElementById('input-gallery-id');
            const addNewInputBtn = document.getElementById('add-new-input-btn');
            
            // Add Input Dropdown
            const addInputInput = document.getElementById('add-input-input');
            const addInputDropdown = document.getElementById('add-input-dropdown');
            // Import elements
            const importBtn = document.getElementById('import-btn');
            const importFromGitBtn = document.getElementById('import-from-git-btn');
            const importFileInput = document.getElementById('import-file-input');
            const importModal = document.getElementById('import-modal');
            const closeImportModalBtn = document.getElementById('close-import-modal');
            const importPromptNameInput = document.getElementById('import-prompt-name');
            const importProjectInput = document.getElementById('import-project');
            const importLlmSelect = document.getElementById('import-llm');
            const cancelImportBtn = document.getElementById('cancel-import');
            const confirmImportBtn = document.getElementById('confirm-import');
            // Commit modal refs
            const commitModal = document.getElementById('commit-modal');
            const closeCommitModalBtn = document.getElementById('close-commit-modal');
            const commitRepoLabel = document.getElementById('commit-repo-label');
            const commitBranchSelect = document.getElementById('commit-branch');
            const commitFilePathInput = document.getElementById('commit-file-path');
            const commitMessageInput = document.getElementById('commit-message');
            const commitLatestInfo = document.getElementById('commit-latest-info');
            const cancelCommitBtn = document.getElementById('cancel-commit');
            const confirmCommitBtn = document.getElementById('confirm-commit');
            const commitChangesBtn = document.getElementById('commit-changes-btn');
            // Import from Git modal refs
            const importGitModal = document.getElementById('import-git-modal');
            const closeImportGitModalBtn = document.getElementById('close-import-git-modal');
            const refreshGitBrowserBtn = document.getElementById('refresh-git-browser-btn');
            const gitBrowserRepos = document.getElementById('git-browser-repos');
            const gitBrowserFiles = document.getElementById('git-browser-files');
            const gitBrowserLoadReposBtn = document.getElementById('git-browser-load-repos-btn');
            const gitFilesFilterInput = document.getElementById('git-files-filter');
            const gitImportTitleInput = document.getElementById('git-import-title');
            const gitImportProjectInput = document.getElementById('git-import-project');
            const gitImportCancelBtn = document.getElementById('git-import-cancel');
            const gitImportConfirmBtn = document.getElementById('git-import-confirm');
            let pendingImportedText = '';
            let pendingImportFilename = '';
            let lastImportedGitFilePath = '';
            // Formatting toolbar removed

            // Find and Replace
            const findBtn = document.getElementById('find-btn');
            const findReplaceBar = document.getElementById('find-replace-bar');
            const findInput = document.getElementById('find-input');
            const replaceInput = document.getElementById('replace-input');
            const findCounter = document.getElementById('find-counter');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const replaceBtn = document.getElementById('replace-btn');
            const replaceAllBtn = document.getElementById('replace-all-btn');
            const closeFindBtn = document.getElementById('close-find-btn');

            // Dynamic Settings (model-aware)
            const dynamicSettingsContainer = document.getElementById('dynamic-settings-container');

            function getSelectedProviderAndCaps() {
                const llmId = llmSelect?.value || 'generic';
                let provider = 'openai';
                try {
                    const conn = (typeof resolveConnForModel === 'function') ? resolveConnForModel(llmId) : null;
                    const base = conn?.base || (typeof getActiveLlmConn === 'function' ? (getActiveLlmConn()?.base || '') : '') || (localStorage.getItem(API_KEYS.llm_base) || '');
                    if (typeof detectProvider === 'function') provider = detectProvider(base);
                } catch {}
                const caps = (typeof getModelCaps === 'function') ? getModelCaps(provider, llmId) : { provider };
                return { provider, llmId, caps };
            }

            function getDynamicSettingsSchema() {
                const { provider, llmId, caps } = getSelectedProviderAndCaps();
                // If unsupported modality, no editable settings
                if (caps && caps.unsupportedReason) return [];
                const fields = [];
                // Endpoint preferences can hide/show knobs
                const preferResp = caps && caps.preferEndpoint === 'responses';
                const preferEmbed = caps && caps.preferEndpoint === 'embeddings';

                // Embeddings: do not show tokens; show dimensions only
                if (preferEmbed) {
                    // Embeddings-specific controls
                    fields.push({ key: 'dimensions', type: 'number', label: 'Dimensions', min: 1, step: 1, default: '' });
                    return fields;
                }

                // For other endpoints, offer a tokens control with label adapted for Responses
                fields.push({ key: 'maxTokens', type: 'number', label: preferResp ? 'Max output tokens' : 'Max tokens', min: 1, step: 1, default: '' });

                // Provider-baseline knobs
                // No Anthropics-specific controls

                // For OpenAI/x.ai chat-like endpoints
                if (!preferResp) {
                    // Sampling knobs
                    fields.push({ key: 'temperature', type: 'range', label: 'Temperature', min: 0, max: 2, step: 0.1, default: 0.7, format: (v) => parseFloat(v).toFixed(1) });
                    fields.push({ key: 'topP', type: 'range', label: 'Top P', min: 0, max: 1, step: 0.01, default: 0.9, format: (v) => parseFloat(v).toFixed(2) });
                    fields.push({ key: 'stopSequences', type: 'textarea', label: 'Stop sequences (one per line)', default: '' });
                    if (provider === 'openai') {
                        // Only show OpenAI-specific penalties/seed/response format for OpenAI
                        fields.push({ key: 'presencePenalty', type: 'range', label: 'Presence penalty', min: -2, max: 2, step: 0.1, default: 0, format: (v) => parseFloat(v).toFixed(1) });
                        fields.push({ key: 'frequencyPenalty', type: 'range', label: 'Frequency penalty', min: -2, max: 2, step: 0.1, default: 0, format: (v) => parseFloat(v).toFixed(1) });
                        fields.push({ key: 'seed', type: 'number', label: 'Seed', min: 0, step: 1, default: '' });
                        fields.push({ key: 'responseFormat', type: 'select', label: 'Response format', options: ['text','json_object'], default: 'text' });
                    }
                }

                // Finally, remove any fields that the caps explicitly drop or disallow
                const allowed = caps && Array.isArray(caps.allowed) ? new Set(caps.allowed.map(k =>
                    // map our UI keys to body keys for comparison
                    ({ temperature:'temperature', topP:'top_p', presencePenalty:'presence_penalty', frequencyPenalty:'frequency_penalty', maxTokens:'max_tokens', stopSequences:'stop', seed:'seed', responseFormat:'response_format', dimensions:'dimensions' }[k] || k)
                )) : null;
                const drop = caps && Array.isArray(caps.drop) ? new Set(caps.drop) : new Set();
                const keyToBody = (k) => ({ temperature:'temperature', topP:'top_p', presencePenalty:'presence_penalty', frequencyPenalty:'frequency_penalty', maxTokens:'max_tokens', stopSequences:'stop', seed:'seed', responseFormat:'response_format', dimensions:'dimensions' }[k] || k);
                const filtered = fields.filter(f => {
                    const bodyKey = keyToBody(f.key);
                    if (drop.has(bodyKey)) return false;
                    if (allowed && !allowed.has(bodyKey)) return false;
                    return true;
                });
                return filtered;
            }

            function renderDynamicSettings(currentValues = {}) {
                const finalSchema = getDynamicSettingsSchema();

                dynamicSettingsContainer.innerHTML = '';

                finalSchema.forEach(field => {
                    const value = (currentValues && field.key in currentValues)
                        ? currentValues[field.key]
                        : (field.default !== undefined ? field.default : '');
                    const wrapper = document.createElement('div');
                    wrapper.className = 'space-y-1';
                    if (field.type === 'range') {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        const spanVal = document.createElement('span');
                        spanVal.className = 'font-mono';
                        spanVal.id = `setting-${field.key}-value`;
                        spanVal.textContent = field.format ? field.format(value) : String(value);
                        label.innerHTML = `<label>${field.label}</label>`;
                        label.appendChild(spanVal);
                        const input = document.createElement('input');
                        input.id = `setting-${field.key}`;
                        input.type = 'range';
                        input.min = field.min;
                        input.max = field.max;
                        input.step = field.step;
                        input.value = value;
                        input.className = 'w-full';
                        input.addEventListener('input', (e) => {
                            spanVal.textContent = field.format ? field.format(e.target.value) : String(e.target.value);
                        });
                        wrapper.appendChild(label);
                        wrapper.appendChild(input);
                    } else if (field.type === 'select') {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        label.innerHTML = `<label>${field.label}</label>`;
                        const select = document.createElement('select');
                        select.id = `setting-${field.key}`;
                        select.className = 'form-control rounded-md py-1 px-2 text-sm w-full';
                        (field.options || []).forEach(opt => {
                            const o = document.createElement('option');
                            o.value = opt; o.textContent = opt;
                            select.appendChild(o);
                        });
                        select.value = value;
                        // No summary chip; no-op
                        wrapper.appendChild(label);
                        wrapper.appendChild(select);
                    } else if (field.type === 'textarea') {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        label.innerHTML = `<label>${field.label}</label>`;
                        const ta = document.createElement('textarea');
                        ta.id = `setting-${field.key}`;
                        ta.className = 'form-control rounded-md py-1 px-2 text-sm w-full';
                        ta.rows = field.rows || 3;
                        ta.value = value || '';
                        // No summary chip; no-op
                        wrapper.appendChild(label);
                        wrapper.appendChild(ta);
                    } else if (field.type === 'messages') {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        label.innerHTML = `<label>${field.label}</label>`;
                        const container = document.createElement('div');
                        container.id = `setting-${field.key}`;
                        container.dataset.allowedRoles = JSON.stringify(field.allowedRoles || ['system','user','assistant']);
                        container.className = 'space-y-2';
                        const list = document.createElement('div');
                        list.className = 'space-y-2';
                        container.appendChild(list);
                        const rows = Array.isArray(value) ? value : (field.default || []);
                        const renderRow = (row, idx) => {
                            const rowEl = document.createElement('div');
                            rowEl.className = 'flex items-start gap-2';
                            rowEl.dataset.index = String(idx);
                            const roleSel = document.createElement('select');
                            roleSel.className = 'form-control rounded-md py-1 px-2 text-sm w-32';
                            const roles = field.allowedRoles || ['system','user','assistant'];
                            roles.forEach(r => {
                                const o = document.createElement('option');
                                o.value = r; o.textContent = r;
                                roleSel.appendChild(o);
                            });
                            roleSel.value = row.role || roles[0];
                            // No summary chip; no-op
                            const ta = document.createElement('textarea');
                            ta.className = 'form-control rounded-md py-1 px-2 text-sm flex-1';
                            ta.rows = 3;
                            ta.placeholder = 'Enter message content...';
                            ta.value = row.content || '';
                            // No summary chip; no-op
                            const delBtn = document.createElement('button');
                            delBtn.className = 'action-button text-xs';
                            delBtn.textContent = 'Remove';
                            delBtn.addEventListener('click', () => {
                                rowEl.remove();
                                // No summary chip; no-op
                            });
                            rowEl.appendChild(roleSel);
                            rowEl.appendChild(ta);
                            rowEl.appendChild(delBtn);
                            list.appendChild(rowEl);
                        };
                        rows.forEach((r, i) => renderRow(r, i));
                        const addBtn = document.createElement('button');
                        addBtn.className = 'action-button text-xs';
                        addBtn.textContent = 'Add message';
                        addBtn.addEventListener('click', () => {
                            renderRow({ role: (field.allowedRoles || ['system','user','assistant'])[0], content: '' }, list.children.length);
                            // No summary chip; no-op
                        });
                        wrapper.appendChild(label);
                        wrapper.appendChild(container);
                        wrapper.appendChild(addBtn);
                    } else if (field.type === 'number') {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        label.innerHTML = `<label>${field.label}</label>`;
                        const input = document.createElement('input');
                        input.id = `setting-${field.key}`;
                        input.type = 'number';
                        if (typeof field.min !== 'undefined') input.min = field.min;
                        if (typeof field.max !== 'undefined') input.max = field.max;
                        if (typeof field.step !== 'undefined') input.step = field.step;
                        input.value = value ?? '';
                        input.className = 'form-control rounded-md py-1 px-2 text-sm w-full';
                        // No summary chip; no-op
                        wrapper.appendChild(label);
                        wrapper.appendChild(input);
                    } else {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        label.innerHTML = `<label>${field.label}</label>`;
                        const input = document.createElement('input');
                        input.id = `setting-${field.key}`;
                        input.type = 'text';
                        input.value = value || '';
                        input.className = 'form-control rounded-md py-1 px-2 text-sm w-full';
                        // No summary chip; no-op
                        wrapper.appendChild(label);
                        wrapper.appendChild(input);
                    }
                    dynamicSettingsContainer.appendChild(wrapper);
                });

                // Summary chip removed; advanced options always visible
            }

            function collectDynamicSettings() {
                const finalSchema = getDynamicSettingsSchema();
                const out = {};
                finalSchema.forEach(field => {
                    if (field.type === 'messages') {
                        const container = document.getElementById(`setting-${field.key}`);
                        if (!container) return;
                        const rows = [...container.querySelectorAll('[data-index]')];
                        out[field.key] = rows.map(r => {
                            const role = r.querySelector('select')?.value || 'user';
                            const content = r.querySelector('textarea')?.value || '';
                            return { role, content };
                        }).filter(m => m.content && m.content.trim().length > 0);
                        return;
                    }
                    const el = document.getElementById(`setting-${field.key}`);
                    if (!el) return;
                    if (field.type === 'range') {
                        const num = parseFloat(el.value);
                        out[field.key] = isNaN(num) ? el.value : num;
                    } else if (field.type === 'number') {
                        const num = el.value === '' ? '' : Number(el.value);
                        out[field.key] = num;
                    } else if (field.type === 'textarea') {
                        out[field.key] = el.value;
                    } else {
                        out[field.key] = el.value;
                    }
                });
                return out;
            }

            // Summary chip removed; keeping function space minimal

            // Tags
            const tagsInput = document.getElementById('tags-input-aside');
            const tagsContainer = document.getElementById('tags-container-aside');
            const tagsDropdown = document.getElementById('tags-dropdown-aside');
            
            // Var Library
            const varLibraryInput = document.getElementById('var-library-input');
            const addVarLibraryBtn = document.getElementById('add-var-library-btn');
            const varLibraryDropdown = document.getElementById('var-library-dropdown');
            
            // Node Flow
            const nodeFlowBtn = document.getElementById('node-flow-btn');
            const nodeFlowModal = document.getElementById('node-flow-modal');
            const closeNodeFlowBtn = document.getElementById('close-node-flow-btn');
            const nodeFlowPromptList = document.getElementById('node-flow-prompt-list');
            const nodeFlowCanvas = document.getElementById('node-flow-canvas');
            const nodeFlowContent = document.getElementById('node-flow-content');
            const nodeFlowConnections = document.getElementById('node-flow-connections');
            const connectionsGroup = document.getElementById('connections-group');
            const nodeFlowProjectFilter = document.getElementById('node-flow-project-filter');
            const saveFlowBtn = document.getElementById('save-flow-btn');
            const savedFlowsDropdown = document.getElementById('saved-flows-dropdown');
            const deleteFlowBtn = document.getElementById('delete-flow-btn');

            // If D3 is unavailable (offline), disable features that require it
            if (!hasD3) {
                if (nodeFlowBtn) { nodeFlowBtn.disabled = true; nodeFlowBtn.title = 'Disabled: D3 not loaded (offline)'; }
                if (graphViewBtn) { graphViewBtn.disabled = true; graphViewBtn.title = 'Disabled: D3 not loaded (offline)'; }
            }

            // --- FUNÇÕES DE DADOS (AGORA COM SUPABASE) ---
            const loadFromLocalStorage = () => {
                try {
                    prompts = JSON.parse(localStorage.getItem(PROMPTS_STORAGE_KEY) || '[]');
                    templates = JSON.parse(localStorage.getItem(TEMPLATES_STORAGE_KEY) || '[]');
                    inputGallery = JSON.parse(localStorage.getItem(INPUT_GALLERY_STORAGE_KEY) || '[]');
                    savedFlows = JSON.parse(localStorage.getItem(NODE_FLOWS_STORAGE_KEY) || '[]');
                    xmlTags = JSON.parse(localStorage.getItem(XML_TAGS_STORAGE_KEY) || '[]');
                    varLibrary = JSON.parse(localStorage.getItem(VAR_LIBRARY_STORAGE_KEY) || '[]');
                    llmList = JSON.parse(localStorage.getItem(LLM_LIST_STORAGE_KEY) || '{}');
                    projectNames = JSON.parse(localStorage.getItem(PROJECTS_STORAGE_KEY) || '[]');
                    projectRepoMap = JSON.parse(localStorage.getItem(PROJECT_REPO_MAP_STORAGE_KEY) || '{}');
                    console.info('Loaded data from localStorage (offline mode).');
                } catch (e) {
                    console.error('Error loading from localStorage:', e);
                }
            };

            const mapPromptRowToUI = (row) => {
                try {
                    return {
                        // keep DB id
                        id: row.id,
                        // unify camelCase used by UI
                        promptId: String(row.prompt_id || row.promptId || row.promptid || row.id || ''),
                        // parent can be in parent_id (old) or parant_id (new); prefer new if present
                        parentId: row.parant_id || row.parent_id || row.parentId || null,
                        title: row.title,
                        content: row.content,
                        tags: Array.isArray(row.tags) ? row.tags : [],
                        project: row.project,
                        llm: row.llm,
                        status: row.status,
                        // prefer explicit date column, fallback to created_at or now
                        date: row.date || row.created_at || new Date().toISOString(),
                        // keep any extra UI-only fields if present
                        comments: row.comments || '',
                        version: row.version || '1.0',
                        temperature: typeof row.temperature === 'number' ? row.temperature : 0.7,
                        // topP may arrive as top_p from DB; prefer UI camelCase
                        topP: typeof row.topP === 'number' ? row.topP : (typeof row.top_p === 'number' ? row.top_p : 0.9),
                        effort: row.effort || 'Medium',
                        dependencies: Array.isArray(row.dependencies) ? row.dependencies : ((row.parant_id || row.parent_id) ? [row.parant_id || row.parent_id] : [])
                    };
                } catch { return row; }
            };

            // Project UI prompt object to DB snake_case columns and allowlist fields
        const mapPromptUIToDb = (item) => {
                const out = {
                    id: item.id,
                    prompt_id: item.promptId || item.prompt_id || item.promptid,
            // write to new parant_id; keep legacy parent_id if present for compatibility
            parant_id: item.parentId || item.parant_id || item.parent_id || null,
                    title: item.title,
                    content: item.content,
                    tags: Array.isArray(item.tags) ? item.tags : [],
                    project: item.project,
                    llm: item.llm,
                    status: item.status,
            date: item.date ? new Date(item.date).toISOString() : null,
            // include top_p for DB from UI topP when available
            top_p: typeof item.topP === 'number' ? item.topP : (typeof item.top_p === 'number' ? item.top_p : undefined),
            temperature: typeof item.temperature === 'number' ? item.temperature : undefined,
            effort: item.effort
                };
                // remove undefined to avoid Postgrest errors on upsert
                Object.keys(out).forEach(k => { if (typeof out[k] === 'undefined') delete out[k]; });
                return out;
            };

            const loadDataFromSupabase = async () => {
                try {
                    const dbStatus = document.getElementById('db-status-pill');
                    if (dbStatus) {
                        dbStatus.textContent = dbOnline ? 'DB: Online' : 'DB: Offline';
                        dbStatus.classList.remove('online', 'offline');
                        dbStatus.classList.add(dbOnline ? 'online' : 'offline');
                    }

                    if (!supabaseClient) {
                        loadFromLocalStorage();
                        return;
                    }

                    // Require auth for fetching app data
                    try {
                        const { data: sess } = await supabaseClient.auth.getSession();
                        if (!sess?.session) {
                            // signed out: don't fallback to localStorage; prompt login via initializeApp()
                            return;
                        }
                    } catch {}

                    console.log("Fetching data from Supabase...");

                    const { data: promptsData, error: promptsError } = await supabaseClient.from('prompts').select('*');
                    if (promptsError) throw promptsError;
                    prompts = (promptsData || []).map(mapPromptRowToUI);

                    const { data: templatesData, error: templatesError } = await supabaseClient.from('templates').select('*');
                    if (templatesError) throw templatesError;
                    templates = templatesData || [];

                    const { data: inputGalleryData, error: inputGalleryError } = await supabaseClient.from('input_gallery').select('*');
                    if (inputGalleryError) throw inputGalleryError;
                    inputGallery = inputGalleryData || [];

                    const { data: nodeFlowsData, error: nodeFlowsError } = await supabaseClient.from('node_flows').select('*');
                    if (nodeFlowsError) throw nodeFlowsError;
                    savedFlows = nodeFlowsData || [];

                    const { data: listsData, error: listsError } = await supabaseClient.from('global_lists').select('*');
                    if (listsError) throw listsError;

                    xmlTags = listsData.find(l => l.name === 'xml_tags')?.data || [];
                    varLibrary = listsData.find(l => l.name === 'var_library')?.data || [];
                    llmList = listsData.find(l => l.name === 'llm_list')?.data || {};
                    projectNames = listsData.find(l => l.name === 'projects')?.data || [];
                    projectRepoMap = listsData.find(l => l.name === 'project_repo_map')?.data || {};
                    // Prime per-connection model caches from server map if present
                    try {
                        const cacheMap = listsData.find(l => l.name === 'llm_models_cache')?.data || {};
                        Object.entries(cacheMap).forEach(([connId, ids]) => {
                            try { localStorage.setItem(modelsCacheKey(connId), JSON.stringify(ids || [])); } catch {}
                        });
                    } catch {}

                    console.log("Data fetched successfully!");

                } catch (error) {
                    console.error("Error loading data from Supabase, falling back to localStorage:", error);
                    loadFromLocalStorage();
                }
            };

                        // Funções para salvar/atualizar/deletar dados individuais
            const upsertItem = async (table, data) => {
                if (!supabaseClient) {
                    // Offline: optimistically return the provided data as "saved"
                    return Array.isArray(data) ? data : [data];
                }
                const { data: rows, error } = await supabaseClient.from(table).upsert(data).select();
                if (error) { console.error(`Error upserting to ${table}:`, error); return null; }
                return rows || null;
            };

            const deleteItem = async (table, id) => {
                if (!supabaseClient) return; // offline: only mutate local state
                const { error } = await supabaseClient.from(table).delete().eq('id', id);
                if (error) console.error(`Error deleting from ${table}:`, error);
            };

            // Specific helper to delete a node_flow by its unique name
            const deleteNodeFlowByName = async (name) => {
                if (!supabaseClient) return; // offline: handled by local state update
                const { error } = await supabaseClient.from('node_flows').delete().eq('name', name);
                if (error) console.error('Error deleting from node_flows by name:', error);
            };

            const deleteItemsByPromptId = async (promptId) => {
                if (!supabaseClient) return;
                const { error } = await supabaseClient.from('prompts').delete().eq('prompt_id', promptId);
                if (error) console.error(`Error deleting prompts by promptId:`, error);
            };

            const updateGlobalList = async (listName, data) => {
                if (!supabaseClient) return; // offline
                const { error } = await supabaseClient.from('global_lists').upsert({ name: listName, data });
                if (error) console.error(`Error updating global list ${listName}:`, error);
            }

            const savePromptsToStorage = () => localStorage.setItem(PROMPTS_STORAGE_KEY, JSON.stringify(prompts));
            const saveXmlTagsToStorage = () => localStorage.setItem(XML_TAGS_STORAGE_KEY, JSON.stringify(xmlTags));
            const saveTemplatesToStorage = () => localStorage.setItem(TEMPLATES_STORAGE_KEY, JSON.stringify(templates));
            const saveVarLibraryToStorage = () => localStorage.setItem(VAR_LIBRARY_STORAGE_KEY, JSON.stringify(varLibrary));
            const saveLlmListToStorage = () => localStorage.setItem(LLM_LIST_STORAGE_KEY, JSON.stringify(llmList));
            const saveInputGalleryToStorage = () => localStorage.setItem(INPUT_GALLERY_STORAGE_KEY, JSON.stringify(inputGallery));
            const saveFlowsToStorage = () => localStorage.setItem(NODE_FLOWS_STORAGE_KEY, JSON.stringify(savedFlows));
            const saveProjectNamesToStorage = () => localStorage.setItem(PROJECTS_STORAGE_KEY, JSON.stringify(projectNames));
            const saveProjectRepoMapToStorage = () => localStorage.setItem(PROJECT_REPO_MAP_STORAGE_KEY, JSON.stringify(projectRepoMap));


            // --- FUNÇÕES DE LÓGICA ---
            const addCurrentXmlTag = () => {
                const source = (typeof confirmModalInput !== 'undefined' && !confirmModal.classList.contains('hidden')) ? confirmModalInput : xmlTagInput;
                const tagName = (source?.value || '').trim();
                if (tagName && !xmlTags.includes(tagName)) {
                    xmlTags.push(tagName);
                    saveXmlTagsToStorage();
                    updateGlobalList('xml_tags', xmlTags);
                    if (source) source.value = '';
                }
            };

            const addCurrentVarToLibrary = () => {
                const source = (typeof confirmModalInput !== 'undefined' && !confirmModal.classList.contains('hidden')) ? confirmModalInput : varLibraryInput;
                let varName = (source?.value || '').trim();
                if (varName) {
                    if (!varName.startsWith('{{') || !varName.endsWith('}}')) {
                        varName = `{{${varName.replace(/{{|}}/g, '')}}}`;
                    }
                    if (!varLibrary.includes(varName)) {
                        varLibrary.push(varName);
                        saveVarLibraryToStorage();
                        updateGlobalList('var_library', varLibrary)
                        if (source) source.value = '';
                    }
                }
            };

            // --- FUNÇÕES DE RENDERIZAÇÃO ---
            const populateLlmSelect = () => {
                const currentVal = llmSelect.value;
                llmSelect.innerHTML = '<option value="generic">Unspecified</option>';
                
                const sortedGroupNames = Object.keys(llmList).sort();

                sortedGroupNames.forEach(groupName => {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = groupName;
                    llmList[groupName].sort().forEach(llm => {
                        const option = document.createElement('option');
                        option.value = llm;
                        option.textContent = llm;
                        optgroup.appendChild(option);
                    });
                    llmSelect.appendChild(optgroup);
                });
                
                const allLlms = Object.values(llmList).flat();
                if (allLlms.includes(currentVal)) {
                    llmSelect.value = currentVal;
                } else {
                    llmSelect.value = 'generic';
                }
            };

            const formatDate = (dateString) => {
                const date = new Date(dateString);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = String(date.getFullYear()).slice(-2);
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${day}/${month}/${year} ${hours}:${minutes}`;
            };

            // Compose the union of projects across prompts, templates, inputGallery and saved projectNames
            const getAllProjects = () => {
                const fromPrompts = prompts.map(p => p.project).filter(Boolean);
                const fromTemplates = templates.map(t => t.project).filter(Boolean);
                const fromInputs = inputGallery.map(i => i.project).filter(Boolean);
                return [...new Set([...fromPrompts, ...fromTemplates, ...fromInputs, ...projectNames])].sort();
            };

            const populateProjectList = (selectElement) => {
                const projects = getAllProjects();
                selectElement.innerHTML = '<option value="all">All Projects</option>';
                projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project;
                    option.textContent = project;
                    selectElement.appendChild(option);
                });
            };

            // For assignment dropdowns (no "All" option); includes an empty unassigned entry
            const populateProjectAssignList = (selectElement) => {
                const projects = getAllProjects();
                selectElement.innerHTML = '<option value="">Unassigned</option>';
                projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project;
                    option.textContent = project;
                    selectElement.appendChild(option);
                });
            };
            
            const populateProjectDataList = () => {
                 const projectList = document.getElementById('project-list-aside');
                 const existingProjects = [...new Set(prompts.map(p => p.project).filter(Boolean))];
                 projectList.innerHTML = '';
                 existingProjects.forEach(project => {
                     const option = document.createElement('option');
                     option.value = project;
                     projectList.appendChild(option);
                 });
            };

            // --- Dependencies state and helpers ---
            let currentDependencies = [];
            const getSortedPromptsForDeps = () => {
                return [...prompts].sort((a, b) => a.title.localeCompare(b.title) || parseFloat(b.version) - parseFloat(a.version));
            };
            const renderDependenciesDropdown = (filter = '') => {
                const list = dependenciesList;
                list.innerHTML = '';
                const q = (filter || '').toLowerCase();
                getSortedPromptsForDeps().forEach(p => {
                    if (String(p.id) === String(selectedVersionId)) return; // don't depend on self
                    const label = `${p.title} (v${p.version})`;
                    if (q && !label.toLowerCase().includes(q)) return;
                    const row = document.createElement('div');
                    row.className = 'px-3 py-2 hover:bg-[#333] border-b border-[--border-dark] cursor-pointer flex items-start gap-3';
                    const idStr = String(p.id);
                    row.innerHTML = `
                        <input type="checkbox" class="mt-1 h-4 w-4 flex-shrink-0" data-id="${idStr}" ${currentDependencies.map(String).includes(idStr) ? 'checked' : ''}>
                        <div class="min-w-0 flex-1">
                            <div class="text-sm font-mono truncate">${label}</div>
                            <div class="text-xs text-[--text-muted-dark] truncate">${p.project || 'No project'} • LLM: ${p.llm || 'N/A'}</div>
                        </div>
                    `;
                    // toggle checkbox on row click for bigger hit area
                    row.addEventListener('click', (e) => {
                        const target = e.target;
                        if (target && target.tagName && target.tagName.toLowerCase() === 'input') return;
                        const cb = row.querySelector('input[type="checkbox"]');
                        if (cb) cb.checked = !cb.checked;
                    });
                    list.appendChild(row);
                });
            };
            const openDependenciesDropdown = () => {
                renderDependenciesDropdown('');
                dependenciesSearch.value = '';
                dependenciesDropdown.classList.remove('hidden');
                dependenciesSearch.focus();
            };
            const closeDependenciesDropdown = () => {
                dependenciesDropdown.classList.add('hidden');
            };
            
            const renderDependencyBar = (deps) => {
                const depIds = Array.isArray(deps) ? deps : (deps ? [deps] : []);
                currentDependencies = depIds.map(String);
                const depPrompts = depIds.map(id => prompts.find(p => String(p.id) === String(id))).filter(Boolean);
                dependencyTagContainer.innerHTML = depPrompts.length
                    ? depPrompts.map(dp => `<span class="dependency-tag text-sm font-mono" data-dependency-id="${dp.id}">${dp.title} (v${dp.version})</span>`).join(' ')
                    : '<span class="text-xs text-[--text-muted-dark]">No dependencies</span>';
            };

            const renderVersionsList = () => {
                versionsHistoryList.innerHTML = '';
                const filterText = searchInput.value.toLowerCase().trim();
                
                const allGroupedPrompts = prompts.reduce((acc, p) => {
                    if (!acc[p.promptId]) {
                        acc[p.promptId] = { title: p.title, project: p.project, versions: [] };
                    }
                    acc[p.promptId].versions.push(p);
                    acc[p.promptId].title = p.title;
                    acc[p.promptId].project = p.project;
                    return acc;
                }, {});

                const filteredAndSortedGroups = Object.keys(allGroupedPrompts)
                    .map(promptId => {
                        const group = allGroupedPrompts[promptId];
                        // Filter versions within the group first
                        const matchingVersions = group.versions.filter(v => {
                            const matchesStatus = activeStatusFilter === 'all' || v.status === activeStatusFilter;
                            if (!matchesStatus) return false;

                            if (filterText === '') return true;

                            if (filterText.startsWith('#')) {
                                return v.tags && v.tags.some(tag => tag.toLowerCase().includes(filterText));
                            } else {
                                const matchesTitle = v.title.toLowerCase().includes(filterText);
                                const matchesProject = v.project && v.project.toLowerCase().includes(filterText);
                                const matchesTags = v.tags && v.tags.some(tag => tag.toLowerCase().includes(filterText));
                                return matchesTitle || matchesProject || matchesTags;
                            }
                        });

                        // If the group has matching versions, return it with only those versions
                        if (matchingVersions.length > 0) {
                            return {
                                promptId,
                                title: group.title,
                                project: group.project,
                                versions: matchingVersions.sort((a, b) => parseFloat(b.version) - parseFloat(a.version))
                            };
                        }
                        return null; // Otherwise, discard the group
                    })
                    .filter(Boolean); // Remove null groups


                if (filteredAndSortedGroups.length === 0) {
                    versionsHistoryList.innerHTML = `<p class="text-sm text-[--text-muted-dark] p-2">No results found.</p>`;
                    return;
                }

                filteredAndSortedGroups.forEach(group => {
                    const isExpanded = expandedPromptGroups.has(group.promptId);
                    const groupContainer = document.createElement('div');
                    groupContainer.className = 'prompt-group group';
                    const header = document.createElement('div');
                    header.className = `prompt-group-header ${isExpanded ? 'expanded' : ''}`;
                    header.dataset.promptId = group.promptId;
                    header.innerHTML = `
                        <div class="flex items-center flex-grow truncate">
                            <svg class="toggle-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                            <div class="flex flex-col">
                                <span class="truncate font-sans font-medium text-sm">${group.title}</span>
                                <span class="truncate font-sans text-xs text-[--text-muted-dark]">${group.project || 'No project'}</span>
                            </div>
                        </div>
                        <button data-action="delete-group" data-prompt-id="${String(group.promptId)}" class="delete-group-btn invisible group-hover:visible p-1 rounded-md hover:bg-red-900/50 text-[--text-muted-dark] hover:text-red-400">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    `;
                    const subList = document.createElement('div');
                    subList.className = `version-sub-list ${isExpanded ? 'expanded' : ''}`;
                    group.versions.forEach(p => {
                        const item = document.createElement('div');
                        item.className = 'version-item font-mono';
                        item.innerHTML = `
                            <div class="flex items-center flex-grow" data-action="select" data-id="${String(p.id)}">
                                <input type="checkbox" class="mr-3 h-4 w-4 rounded bg-gray-700 border-gray-600 text-fuchsia-600 focus:ring-fuchsia-500" data-id="${String(p.id)}" data-prompt-id="${String(p.promptId)}">
                                <span class="truncate pr-2 text-gray-400">Version</span>
                                <span class="font-medium text-white">${p.version}</span>
                            </div>
                            <span class="text-xs text-gray-500" data-action="select" data-id="${String(p.id)}">${formatDate(p.date)}</span>
                        `;
                        if (String(p.id) === String(selectedVersionId)) item.classList.add('selected');
                        subList.appendChild(item);
                    });
                    groupContainer.appendChild(header);
                    groupContainer.appendChild(subList);
                    versionsHistoryList.appendChild(groupContainer);
                });
            };

            const renderGallery = () => {
                galleryGrid.innerHTML = ''; // Limpa o conteúdo anterior

                const groupedPrompts = prompts.reduce((acc, p) => {
                    if (!acc[p.promptId]) {
                        acc[p.promptId] = [];
                    }
                    acc[p.promptId].push(p);
                    return acc;
                }, {});

                const latestVersions = Object.values(groupedPrompts).map(versions => {
                    return versions.sort((a, b) => {
                        const [majorA, minorA = 0] = a.version.split('.').map(Number);
                        const [majorB, minorB = 0] = b.version.split('.').map(Number);
                        if (majorA !== majorB) return majorB - majorA;
                        return minorB - minorA;
                    })[0];
                });

                latestVersions.forEach(prompt => {
                    const versionCount = groupedPrompts[prompt.promptId].length;
                    const depCount = Array.isArray(prompt.dependencies) ? prompt.dependencies.length : (prompt.parentId ? 1 : 0);
                    let dependencyTitle = 'N/A';
                    if (prompt.parentId) {
                        const parentPrompt = prompts.find(p => p.id === prompt.parentId);
                        if (parentPrompt) {
                            dependencyTitle = `${parentPrompt.title} (v${parentPrompt.version})`;
                        }
                    }

                    const card = document.createElement('div');
                    card.className = 'gallery-card standard-card bg-[--card-bg-dark] border border-[--border-dark] rounded-md p-3 flex flex-col text-xs text-[--text-dark]';
                    card.innerHTML = `
                        <div class="flex items-center gap-2 mb-1">
                            <h3 class="font-bold text-base truncate pr-2 flex-1 min-w-0" style="color: var(--accent-fuchsia);">${prompt.title}</h3>
                            <span class="text-xs font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5 shrink-0">${versionCount} ${versionCount > 1 ? 'versions' : 'version'}</span>
                        </div>
                        <div class="mb-1">
                            <span class="text-[10px] font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5">${depCount} ${depCount === 1 ? 'dependency' : 'dependencies'}</span>
                        </div>
                        <div class="space-y-1 flex-grow">
                            <p><strong class="text-[--text-muted-dark] font-normal">Project:</strong> ${prompt.project || 'N/A'}</p>
                            <p><strong class="text-[--text-muted-dark] font-normal">LLM:</strong> ${prompt.llm || 'N/A'}</p>
                            <p><strong class="text-[--text-muted-dark] font-normal">Repo:</strong> ${prompt.githubRepoFull || prompt.githubRepo || 'N/A'}</p>
                        </div>
                        <div class="mt-3 pt-2 border-t border-[--border-dark] grid grid-cols-3 gap-2 text-center font-mono">
                            <div>
                                <p class="text-[--text-muted-dark] text-xs">Temp</p>
                                <p class="font-semibold text-sm">${prompt.temperature}</p>
                            </div>
                            <div>
                                <p class="text-[--text-muted-dark] text-xs">Top P</p>
                                <p class="font-semibold text-sm">${prompt.topP}</p>
                            </div>
                            <div>
                                <p class="text-[--text-muted-dark] text-xs">Effort</p>
                                <p class="font-semibold text-sm">${prompt.effort}</p>
                            </div>
                        </div>
                    `;
                    card.addEventListener('click', () => {
                        loadVersionIntoEditor(prompt.id);
                        galleryModal.classList.add('hidden');
                    });
                    galleryGrid.appendChild(card);
                });
            };

            const renderProjectsView = () => {
                projectsListContainer.innerHTML = '';
                // Build repositories dropdown options from GitHub connections list
                let repoOptions = [];
                try {
                    const ghList = JSON.parse(localStorage.getItem('github_repo_list') || '[]');
                    repoOptions = ghList.map(r => ({ id: r.id, label: r.repo || r.id }));
                } catch {}
                const groupedByProject = prompts.reduce((acc, p) => {
                    const project = p.project || 'No Project';
                    if (!acc[project]) {
                        acc[project] = [];
                    }
                    acc[project].push(p);
                    return acc;
                }, {});

                const allProjectSet = new Set([...Object.keys(groupedByProject), ...projectNames]);
                const allProjects = Array.from(allProjectSet).sort();

                allProjects.forEach(project => {
                    const projectWrapper = document.createElement('div');
                    projectWrapper.className = 'mb-6';
                    
                    const headerRow = document.createElement('div');
                    headerRow.className = 'flex items-center justify-between border-b border-[--border-dark] pb-2 mb-3';
                    const projectTitle = document.createElement('h3');
                    projectTitle.className = 'text-lg font-bold text-[--accent-fuchsia]';
                    projectTitle.textContent = project;
                    headerRow.appendChild(projectTitle);
                    // Repo selector on the right
                    const repoWrap = document.createElement('div');
                    repoWrap.className = 'flex items-center gap-2';
                    const repoLabel = document.createElement('label');
                    repoLabel.className = 'text-xs font-medium text-[--text-muted-dark]';
                    repoLabel.textContent = 'Repository:';
                    const repoSelect = document.createElement('select');
                    repoSelect.className = 'form-control rounded-md py-1 px-2 text-xs';
                    const emptyOpt = document.createElement('option');
                    emptyOpt.value = '';
                    emptyOpt.textContent = 'Unassigned';
                    repoSelect.appendChild(emptyOpt);
                    repoOptions.forEach(({ id, label }) => {
                        const opt = document.createElement('option');
                        opt.value = id;
                        opt.textContent = label;
                        repoSelect.appendChild(opt);
                    });
                    // Preselect saved mapping
                    const saved = projectRepoMap[project] || '';
                    repoSelect.value = saved;
                    repoSelect.addEventListener('change', async () => {
                        projectRepoMap[project] = repoSelect.value;
                        saveProjectRepoMapToStorage();
                        try { await updateGlobalList('project_repo_map', projectRepoMap); } catch {}
                    });
                    repoWrap.appendChild(repoLabel);
                    repoWrap.appendChild(repoSelect);
                    headerRow.appendChild(repoWrap);
                    projectWrapper.appendChild(headerRow);

                    const table = document.createElement('table');
                    table.className = 'w-full text-left text-xs table-fixed';
                    table.innerHTML = `
                        <thead>
                            <tr class="border-b border-[--border-dark]">
                                <th class="py-2 px-2 font-semibold w-[25%]">Prompt</th>
                                <th class="py-2 px-2 font-semibold text-center w-[8%]">Version</th>
                                <th class="py-2 px-2 font-semibold w-[22%]">Dependence</th>
                                <th class="py-2 px-2 font-semibold w-[15%]">Target</th>
                                <th class="py-2 px-2 font-semibold text-center w-[7%]">Temp</th>
                                <th class="py-2 px-2 font-semibold text-center w-[7%]">Top P</th>
                                <th class="py-2 px-2 font-semibold w-[10%]">Effort</th>
                                <th class="py-2 px-2 font-semibold text-center w-[6%]">Notes</th>
                            </tr>
                        </thead>
                    `;
                    const tbody = document.createElement('tbody');
                    const rows = (groupedByProject[project] || []).sort((a,b) => a.title.localeCompare(b.title) || parseFloat(b.version) - parseFloat(a.version));
                    rows.forEach(prompt => {
                        let dependencyTitle = 'N/A';
                        if (prompt.parentId) {
                            const parentPrompt = prompts.find(p => p.id === prompt.parentId);
                            if (parentPrompt) {
                                dependencyTitle = `${parentPrompt.title} (v${parentPrompt.version})`;
                            }
                        }

                        const row = document.createElement('tr');
                        row.className = 'hover:bg-[#333] cursor-pointer border-b border-[--border-dark]';
                        row.dataset.id = prompt.id;
                        row.innerHTML = `
                            <td class="py-2 px-2 truncate">${prompt.title}</td>
                            <td class="py-2 px-2 text-center">${prompt.version}</td>
                            <td class="py-2 px-2 truncate">${dependencyTitle}</td>
                            <td class="py-2 px-2 truncate">${prompt.llm}</td>
                            <td class="py-2 px-2 text-center">${prompt.temperature}</td>
                            <td class="py-2 px-2 text-center">${prompt.topP}</td>
                            <td class="py-2 px-2">${prompt.effort}</td>
                        `;
                        
                        const commentsCell = document.createElement('td');
                        commentsCell.className = 'py-2 px-2 text-center';
                        if (prompt.comments && prompt.comments.trim() !== '') {
                            commentsCell.innerHTML = `
                                <button data-action="view-comments" data-id="${prompt.id}" class="p-1 rounded-md text-[--text-muted-dark] hover:text-white hover:bg-[#333]">
                                    <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12c0 4.556-4.03 8.25-9 8.25a9.764 9.764 0 01-2.555-.337A5.972 5.972 0 015.41 20.97a5.969 5.969 0 01-.474-.065 4.48 4.48 0 00.978-2.025c.09-.457-.133-.901-.467-1.226C3.93 16.178 3 14.189 3 12c0-4.556 4.03-8.25 9-8.25s9 3.694 9 8.25z" />
                                    </svg>
                                </button>
                            `;
                        }
                        row.appendChild(commentsCell);
                        tbody.appendChild(row);
                    });

                    table.appendChild(tbody);
                    projectWrapper.appendChild(table);
                    projectsListContainer.appendChild(projectWrapper);
                });
            };

            const renderTemplatesGrid = () => {
                const selectedProject = (typeof templatesProjectFilter !== 'undefined' && templatesProjectFilter) ? templatesProjectFilter.value : 'all';
                templatesGridContainer.innerHTML = '';
                const list = (selectedProject === 'all') ? templates : templates.filter(t => (t.project || '') === selectedProject);
                if (list.length === 0) {
                    templatesGridContainer.innerHTML = `<p class="text-sm text-[--text-muted-dark] col-span-full">No templates saved.</p>`;
                    return;
                }

                list.forEach(template => {
                    let dependencyTitle = 'N/A';
                    if (template.parentId) {
                        const parentPrompt = prompts.find(p => p.id === template.parentId);
                        if (parentPrompt) {
                            dependencyTitle = `${parentPrompt.title} (v${parentPrompt.version})`;
                        }
                    }
                    const depCount = Array.isArray(template.dependencies) ? template.dependencies.length : (template.parentId ? 1 : 0);

                    const card = document.createElement('div');
                    card.className = 'gallery-card standard-card bg-[--card-bg-dark] border border-[--border-dark] rounded-md p-3 flex flex-col text-xs text-[--text-dark]';
                    card.dataset.id = template.id;

                    card.innerHTML = `
                        <div class="flex justify-between items-start mb-2">
                            <h3 class="font-bold text-base truncate pr-2" style="color: var(--accent-fuchsia);">${template.name}</h3>
                            <span class="text-xs font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5">Template</span>
                        </div>
                        <div class="mb-1">
                            <span class="text-[10px] font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5">${depCount} ${depCount === 1 ? 'dependency' : 'dependencies'}</span>
                        </div>
                        <div class="space-y-1 flex-grow mb-3">
                            <p class="truncate"><strong class="text-[--text-muted-dark] font-normal">Based on:</strong> ${template.title || 'N/A'}</p>
                            <p><strong class="text-[--text-muted-dark] font-normal">Project:</strong> ${template.project || 'N/A'}</p>
                            <p><strong class="text-[--text-muted-dark] font-normal">LLM:</strong> ${template.llm || 'N/A'}</p>
                        </div>
                        <div class="mt-auto pt-2 border-t border-[--border-dark] grid grid-cols-3 gap-2 text-center font-mono">
                            <div>
                                <p class="text-[--text-muted-dark] text-xs">Temp</p>
                                <p class="font-semibold text-sm">${template.temperature}</p>
                            </div>
                            <div>
                                <p class="text-[--text-muted-dark] text-xs">Top P</p>
                                <p class="font-semibold text-sm">${template.topP}</p>
                            </div>
                             <div>
                                <p class="text-[--text-muted-dark] text-xs">Effort</p>
                                <p class="font-semibold text-sm">${template.effort}</p>
                            </div>
                        </div>
                        <div class="mt-3 pt-3 border-t border-[--border-dark] flex gap-2">
                            <button data-action="load-template" class="action-button primary flex-grow text-center">Use</button>
                            <button data-action="delete-template" class="action-button text-red-500 hover:bg-red-900/20 hover:border-red-800">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                            </button>
                        </div>
                    `;
                    templatesGridContainer.appendChild(card);
                });
            };
            
            const updateStatusSelectorUI = (status) => {
                document.querySelectorAll('.status-option').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.status === status) btn.classList.add('active');
                });
            };

            const updateStatusFilterUI = () => {
                document.querySelectorAll('#status-filter-container .filter-tag-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.filter === activeStatusFilter) btn.classList.add('active');
                });
            };

            const updateEditorStats = () => {
                const content = mainEditor.value;
                const charCount = content.length;
                const wordCount = content.trim().split(/\s+/).filter(Boolean).length;
                const tokenCount = Math.ceil(charCount / 4);
                editorStats.textContent = `${tokenCount} tokens / ${wordCount} words / ${charCount} characters`;
            };

            // ===== Dashboard helpers =====
            const getISOWeek = (date) => {
                const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
                const dayNum = d.getUTCDay() || 7;
                d.setUTCDate(d.getUTCDate() + 4 - dayNum);
                const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
                const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1)/7);
                return { year: d.getUTCFullYear(), week: weekNo };
            };

            const groupByPeriod = (items, period) => {
                const map = new Map();
                const add = (key, t, w, c, d) => {
                    const cur = map.get(key) || { tokens: 0, words: 0, chars: 0, count: 0, sort: d.getTime() };
                    cur.tokens += t; cur.words += w; cur.chars += c; cur.count += 1; cur.sort = Math.max(cur.sort, d.getTime());
                    map.set(key, cur);
                };
                items.forEach(p => {
                    const content = p.content || '';
                    const chars = content.length || 0;
                    const words = (content.trim().match(/\S+/g) || []).length;
                    const tokens = Math.ceil(chars / 4);
                    const d = p.date ? new Date(p.date) : new Date();
                    let key;
                    if (period === 'day') {
                        key = d.toISOString().slice(0,10);
                    } else if (period === 'week') {
                        const { year, week } = getISOWeek(d);
                        key = `${year}-W${String(week).padStart(2,'0')}`;
                    } else {
                        key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
                    }
                    add(key, tokens, words, chars, d);
                });
                const labels = Array.from(map.keys()).sort((a,b) => (map.get(a).sort || 0) - (map.get(b).sort || 0));
                const data = labels.map(l => map.get(l));
                return { labels, data };
            };

            const getCounts = (arr, mapper) => {
                const map = new Map();
                arr.forEach(x => {
                    const key = mapper(x) || 'N/A';
                    map.set(key, (map.get(key)||0)+1);
                });
                const labels = Array.from(map.keys());
                const data = labels.map(l => map.get(l));
                return { labels, data };
            };

            const getTopTags = (arr, topN = 10) => {
                const map = new Map();
                arr.forEach(p => {
                    (p.tags || []).forEach(tag => {
                        map.set(tag, (map.get(tag)||0)+1);
                    });
                });
                const entries = Array.from(map.entries()).sort((a,b) => b[1]-a[1]).slice(0, topN);
                return { labels: entries.map(e=>e[0]), data: entries.map(e=>e[1]) };
            };

            const destroyIf = (chart) => { if (chart && typeof chart.destroy === 'function') chart.destroy(); };
            const getChartColors = () => {
                const isLight = document.documentElement.getAttribute('data-theme') === 'light';
                const text = getComputedStyle(document.documentElement).getPropertyValue('--text-dark')?.trim() || (isLight ? '#1F2937' : '#e5e7eb');
                return {
                    line1: 'rgba(236, 72, 153, 1)',
                    line2: 'rgba(59, 130, 246, 1)',
                    line3: 'rgba(16, 185, 129, 1)',
                    bar: 'rgba(234, 179, 8, 0.9)',
                    dough: ['#60A5FA','#F472B6','#34D399','#F59E0B','#A78BFA','#F43F5E','#10B981','#8B5CF6','#22D3EE','#EAB308'],
                    grid: isLight ? 'rgba(0,0,0,0.08)' : 'rgba(148,163,184,0.2)',
                    text,
                    tooltipBg: isLight ? 'rgba(0,0,0,0.75)' : 'rgba(15,15,15,0.9)',
                    tooltipColor: '#FFFFFF'
                };
            };

            const renderDashboardCharts = (period = 'month') => {
                if (typeof Chart === 'undefined') {
                    showModal('Unavailable', 'Dashboard requires Chart.js which is not loaded (offline).', [
                        { text: 'OK', className: 'action-button primary', onClick: hideModal }
                    ]);
                    return;
                }
                const ctxTokens = document.getElementById('tokensChart').getContext('2d');
                const ctxPrompts = document.getElementById('promptsChart').getContext('2d');
                const ctxModels  = document.getElementById('modelsChart').getContext('2d');
                const ctxProjects= document.getElementById('projectsChart').getContext('2d');
                const ctxStatus  = document.getElementById('statusChart').getContext('2d');
                const ctxTags    = document.getElementById('tagsChart').getContext('2d');

                const grouped = groupByPeriod(prompts, period);
                const labels = grouped.labels;
                const tokens = grouped.data.map(d => d.tokens);
                const words  = grouped.data.map(d => d.words);
                const chars  = grouped.data.map(d => d.chars);
                const counts = grouped.data.map(d => d.count);

                const chartColors = getChartColors();

                destroyIf(tokensChart); destroyIf(promptsChart); destroyIf(modelsChart); destroyIf(projectsChart); destroyIf(statusChart); destroyIf(tagsChart);

                tokensChart = new Chart(ctxTokens, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            { label: 'Tokens', data: tokens, borderColor: chartColors.line1, backgroundColor: chartColors.line1, fill: false, tension: 0.2 },
                            { label: 'Words',  data: words,  borderColor: chartColors.line2, backgroundColor: chartColors.line2, fill: false, tension: 0.2 },
                            { label: 'Chars',  data: chars,  borderColor: chartColors.line3, backgroundColor: chartColors.line3, fill: false, tension: 0.2 }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: { padding: { top: 2, right: 2, bottom: 2, left: 2 } },
                        plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } },
                        elements: { point: { radius: 0, hitRadius: 2 }, line: { borderWidth: 1 } },
                        scales: {
                            x: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } },
                            y: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } }
                        }
                    }
                });

                promptsChart = new Chart(ctxPrompts, {
                    type: 'bar',
                    data: { labels, datasets: [{ label: 'Versions', data: counts, backgroundColor: chartColors.bar, barPercentage: 0.9, categoryPercentage: 0.9 }] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: { padding: { top: 2, right: 2, bottom: 2, left: 2 } },
                        plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } },
                        scales: {
                            x: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } },
                            y: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } }
                        }
                    }
                });

                const models = getCounts(prompts, p => p.llm || 'generic');
                modelsChart = new Chart(ctxModels, {
                    type: 'doughnut', data: { labels: models.labels, datasets: [{ data: models.data, backgroundColor: chartColors.dough }] },
                    options: { responsive: true, maintainAspectRatio: false, cutout: '60%', plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } } }
                });

                const projects = getCounts(prompts, p => p.project || 'No Project');
                projectsChart = new Chart(ctxProjects, {
                    type: 'bar', data: { labels: projects.labels, datasets: [{ label: 'Prompts', data: projects.data, backgroundColor: chartColors.line2, barPercentage: 0.9, categoryPercentage: 0.9 }] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        layout: { padding: { top: 2, right: 2, bottom: 2, left: 2 } },
                        plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } },
                        scales: {
                            x: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } },
                            y: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } }
                        }
                    }
                });

                const status = getCounts(prompts, p => p.status || 'unknown');
                statusChart = new Chart(ctxStatus, {
                    type: 'doughnut', data: { labels: status.labels, datasets: [{ data: status.data, backgroundColor: chartColors.dough }] },
                    options: { responsive: true, maintainAspectRatio: false, cutout: '60%', plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } } }
                });

                const topTags = getTopTags(prompts, 10);
                tagsChart = new Chart(ctxTags, {
                    type: 'bar', data: { labels: topTags.labels, datasets: [{ label: 'Usage', data: topTags.data, backgroundColor: chartColors.line3, barPercentage: 0.9, categoryPercentage: 0.9 }] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        layout: { padding: { top: 2, right: 2, bottom: 2, left: 2 } },
                        plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } },
                        scales: {
                            x: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } },
                            y: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } }
                        }
                    }
                });
            };

            // ===== Dashboard events =====
            if (dashboardBtn && dashboardModal) {
                dashboardBtn.addEventListener('click', () => {
                    dashboardModal.classList.remove('hidden');
                    const sel = document.getElementById('dashboard-period-select');
                    const period = sel ? sel.value : 'month';
                    renderDashboardCharts(period);
                });
                const closeBtn = document.getElementById('close-dashboard-btn');
                closeBtn && closeBtn.addEventListener('click', () => {
                    dashboardModal.classList.add('hidden');
                });
                dashboardModal.addEventListener('click', (e) => {
                    if (e.target === dashboardModal) dashboardModal.classList.add('hidden');
                });
                const sel = document.getElementById('dashboard-period-select');
                sel && sel.addEventListener('change', (e) => {
                    renderDashboardCharts(e.target.value);
                });
            }

            // ===== API Console =====
            const apiConsoleBtn = document.getElementById('api-console-btn');
            const apiConsoleModal = document.getElementById('api-console-modal');
            const closeApiConsoleBtn = document.getElementById('close-api-console-btn');
            const initSqlTextarea = document.getElementById('init-sql-textarea');
            const supabaseUrlInput = document.getElementById('supabase-url-input');
            const supabaseKeyInput = document.getElementById('supabase-key-input');
            const supabaseIntegrateBtn = document.getElementById('supabase-integrate-btn');
            const supabaseIntegrateStatus = document.getElementById('supabase-integrate-status');
            const llmApiBaseInput = document.getElementById('llm-api-base-input');
            const llmApiKeyInput = document.getElementById('llm-api-key-input');
            const llmTestBtn = document.getElementById('llm-test-btn');
            const llmTestStatus = document.getElementById('llm-test-status');
            const llmCurlInput = document.getElementById('llm-curl-input');
            const llmParseCurlBtn = document.getElementById('llm-parse-curl-btn');
            const llmAddCurlBtn = document.getElementById('llm-add-curl-btn');
            const llmCurlStatus = document.getElementById('llm-curl-status');
            const githubTokenInput = document.getElementById('github-token-input');
            const githubRepoInput = document.getElementById('github-repo-input');
            const githubTestBtn = document.getElementById('github-test-btn');
            const githubTestStatus = document.getElementById('github-test-status');
            const llmStoreServerCheckbox = document.getElementById('llm-store-server-checkbox');
            const ghStoreServerCheckbox = document.getElementById('gh-store-server-checkbox');
            const apiTabBtns = document.querySelectorAll('.api-tab-btn');
            const llmApiListEl = document.getElementById('llm-api-list');
            const llmAddApiBtn = document.getElementById('llm-add-api-btn');
            const ghRepoListEl = document.getElementById('github-repo-list');
            const ghAddRepoBtn = document.getElementById('github-add-repo-btn');
            // Proxy is always ON; remove UI toggle
            // removed copy buttons for function code templates
            const llmLoadModelsBtn = document.getElementById('llm-load-models-btn');
            const llmRebuildListBtn = document.getElementById('llm-rebuild-llm-list-btn');
            const llmAvailableModelsEl = document.getElementById('llm-available-models');
            const ghLoadReposBtn = document.getElementById('github-load-repos-btn');
            const ghAvailableReposEl = document.getElementById('github-available-repos');
            const ghReposToggle = document.getElementById('github-repos-toggle');
            const ghReposCaret = document.getElementById('github-repos-caret');
            // Dock GitHub toggle elements
            const dockGhLoadReposBtn = document.getElementById('dock-github-load-repos-btn');
            const dockGhAvailableReposEl = document.getElementById('dock-github-available-repos');
            const dockGhReposToggle = document.getElementById('dock-github-repos-toggle');
            const dockGhReposCaret = document.getElementById('dock-github-repos-caret');
            const ghRepoFoldersToggle = document.getElementById('github-repo-folders-toggle');
            const ghRepoFoldersCaret = document.getElementById('github-repo-folders-caret');
            const ghLoadFoldersBtn = document.getElementById('github-load-folders-btn');
            const ghRepoFoldersEl = document.getElementById('github-repo-folders');
            const verifyFunctionsBtn = document.getElementById('verify-functions-btn');
            const verifyOpenaiStatus = document.getElementById('verify-openai-status');
            const verifyAllBtn = document.getElementById('llm-verify-all-btn');
            const verifyOut = document.getElementById('llm-verify-output');
            const verifyProgress = document.getElementById('llm-verify-progress');
            const verifyGithubStatus = document.getElementById('verify-github-status');

                        // SQL console and templates removed from UI

            const API_KEYS = {
                supabase_url: 'supabase_url',
                supabase_key: 'supabase_anon_key',
        // legacy local secret keys removed; secrets must be stored server-side only
        llm_base: 'llm_api_base', // kept only to aid curl parsing UI, not persisted
        llm_key: 'llm_api_key',   // kept only to aid curl parsing UI, not persisted
        gh_token: 'github_token', // kept only for UI input convenience, not persisted
        gh_repo: 'github_repo',
        llm_multi: 'llm_api_list',    // array of { id, base, label, server: true }
        gh_multi: 'github_repo_list', // array of { id, repo, server: true }
                llm_active: 'llm_api_active_id',
                                gh_active: 'github_repo_active_id',
                                use_proxy: 'use_proxy_mode'
            };

    // Remove legacy migration that stored secrets locally. Connections must be created via server only.
    function migrateSingleLlmToMulti() { return; }

            const loadApiSettings = () => {
                try {
            // Proxy toggle removed; proxy is always enabled
            if (llmStoreServerCheckbox) llmStoreServerCheckbox.checked = true;
            const ghStoreServerCheckbox = document.getElementById('gh-store-server-checkbox');
            if (ghStoreServerCheckbox) ghStoreServerCheckbox.checked = true;
                    // Do not auto-fill secrets from localStorage anymore; keep inputs empty by default
                    if (llmApiBaseInput) llmApiBaseInput.value = '';
                    if (llmApiKeyInput) llmApiKeyInput.value = '';
                    if (githubTokenInput) githubTokenInput.value = '';
                    if (githubRepoInput) githubRepoInput.value = localStorage.getItem(API_KEYS.gh_repo) || '';
                    // Ensure legacy single LLM is visible in the multi list
                    migrateSingleLlmToMulti();
                    renderLlmApiList();
                    renderGithubRepoList();
                    // Prune orphaned LLM groups so Target LLM mirrors API Console
                    syncLlmListWithConnections();
                } catch (e) { console.warn('Failed to load API settings', e); }
            };

    // Proxy-only mode: always true
    const useProxyEnabled = () => true;

            async function verifyFunctions() {
                if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return { openai: false, github: false };
                const base = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                const headers = await buildFnHeaders();
                const tryProbe = async (path, body) => {
                    try {
                        const r = await fetch(base + path, { method: 'POST', headers, body: JSON.stringify(body) });
                        return r.status !== 404;
                    } catch { return false; }
                };
                const openai = await tryProbe('/proxy-ai-api', { path: 'models', method: 'GET', config_id: '00000000-0000-0000-0000-000000000000' })
                             || await tryProbe('/proxy-llm', { path: 'models', method: 'GET', conn_id: '00000000-0000-0000-0000-000000000000' });
                const github = await tryProbe('/proxy-github-conn', { path: 'user', method: 'GET', conn_id: '00000000-0000-0000-0000-000000000000' });
                return { openai, github };
            }
            // Note: connections-manager POST expects { type: 'llm'|'github', label, base_url, api_key } and sets user_id via JWT
            //       connections-manager DELETE expects ?id=uuid and validates ownership via JWT+RLS
            //       proxy-llm expects { conn_id, path, method, body }, resolves credentials from api_connections, decrypts, and proxies

            const saveIfPresent = (el, key) => {
                // Never persist LLM/GitHub secrets to localStorage anymore
                const forbidden = new Set([API_KEYS.llm_key, API_KEYS.llm_base, API_KEYS.gh_token]);
                if (!el || !el.value || forbidden.has(key)) return;
                localStorage.setItem(key, el.value);
            };
            // ===== Active connection helpers (global) =====
            function getActiveLlmConn() {
                const list = JSON.parse(localStorage.getItem(API_KEYS.llm_multi) || '[]');
                const activeId = localStorage.getItem(API_KEYS.llm_active);
                return list.find(i => i.id === activeId) || null;
            }
            // Pending server-stored LLM connection created during Test, before user clicks Add
            let PENDING_LLM_CONN = null; // { id, base, label, server: true }
        // Cache detected function variants
    let FN_VARIANTS = { aiProxy: null, saveConfig: null, listConfig: null, deleteConfig: null, connLlm: null, connGh: null, ghProxy: null };
        async function detectFnVariants() {
            if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return FN_VARIANTS;
            if (FN_VARIANTS.aiProxy) return FN_VARIANTS;
            const base = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
            const headers = await buildFnHeaders();
            try {
                const r = await fetch(base + '/proxy-ai-api', { method: 'POST', headers, body: JSON.stringify({ path: 'models', method: 'GET', config_id: '00000000-0000-0000-0000-000000000000' }) });
                if (r.status !== 404) FN_VARIANTS.aiProxy = 'new';
            } catch {}
            try {
                if (!FN_VARIANTS.aiProxy) {
                    const r = await fetch(base + '/proxy-llm', { method: 'POST', headers, body: JSON.stringify({ path: 'models', method: 'GET', conn_id: '00000000-0000-0000-0000-000000000000' }) });
                    if (r.status !== 404) FN_VARIANTS.aiProxy = 'old';
                }
            } catch {}
            try {
                const r = await fetch(base + '/save-ai-api-config', { method: 'POST', headers, body: JSON.stringify({ name: 'probe', provider: 'openai', base_url: 'https://api.openai.com/v1', api_key: 'x' }) });
                if (r.status !== 404) FN_VARIANTS.saveConfig = 'new';
            } catch {}
            try {
                const r = await fetch(base + '/list-ai-api-configs', { method: 'GET', headers });
                if (r.status !== 404) FN_VARIANTS.listConfig = 'new';
            } catch {}
            try {
                const r = await fetch(base + '/delete-ai-api-config?id=00000000-0000-0000-0000-000000000000', { method: 'DELETE', headers });
                if (r.status !== 404) FN_VARIANTS.deleteConfig = 'new';
            } catch {}
            try {
                const r = await fetch(base + '/connections-llm', { method: 'POST', headers, body: JSON.stringify({ base_url: 'x', api_key: 'x' }) });
                if (r.status !== 404) FN_VARIANTS.connLlm = 'present';
            } catch {}
            try {
                const r = await fetch(base + '/connections-github', { method: 'POST', headers, body: JSON.stringify({ repo: 'x/y', token: 'z' }) });
                if (r.status !== 404) FN_VARIANTS.connGh = 'present';
            } catch {}
            try {
                const r = await fetch(base + '/proxy-github-conn', { method: 'POST', headers, body: JSON.stringify({ path: 'user', method: 'GET', conn_id: '00000000-0000-0000-0000-000000000000' }) });
                if (r.status !== 404) FN_VARIANTS.ghProxy = 'conn';
            } catch {}
            if (!FN_VARIANTS.saveConfig) FN_VARIANTS.saveConfig = 'old';
            return FN_VARIANTS;
        }

        async function buildFnHeaders() {
            const base = { 'Content-Type': 'application/json', 'apikey': FINAL_SUPABASE_KEY };
            try {
                if (supabaseClient && supabaseClient.auth) {
                    const { data } = await supabaseClient.auth.getSession();
                    const token = data?.session?.access_token;
                    if (token) return { ...base, 'Authorization': `Bearer ${token}` };
                }
            } catch {}
            // fallback to anon key (may not authorize user-only functions)
            return { ...base, 'Authorization': `Bearer ${FINAL_SUPABASE_KEY}` };
        }

        async function llmRequest(path, init = {}) {
            // Proxy-only: require Supabase and a server-stored connection
            const connOverrideId = init && init.connId ? init.connId : null;
            const conn = connOverrideId ? (typeof getLlmConnections === 'function' ? getLlmConnections().find(c => c.id === connOverrideId) : null) || getActiveLlmConn() : getActiveLlmConn();
            if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) throw new Error('Supabase proxy not configured.');
            if (!conn || !conn.server) throw new Error('Active LLM connection is not server-stored. Add it with "Store securely on server" in API Console > LLM.');
            const raw = init && 'body' in init ? init.body : null;
            const method = init && init.method ? init.method : 'POST';
            const fwdHeaders = init && init.headers ? init.headers : undefined;
            let bodyObj = null;
            if (raw) {
                if (typeof raw === 'string') { try { bodyObj = JSON.parse(raw); } catch { bodyObj = null; } }
                else if (typeof raw === 'object') { bodyObj = raw; }
            }
            await detectFnVariants();
            const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
            const headersFn = await buildFnHeaders();
            if (FN_VARIANTS.aiProxy === 'new') {
                return fetch(baseFn + '/proxy-ai-api', { method: 'POST', headers: headersFn, body: JSON.stringify({ config_id: conn.id, path, method, body: bodyObj, headers: fwdHeaders }) });
            }
            return fetch(baseFn + '/proxy-llm', { method: 'POST', headers: headersFn, body: JSON.stringify({ conn_id: conn.id, path, method, body: bodyObj, headers: fwdHeaders }) });
        }

            function getActiveGithubConn() {
                const list = JSON.parse(localStorage.getItem(API_KEYS.gh_multi) || '[]');
                const activeId = localStorage.getItem(API_KEYS.gh_active);
                return list.find(i => i.id === activeId) || null;
            }
            async function githubRequest(path, init = {}) {
                // Proxy-only: require Supabase
                if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) throw new Error('Supabase proxy not configured.');
                const body = init && 'body' in init ? init.body : null;
                const method = init && init.method ? init.method : 'GET';
                const base = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                const headers = await buildFnHeaders();
                // Prefer connection-based proxy if an active server-stored connection exists
                const conn = getActiveGithubConn();
                if (conn && conn.server) {
                    return fetch(base + '/proxy-github-conn', { method: 'POST', headers, body: JSON.stringify({ conn_id: conn.id, path, method, body }) });
                }
                throw new Error('Active GitHub connection is not server-stored. Add it with "Store securely on server" in API Console > Github.');
            }

            // expose minimal API for future use
            window.PromptManaAPI = Object.assign(window.PromptManaAPI || {}, {
                getActiveLlmConn, llmRequest, getActiveGithubConn, githubRequest
            });


            const setStatus = (el, ok, msgOk = 'OK', msgFail = 'Failed') => {
                if (!el) return;
                el.textContent = ok ? msgOk : msgFail;
                el.style.color = ok ? 'var(--accent-mint)' : 'var(--accent-red)';
            };

            

            const testSupabase = async (url, key) => {
                try {
                    if (!window.supabase || !window.supabase.createClient) return false;
                    const client = window.supabase.createClient(url, key);
                    const { error } = await client.from('global_lists').select('name').limit(1);
                    if (error && (error.code === '42P01' || (error.message && error.message.includes('relation')))) {
                        // table missing but auth ok => treat as connected
                        return true;
                    }
                    return !error;
                } catch { return false; }
            };

            // Probe a single model using its connection and provider-safe body
            async function probeModel(conn, modelId) {
                const base = conn?.base || '';
                const provider = (typeof detectProvider === 'function') ? detectProvider(base) : 'openai';
                const minimalMsg = [{ role: 'user', content: 'ping' }];
                const rawBody = { model: modelId, messages: minimalMsg };
                const caps = sanitizeRequestForModel({ body: rawBody, provider, model: modelId });
                if (caps.unsupportedReason) {
                    return new Response(`UNSUPPORTED in Run/Diagnostics (${caps.unsupportedReason})`, { status: 400 });
                }
                let path = 'chat/completions';
                if (provider === 'openai' && caps.preferEndpoint === 'responses') {
                    path = 'responses';
                } else if (provider === 'openai' && caps.preferEndpoint === 'embeddings') {
                    path = 'embeddings';
                }
                const headers = {};
                // Prepare body for chosen endpoint
                let effectiveBody = caps.body || rawBody;
                if (provider === 'openai' && path === 'responses') {
                    const inputText = (Array.isArray(effectiveBody.messages) ? effectiveBody.messages.map(m => m.content).join('\n\n') : (effectiveBody.input || '')) || 'ping';
                    effectiveBody = { model: effectiveBody.model, input: inputText };
                }
                if (provider === 'openai' && path === 'embeddings') {
                    const inputText = (Array.isArray(effectiveBody.messages) ? effectiveBody.messages.map(m => m.content).join('\n\n') : (effectiveBody.input || '')) || 'ping';
                    effectiveBody = { model: effectiveBody.model, input: inputText };
                }
                if (provider === 'openai' && caps.ensureTools) {
                    const tools = Array.isArray(effectiveBody.tools) ? effectiveBody.tools.slice(0) : [];
                    const hasTool = tools.some(t => t?.type === caps.ensureTools);
                    if (!hasTool) tools.push({ type: caps.ensureTools });
                    effectiveBody.tools = tools;
                }
                // Send sanitized+converted body
                let res = await llmRequest(path, { method: 'POST', body: effectiveBody, headers, connId: conn?.id });
                if (!res.ok && (provider === 'openai' || provider === 'xai') && res.status === 400) {
                    try {
                        const j = await res.json();
                        if ((j?.error?.code === 'unsupported_value' || j?.error?.code === 'unsupported_parameter') && j?.error?.param) {
                            const copy = Object.assign({}, caps.body || rawBody);
                            delete copy[j.error.param];
                            res = await llmRequest(path, { method: 'POST', body: copy, headers, connId: conn?.id });
                        } else if (/Unsupported parameter/i.test(j?.error?.message || '')) {
                            const copy = Object.assign({}, caps.body || rawBody);
                            ['top_p','temperature','presence_penalty','frequency_penalty','seed','stop','response_format'].forEach(k => { if (k in copy) delete copy[k]; });
                            res = await llmRequest(path, { method: 'POST', body: copy, headers, connId: conn?.id });
                        }
                    } catch {}
                }
                // OpenAI endpoint guidance fallbacks for diagnostics as well
                if (!res.ok && provider === 'openai' && (res.status === 404 || res.status === 400)) {
                    let text = '';
                    try { text = await res.clone().text(); } catch {}
                    if (/only supported in v1\/responses/i.test(text)) {
                        const b = effectiveBody;
                        const inputText = (Array.isArray(b.messages) ? b.messages.filter(m=>m.role==='user').map(m=>m.content).join('\n\n') : '') || 'ping';
                        const respBody = { model: b.model, input: inputText };
                        res = await llmRequest('responses', { method: 'POST', body: respBody, connId: conn?.id });
                    } else if (/not supported in the v1\/chat\/completions endpoint\..*v1\/completions/i.test(text)) {
                        const b = effectiveBody;
                        const prompt = (Array.isArray(b.messages) ? b.messages.map(m => `${m.role}: ${m.content}`).join('\n') : '') || 'ping';
                        const compBody = { model: b.model, prompt };
                        res = await llmRequest('completions', { method: 'POST', body: compBody, connId: conn?.id });
                    }
                }
                return res;
            }

            async function verifyAllModels() {
                try {
                    if (verifyOut) verifyOut.textContent = '';
                    if (verifyProgress) verifyProgress.textContent = 'Starting…';
                    const conns = (typeof getLlmConnections === 'function') ? getLlmConnections() : [];
                    const groups = Object.keys(llmList || {});
                    const results = [];
                    // Map group -> conn
                    const groupToConn = {};
                    conns.forEach(c => { try { groupToConn[computeConnGroup(c)] = c; } catch {} });
                    for (const g of groups) {
                        const ids = (llmList[g] || []).slice(0); // copy
                        const conn = groupToConn[g] || null;
                        for (const id of ids) {
                            if (verifyProgress) verifyProgress.textContent = `Testing ${id}…`;
                            let status = 'OK';
                            let info = '';
                            try {
                                if (!conn) throw new Error('no-conn-for-group');
                                // If Proxy is ON and this non-openai conn is local, store on server first
                                if (!conn.server) throw new Error('connection-not-server');
                                const res = await probeModel(conn, id);
                                if (!res.ok) {
                                    status = `FAIL ${res.status}`;
                                    try { info = await res.text(); } catch {}
                                }
                            } catch (e) {
                                status = 'ERR';
                                info = e?.message || String(e);
                            }
                            results.push({ model: id, group: g, status, info });
                            if (verifyOut) verifyOut.textContent += `${g} :: ${id} -> ${status}${info ? ' — ' + info : ''}\n`;
                        }
                    }
                    if (verifyProgress) verifyProgress.textContent = 'Done';
                    return results;
                } catch (e) {
                    if (verifyProgress) verifyProgress.textContent = 'Error';
                    if (verifyOut) verifyOut.textContent += `Diagnostics error: ${e?.message || String(e)}\n`;
                    return [];
                }
            }

            // Helper: update LLM status pill
            function setLlmStatus(ok, textOk = 'LLM API: Online', textFail = 'LLM API: Offline') {
                const llmStatus = document.getElementById('llm-status-pill');
                if (!llmStatus) return;
                llmStatus.textContent = ok ? textOk : textFail;
                llmStatus.classList.remove('online','offline');
                llmStatus.classList.add(ok ? 'online' : 'offline');
            }

            // Run diagnostics, then filter model caches and llmList to only OK entries
            async function verifyAndFilterModels() {
                try {
                    // Ensure LLM lists are in sync with current connections
                    syncLlmListWithConnections();
                    const results = await verifyAllModels();
                    // Build a map of OK models per connection group
                    const okByGroup = {};
                    (results || []).forEach(r => {
                        const ok = r.status === 'OK';
                        if (ok) {
                            if (!okByGroup[r.group]) okByGroup[r.group] = new Set();
                            okByGroup[r.group].add(r.model);
                        }
                    });
                    // Filter per-connection caches and llmList to only OK models
                    const conns = (typeof getLlmConnections === 'function') ? getLlmConnections() : [];
                    conns.forEach(conn => {
                        const group = computeConnGroup(conn);
                        const cached = getModelsCache(conn.id) || [];
                        const okSet = okByGroup[group] || new Set();
                        const filtered = cached
                            .filter(id => okSet.has(id))
                            .filter(id => !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id));
                        setModelsCache(conn.id, filtered);
                    });
                    // Rebuild llmList strictly from filtered caches
                    rebuildLlmListFromConnections();
                    // Update selects/drawers with filtered ok models
                    if (typeof populateLlmSelect === 'function') populateLlmSelect();
                    if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                    // Mark status: Online if we had at least one OK model overall
                    const anyOk = (results || []).some(r => r.status === 'OK');
                    setLlmStatus(anyOk);
                    return results;
                } catch (e) {
                    setLlmStatus(false);
                    return [];
                }
            }

        const testLLM = async (_base, _key, connId = null) => {
                const fail = (status = 0, text = '') => ({ ok: false, status, text });
                try {
            if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return fail(0, 'Supabase proxy not configured.');
                    if (!connId) return fail(0, 'Missing server-stored connection');
                    await detectFnVariants();
                    const fnUrl = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                    const fnHeaders = await buildFnHeaders();
                    const provider = (typeof detectProvider === 'function') ? detectProvider(_base || '') : 'openai';
                    // 1) Try GET /models
                    const firstBody = (FN_VARIANTS.aiProxy === 'new')
                        ? { config_id: connId, path: 'models', method: 'GET' }
                        : { conn_id: connId, path: 'models', method: 'GET' };
                    try {
                        const r = await fetch(fnUrl + (FN_VARIANTS.aiProxy === 'new' ? '/proxy-ai-api' : '/proxy-llm'), { method: 'POST', headers: fnHeaders, body: JSON.stringify(firstBody) });
                        if (r.ok) return { ok: true, status: r.status, text: 'models ok' };
                        if (r.status === 401 || r.status === 403) {
                            const t = await r.text().catch(() => '');
                            return fail(r.status, t || 'Unauthorized');
                        }
                    } catch {}
                    // 2) Minimal chat/messages probe per provider
                    let path = 'chat/completions';
                    let body = { model: 'gpt-4o-mini', max_tokens: 1, messages: [{ role: 'user', content: 'ping' }] };
                    let hdrs = undefined;
                    if (provider === 'xai') { body = { model: 'grok-3-mini-beta', max_tokens: 1, messages: [{ role: 'user', content: 'ping' }] }; }
                    const secondBody = (FN_VARIANTS.aiProxy === 'new')
                        ? { config_id: connId, path, method: 'POST', body, headers: hdrs }
                        : { conn_id: connId, path, method: 'POST', body, headers: hdrs };
                    const r2 = await fetch(fnUrl + (FN_VARIANTS.aiProxy === 'new' ? '/proxy-ai-api' : '/proxy-llm'), { method: 'POST', headers: fnHeaders, body: JSON.stringify(secondBody) });
                    if (r2.ok) return { ok: true, status: r2.status, text: 'chat ok' };
                    const txt = await r2.text().catch(() => '');
                    if (r2.status === 400 && /model/i.test(txt)) return { ok: true, status: r2.status, text: 'auth ok (model error)' };
                    return fail(r2.status, txt);
                } catch (e) {
                    return fail(0, (e && e.message) ? e.message : 'Unknown error');
                }
            };

            const testGitHub = async (_token, connId = null) => {
                try {
                    if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return false;
                    if (!connId) return false; // require server-stored connection
                    const fnUrl = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                    const headers = await buildFnHeaders();
                    const res = await fetch(fnUrl + '/proxy-github-conn', { method: 'POST', headers, body: JSON.stringify({ conn_id: connId, path: 'user', method: 'GET' }) });
                    return res.ok;
                } catch { return false; }
            };

            const switchApiTab = (tab) => {
                ['sql','llm','git'].forEach(t => {
                    const panel = document.getElementById(`api-panel-${t}`);
                    if (panel) panel.classList.toggle('hidden', t !== tab);
                });
                apiTabBtns.forEach(btn => btn.classList.toggle('primary', btn.dataset.apiTab === tab));
                // Auto-load provider lists on tab open
                if (tab === 'llm') { try { loadAvailableModels(); } catch {} }
                if (tab === 'git') { try { loadAccessibleRepos(); } catch {} }
            };

                if (apiConsoleBtn && apiConsoleModal) {
                apiConsoleBtn.addEventListener('click', () => {
                    apiConsoleModal.classList.remove('hidden');
                    loadApiSettings();
                    switchApiTab('llm');
                    // Ensure models list reflects filtered OK models
                    try { renderLlmModelsPerConn(); } catch {}
                });
                if (closeApiConsoleBtn) closeApiConsoleBtn.addEventListener('click', () => apiConsoleModal.classList.add('hidden'));
                // Close API Console on overlay click
                apiConsoleModal.addEventListener('click', (e) => {
                    if (e.target === apiConsoleModal) apiConsoleModal.classList.add('hidden');
                });
                apiConsoleModal.addEventListener('click', (e) => { if (e.target === apiConsoleModal) apiConsoleModal.classList.add('hidden'); });

                // Tab switching
                apiTabBtns.forEach(btn => btn.addEventListener('click', () => switchApiTab(btn.dataset.apiTab)));

                

                // Removed Anthropics version wiring

                if (verifyFunctionsBtn) verifyFunctionsBtn.addEventListener('click', async () => {
                    const res = await verifyFunctions();
                    if (verifyOpenaiStatus) setStatus(verifyOpenaiStatus, res.openai);
                    if (verifyGithubStatus) setStatus(verifyGithubStatus, res.github);
                });

                // LLM test and persist
                if (llmTestBtn) llmTestBtn.addEventListener('click', async () => {
                    const base = (llmApiBaseInput.value || '').trim();
                    const key  = (llmApiKeyInput.value || '').trim();
                    if (!base || !key) { setStatus(llmTestStatus, false, '', 'Missing'); return; }
                    let result = { ok: false, status: 0, text: '' };
                    try {
                        await detectFnVariants();
                        const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                        const headersFn = await buildFnHeaders();
                        // Reuse pending if same base, else create a new temporary server config
                        if (!PENDING_LLM_CONN || PENDING_LLM_CONN.base !== base) {
                            let res;
                            const label = (() => { try { return new URL(base).hostname; } catch { return 'LLM'; } })();
                            const provider = (typeof detectProvider === 'function') ? detectProvider(base) : 'openai';
                            if (FN_VARIANTS.saveConfig === 'new') {
                                res = await fetch(baseFn + '/save-ai-api-config', { method: 'POST', headers: headersFn, body: JSON.stringify({ name: label, provider, base_url: base, api_key: key }) });
                                if (res.status === 401 || res.status === 403) {
                                    // Fallback to legacy manager when not authenticated for new endpoint
                                    res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers: headersFn, body: JSON.stringify({ type: 'llm', label, base_url: base, api_key: key, provider }) });
                                }
                            } else {
                                // Prefer your deployed connections-llm if present
                                if (FN_VARIANTS.connLlm === 'present') {
                                    res = await fetch(baseFn + '/connections-llm', { method: 'POST', headers: headersFn, body: JSON.stringify({ label, provider, base_url: base, api_key: key }) });
                                } else {
                                    res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers: headersFn, body: JSON.stringify({ type: 'llm', label, base_url: base, api_key: key, provider }) });
                                }
                            }
                            if (!res.ok) throw new Error('create-failed');
                            const { id } = await res.json();
                            PENDING_LLM_CONN = { id, base, label, server: true };
                        }
                        result = await testLLM(base, null, PENDING_LLM_CONN.id);
                    } catch (e) { result = { ok: false, status: 0, text: e && e.message ? e.message : '' }; }
                    setStatus(llmTestStatus, !!result.ok, 'OK', result.text ? String(result.text).slice(0, 64) : 'Failed');
                    // If OK, fetch models and run diagnostics immediately (without adding to saved list yet)
                    if (result.ok && PENDING_LLM_CONN) {
                        try { await fetchModelsForConn(PENDING_LLM_CONN); } catch {}
                        try { await verifyAndFilterModels(); } catch {}
                    }
                });

                // Parse curl helpers
        const parseCurl = (txt) => {
                    try {
                        if (!txt || !/curl\s/i.test(txt)) return null;
                        // Normalize quotes and whitespace
                        const s = txt.replace(/\\\n/g, ' ').replace(/\s+/g, ' ').trim();
            const urlMatch = s.match(/curl\s+([^\s\\]+)|curl\s+-X\s+\w+\s+([^\s\\]+)/i);
                        const fullUrl = (urlMatch && (urlMatch[1] || urlMatch[2])) || '';
            // Try common header forms: Authorization: Bearer <key> or x-api-key: <key>
            const authMatch = s.match(/-H\s+"?Authorization:\s*Bearer\s+([^"]+)"?| -H 'Authorization:\s*Bearer\s*([^']+)'/i);
            const xApiKeyMatch = s.match(/-H\s+"?x-api-key:\s*([^"\s]+)"?| -H 'x-api-key:\s*([^']+)'/i);
            const token = ((authMatch && (authMatch[1] || authMatch[2])) || (xApiKeyMatch && (xApiKeyMatch[1] || xApiKeyMatch[2])) || '').trim();
                        // Try to capture JSON body from -d '...'
                        let model = '';
                        try {
                            const dMatch = txt.match(/-d\s+"([\s\S]*?)"|-d\s+'([\s\S]*?)'/);
                            const bodyRaw = (dMatch && (dMatch[1] || dMatch[2])) || '';
                            if (bodyRaw) {
                                const normalized = bodyRaw.replace(/\\"/g, '"');
                                try { const obj = JSON.parse(normalized); if (obj && obj.model) model = obj.model; } catch {}
                                if (!model) {
                                    const m = normalized.match(/"model"\s*:\s*"([^"]+)"/);
                                    model = m ? m[1] : '';
                                }
                            }
                        } catch {}
                        let base = fullUrl;
                        try {
                            const u = new URL(fullUrl);
                            // strip trailing path to provider base e.g., /v1 or /v1/chat/completions -> /v1
                            const parts = u.pathname.split('/').filter(Boolean);
                            const v1Idx = parts.indexOf('v1');
                            const keep = v1Idx >= 0 ? parts.slice(0, v1Idx + 1).join('/') : parts.slice(0, 1).join('/');
                            u.pathname = '/' + keep;
                            u.search = '';
                            base = u.origin + u.pathname;
                        } catch {}
                        return { base, key: token, model };
                    } catch { return null; }
                };

                if (llmParseCurlBtn) llmParseCurlBtn.addEventListener('click', () => {
                    const res = parseCurl(llmCurlInput?.value || '');
                    if (!res || !res.base || !res.key) { setStatus(llmCurlStatus, false, '', 'Invalid curl'); return; }
                    if (llmApiBaseInput) llmApiBaseInput.value = res.base;
                    if (llmApiKeyInput) llmApiKeyInput.value = res.key;
                    setStatus(llmCurlStatus, true, 'Parsed', '');
                });

                if (llmAddCurlBtn) llmAddCurlBtn.addEventListener('click', async () => {
                    const res = parseCurl(llmCurlInput?.value || '');
                    if (!res || !res.base || !res.key) { setStatus(llmCurlStatus, false, '', 'Invalid curl'); return; }
                    // Prefill inputs for consistency and reuse existing add logic
                    if (llmApiBaseInput) llmApiBaseInput.value = res.base;
                    if (llmApiKeyInput) llmApiKeyInput.value = res.key;
                    setStatus(llmCurlStatus, true, 'Parsed', '');
                    // Trigger add using the same flow as Add LLM API button
                    try {
                        if (llmAddApiBtn) llmAddApiBtn.click();
                        // After add, attach model if present
                        if (res.model) {
                            setTimeout(() => {
                                try {
                                    const active = (typeof getActiveLlmConn === 'function') ? getActiveLlmConn() : null;
                                    if (!active) return;
                                    const cached = getModelsCache(active.id);
                                    if (!cached.includes(res.model)) {
                                        const next = [...cached, res.model].sort();
                                        setModelsCache(active.id, next);
                                        const prov = detectProvider(active.base || '');
                                        const group = `${prov === 'openai' ? 'openai' : prov} — ${getConnLabel(active)}`;
                                        llmList = llmList || {};
                                        llmList[group] = next;
                                        if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                        if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                        persistAllModelCachesToServer();
                                        if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                        if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                                    }
                                } catch {}
                            }, 400);
                        }
                    } catch {}
                });

                // GitHub test and persist
                if (githubTestBtn) githubTestBtn.addEventListener('click', async () => {
                    saveIfPresent(githubRepoInput, API_KEYS.gh_repo);
                    const token = githubTokenInput.value.trim();
                    const repo  = githubRepoInput.value.trim();
                    // Encourage server-stored connection for tests
                    let ok = false;
                    try {
                        const active = getActiveGithubConn();
                        if (active && active.server) ok = await testGitHub(null, active.id);
                        else ok = await testGitHub(token);
                    } catch { ok = false; }
                    setStatus(githubTestStatus, ok, 'OK', 'Failed');
                    // Auto-save on server if requested
                    if (ok && ghStoreServerCheckbox?.checked) {
                        try {
                            await detectFnVariants();
                            const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                            const headersFn = await buildFnHeaders();
                            const res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers: headersFn, body: JSON.stringify({ type: 'github', label: repo || 'repo', base_url: repo, api_key: token }) });
                            if (res.ok) {
                                const { id } = await res.json();
                                const list = JSON.parse(localStorage.getItem(API_KEYS.gh_multi) || '[]');
                                if (!list.some(i => i.id === id)) list.push({ id, repo, server: true });
                                localStorage.setItem(API_KEYS.gh_multi, JSON.stringify(list));
                                if (!localStorage.getItem(API_KEYS.gh_active)) localStorage.setItem(API_KEYS.gh_active, id);
                                renderGithubRepoList();
                            }
                        } catch {}
                    }
                });
            // Provider section toggle (OpenAI models list)
            const llmProviderOpenaiToggle = document.getElementById('llm-provider-openai-toggle');
            const llmProviderOpenaiCaret = document.getElementById('llm-provider-openai-caret');
            if (llmProviderOpenaiToggle) {
                llmProviderOpenaiToggle.addEventListener('click', () => {
                    const box = document.getElementById('llm-available-models');
                    if (!box) return;
                    const isHidden = box.classList.contains('hidden');
                    box.classList.toggle('hidden', !isHidden);
                    if (llmProviderOpenaiCaret) llmProviderOpenaiCaret.textContent = isHidden ? '▼' : '▶';
                    if (isHidden) loadAvailableModels();
                });
            }
            if (verifyAllBtn) verifyAllBtn.addEventListener('click', verifyAllModels);
                // LLM multi connections
                if (llmAddApiBtn) llmAddApiBtn.addEventListener('click', async () => {
                    const base = (llmApiBaseInput?.value || '').trim();
                    const key  = (llmApiKeyInput?.value || '').trim();
                    if (!base || !key) return;
                    // Proxy-only: require server storage
            if (llmStoreServerCheckbox?.checked) {
                        let savedOnServer = false;
                        if (FINAL_SUPABASE_URL && FINAL_SUPABASE_KEY) {
                            await detectFnVariants();
                            const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                            const headersFn = await buildFnHeaders();
                            // If we have a pending created by Test for this base, reuse it; else create
                            let connId = PENDING_LLM_CONN && PENDING_LLM_CONN.base === base ? PENDING_LLM_CONN.id : null;
                            if (!connId) {
                                let res;
                                const label = (() => { try { return new URL(base).hostname; } catch { return 'LLM'; } })();
                                const provider = (typeof detectProvider === 'function') ? detectProvider(base) : 'openai';
                                if (FN_VARIANTS.saveConfig === 'new') {
                                    res = await fetch(baseFn + '/save-ai-api-config', { method: 'POST', headers: headersFn, body: JSON.stringify({ name: label, provider, base_url: base, api_key: key }) });
                                    if (res.status === 401 || res.status === 403) {
                                        // Fallback when new config suite requires auth not available in this context
                                        res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers: headersFn, body: JSON.stringify({ type: 'llm', label, base_url: base, api_key: key, provider }) });
                                    } else if (!res.ok && FN_VARIANTS.connLlm === 'present') {
                                        // If new endpoint failed for other reasons but dedicated connections-llm exists, try it
                                        res = await fetch(baseFn + '/connections-llm', { method: 'POST', headers: headersFn, body: JSON.stringify({ label, provider, base_url: base, api_key: key }) });
                                    }
                                } else if (FN_VARIANTS.connLlm === 'present') {
                                    res = await fetch(baseFn + '/connections-llm', { method: 'POST', headers: headersFn, body: JSON.stringify({ label, provider, base_url: base, api_key: key }) });
                                } else {
                                    res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers: headersFn, body: JSON.stringify({ type: 'llm', label, base_url: base, api_key: key, provider }) });
                                }
                                if (!res.ok) throw new Error('create-failed');
                                const { id } = await res.json();
                                connId = id;
                                PENDING_LLM_CONN = { id: connId, base, label, server: true };
                            }
                            if (connId) {
                                const list = JSON.parse(localStorage.getItem(API_KEYS.llm_multi) || '[]');
                                const idx = list.findIndex(i => i.id === connId);
                                const entry = { id: connId, base, label: (PENDING_LLM_CONN?.label || (()=>{ try { return new URL(base).hostname; } catch { return 'LLM'; } })()), server: true };
                                if (idx >= 0) list[idx] = entry; else list.push(entry);
                                localStorage.setItem(API_KEYS.llm_multi, JSON.stringify(list));
                                localStorage.setItem(API_KEYS.llm_active, connId);
                                savedOnServer = true;
                            }
                        }
                        if (!savedOnServer) { throw new Error('Failed to save on server. Configure Supabase and try again.'); }
                        renderLlmApiList();
                        try { if (typeof loadAvailableModels === 'function') await loadAvailableModels(); } catch {}
                        try { await verifyAndFilterModels(); } catch {}
                        syncLlmListWithConnections();
                    } else { alert('Server storage is required. Please check "Store securely on server".'); }
                });

                // GitHub multi repos
                if (ghAddRepoBtn) ghAddRepoBtn.addEventListener('click', async () => {
                    const token = (githubTokenInput?.value || '').trim();
                    const repo  = (githubRepoInput?.value || '').trim();
                    if (!token || !repo) return;
                    // Proxy-only: require server storage
                    if (ghStoreServerCheckbox?.checked) {
                        if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return;
                        await detectFnVariants();
                        const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                        const headersFn = await buildFnHeaders();
                        // No save-ai-api-config for GitHub; keep connections-manager for GitHub
                        const res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers: headersFn, body: JSON.stringify({ type: 'github', label: repo, base_url: repo, api_key: token }) });
                        if (!res.ok) return;
                        const { id } = await res.json();
                        const list = JSON.parse(localStorage.getItem(API_KEYS.gh_multi) || '[]');
                        list.push({ id, repo, server: true });
                        localStorage.setItem(API_KEYS.gh_multi, JSON.stringify(list));
                        if (!localStorage.getItem(API_KEYS.gh_active)) localStorage.setItem(API_KEYS.gh_active, id);
                        renderGithubRepoList();
                    } else { alert('Server storage is required. Please check "Store securely on server".'); }
                });
            }

            function renderLlmApiList() {
                if (!llmApiListEl) return;
                const list = JSON.parse(localStorage.getItem(API_KEYS.llm_multi) || '[]');
                const activeId = localStorage.getItem(API_KEYS.llm_active);
                llmApiListEl.innerHTML = '';
                list.forEach(({ id, base, label }) => {
                    const row = document.createElement('div');
                    row.className = 'flex items-center justify-between border border-[--border-dark] rounded-md p-2';
                    const left = document.createElement('div');
                    left.className = 'text-xs';
                    left.innerHTML = `<div class=\"font-semibold\">${label || new URL(base).hostname} ${id===activeId ? '<span class=\\"ml-2 px-1 rounded border border-[--border-dark] text-[10px]\\">Active</span>' : ''}</div><div class=\"text-[--text-muted-dark]\">${base}</div>`;
                    const right = document.createElement('div');
                    right.className = 'flex items-center gap-2';
                    const testBtn = document.createElement('button');
                    testBtn.className = 'action-button text-xs';
                    testBtn.textContent = 'Test';
                    const setBtn = document.createElement('button');
                    setBtn.className = 'action-button text-xs';
                    setBtn.textContent = 'Set active';
                    const delBtn = document.createElement('button');
                    delBtn.className = 'action-button text-xs';
                    delBtn.textContent = 'Delete';
                    const status = document.createElement('span');
                    status.className = 'text-[10px] font-mono';
                    testBtn.addEventListener('click', async () => {
                        const res = await testLLM(base, null, id);
                        setStatus(status, !!res.ok, 'OK', res && res.text ? String(res.text).slice(0, 64) : 'Fail');
                    });
                    setBtn.addEventListener('click', () => {
                        localStorage.setItem(API_KEYS.llm_active, id);
                        renderLlmApiList();
                        if (typeof populateLlmSelect === 'function') populateLlmSelect();
                        // Refresh provider models into Target LLM after switching active connection
                        try { if (typeof loadAvailableModels === 'function') loadAvailableModels(); } catch {}
                        // Keep list coherence
                        syncLlmListWithConnections();
                    });
                    delBtn.addEventListener('click', async () => {
                        try {
                            if (FINAL_SUPABASE_URL && FINAL_SUPABASE_KEY) {
                                await detectFnVariants();
                                const base = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                                const headers = await buildFnHeaders();
                                if (FN_VARIANTS.deleteConfig === 'new') {
                                    await fetch(base + '/delete-ai-api-config?id=' + encodeURIComponent(id), { method: 'DELETE', headers });
                                } else {
                                    await fetch(base + '/connections-manager?id=' + encodeURIComponent(id), { method: 'DELETE', headers });
                                }
                            }
                        } catch {}
                        const cur = JSON.parse(localStorage.getItem(API_KEYS.llm_multi) || '[]');
                        localStorage.setItem(API_KEYS.llm_multi, JSON.stringify(cur.filter(i => i.id !== id)));
                        if (localStorage.getItem(API_KEYS.llm_active) === id) localStorage.removeItem(API_KEYS.llm_active);
                        renderLlmApiList();
                        if (typeof populateLlmSelect === 'function') populateLlmSelect();
                        try { if (typeof loadAvailableModels === 'function') loadAvailableModels(); } catch {}
                        syncLlmListWithConnections();
                    });
                    right.appendChild(testBtn); right.appendChild(setBtn); right.appendChild(delBtn); right.appendChild(status);
                    row.appendChild(left); row.appendChild(right);
                    llmApiListEl.appendChild(row);
                });
            }

            function renderGithubRepoList() {
                if (!ghRepoListEl) return;
                const list = JSON.parse(localStorage.getItem(API_KEYS.gh_multi) || '[]');
                const activeId = localStorage.getItem(API_KEYS.gh_active);
                ghRepoListEl.innerHTML = '';
                list.forEach(({ id, repo }) => {
                    const row = document.createElement('div');
                    row.className = 'flex items-center justify-between border border-[--border-dark] rounded-md p-2';
                    const left = document.createElement('div');
                    left.className = 'text-xs';
                    left.innerHTML = `<div class=\"font-semibold\">${repo} ${id===activeId ? '<span class=\\"ml-2 px-1 rounded border border-[--border-dark] text-[10px]\\">Active</span>' : ''}</div><div class=\"text-[--text-muted-dark]\">Token: ••••••••</div>`;
                    const right = document.createElement('div');
                    right.className = 'flex items-center gap-2';
                    const testBtn = document.createElement('button');
                    testBtn.className = 'action-button text-xs';
                    testBtn.textContent = 'Test';
                    const setBtn = document.createElement('button');
                    setBtn.className = 'action-button text-xs';
                    setBtn.textContent = 'Set active';
                    const delBtn = document.createElement('button');
                    delBtn.className = 'action-button text-xs';
                    delBtn.textContent = 'Delete';
                    const status = document.createElement('span');
                    status.className = 'text-[10px] font-mono';
                    testBtn.addEventListener('click', async () => {
                        const entry = (JSON.parse(localStorage.getItem(API_KEYS.gh_multi) || '[]').find(i => i.id === id) || {});
                        const ok = entry.server ? await testGitHub(null, id) : false;
                        setStatus(status, ok, 'OK', 'Fail');
                    });
                    setBtn.addEventListener('click', () => {
                        localStorage.setItem(API_KEYS.gh_active, id);
                        renderGithubRepoList();
                    });
                    delBtn.addEventListener('click', async () => {
                        try {
                            if (FINAL_SUPABASE_URL && FINAL_SUPABASE_KEY) {
                                const url = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1/connections-manager?id=' + encodeURIComponent(id);
                                const headers = await buildFnHeaders();
                                await fetch(url, { method: 'DELETE', headers });
                            }
                        } catch {}
                        const cur = JSON.parse(localStorage.getItem(API_KEYS.gh_multi) || '[]');
                        localStorage.setItem(API_KEYS.gh_multi, JSON.stringify(cur.filter(i => i.id !== id)));
                        if (localStorage.getItem(API_KEYS.gh_active) === id) localStorage.removeItem(API_KEYS.gh_active);
                        renderGithubRepoList();
                    });
                    right.appendChild(testBtn); right.appendChild(setBtn); right.appendChild(delBtn); right.appendChild(status);
                    row.appendChild(left); row.appendChild(right);
                    ghRepoListEl.appendChild(row);
                });
            }

            // ===== Provider-backed lists (per-connection) =====
            const getLlmConnections = () => JSON.parse(localStorage.getItem(API_KEYS.llm_multi) || '[]');
            const getConnLabel = (conn) => {
                try { return conn.label || (conn.base ? new URL(conn.base).hostname : 'LLM'); } catch { return conn.label || 'LLM'; }
            };
            const detectProvider = (base) => {
                try {
                    const host = new URL(base).hostname.toLowerCase();
                    if (host.includes('openai')) return 'openai';
                    if (host.includes('x.ai') || host.includes('xai')) return 'xai';
                    if (host.includes('anthropic')) return 'anthropic';
                    if (host.includes('deepseek')) return 'deepseek';
                    if (host.includes('openrouter')) return 'openrouter';
                    return 'openai';
                } catch { return 'openai'; }
            };
            // Central model capability registry and sanitizer
            const MODEL_CAPS = [
                // OpenAI: image and specialized modalities – not supported by text Run
                { provider: 'openai', match: /^(dall-e-|gpt-image-1)/i, unsupportedReason: 'image_generation' },
                { provider: 'openai', match: /(realtime|transcribe|tts|audio-preview|whisper|video)/i, unsupportedReason: 'specialized_api' },
                // OpenAI: reasoning/new families – prefer Responses API, drop sampling params
                { provider: 'openai', match: /^o1/i, preferEndpoint: 'responses', drop: ['temperature','top_p','presence_penalty','frequency_penalty','seed','response_format','stop'] },
                { provider: 'openai', match: /^gpt-5/i, preferEndpoint: 'responses', drop: ['temperature','top_p','presence_penalty','frequency_penalty','seed','response_format','stop'] },
                // OpenAI: embeddings
                { provider: 'openai', match: /(embedding|^text-embedding-)/i, preferEndpoint: 'embeddings', allowed: ['model','input','encoding_format','dimensions','user'] },
                // OpenAI: deep research requires at least one tool
                { provider: 'openai', match: /deep-research/i, allowed: ['model','messages','tools','max_tokens','temperature','top_p','stop','presence_penalty','frequency_penalty','seed','response_format','stream'], ensureTools: 'web_search_preview' },
                // x.ai: image-only model not supported by text Run
                { provider: 'xai', match: /^grok-2-image-/i, unsupportedReason: 'image_generation' },
                // x.ai: be conservative – allow core sampling knobs only
                { provider: 'xai', match: /^grok-/i, allowed: ['model','messages','max_tokens','temperature','top_p','stop','stream'] },
                // Anthropic handled by provider rules below; no per-model overrides yet
            ];
            function getModelCaps(provider, model) {
                try {
                    const hit = MODEL_CAPS.find(r => r.provider === provider && r.match.test(model || ''));
                    return hit || { provider };
                } catch { return { provider }; }
            }
            function sanitizeRequestForModel({ body, provider, model }) {
                const caps = getModelCaps(provider, model);
                const out = { ...body };
                // Provider-level defaults
                if (provider === 'anthropic') {
                    // Anthropic doesn't support OpenAI penalties/seed/response_format
                    ['presence_penalty','frequency_penalty','seed','response_format'].forEach(k => { if (k in out) delete out[k]; });
                    // Translate stop -> stop_sequences
                    if (Array.isArray(out.stop) && out.stop.length) {
                        out.stop_sequences = out.stop;
                        delete out.stop;
                    }
                } else if (provider === 'xai') {
                    // Be conservative for x.ai by default
                    const allowed = (caps && caps.allowed) || ['model','messages','max_tokens','temperature','top_p','stop','stream'];
                    Object.keys(out).forEach(k => { if (!allowed.includes(k)) delete out[k]; });
                } else if (provider === 'openai') {
                    // Default OpenAI chat-compatible knobs; may be narrowed by caps
                    // Include embeddings/responses specific knobs to avoid stripping when we later switch endpoint
                    const defaultAllowed = ['model','messages','max_tokens','temperature','top_p','stop','presence_penalty','frequency_penalty','seed','response_format','stream','input','dimensions','encoding_format','user','max_output_tokens'];
                    let allowed = defaultAllowed;
                    if (caps && Array.isArray(caps.allowed)) allowed = caps.allowed;
                    if (caps && Array.isArray(caps.drop)) caps.drop.forEach(k => { if (k in out) delete out[k]; });
                    Object.keys(out).forEach(k => { if (!allowed.includes(k)) delete out[k]; });
                }
                return { body: out, preferEndpoint: caps.preferEndpoint, unsupportedReason: caps.unsupportedReason, ensureTools: caps.ensureTools };
            }
            const modelsCacheKey = (id) => `llm_models_cache_${id}`;
            const getModelsCache = (id) => { try { return JSON.parse(localStorage.getItem(modelsCacheKey(id)) || '[]'); } catch { return []; } };
            const setModelsCache = (id, ids) => { try { localStorage.setItem(modelsCacheKey(id), JSON.stringify(ids || [])); } catch {} };

            // Persist all per-connection model caches to DB (global_lists: 'llm_models_cache')
            async function persistAllModelCachesToServer() {
                try {
                    if (!supabaseClient || typeof updateGlobalList !== 'function') return;
                    const conns = getLlmConnections();
                    const map = {};
                    conns.forEach(c => { map[c.id] = getModelsCache(c.id) || []; });
                    await updateGlobalList('llm_models_cache', map);
                } catch {}
            }

            const computeConnGroup = (conn) => {
                try {
                    const prov = detectProvider(conn?.base || '');
                    return `${prov === 'openai' ? 'openai' : prov} — ${getConnLabel(conn)}`;
                } catch { return getConnLabel(conn) || 'LLM'; }
            };
            function syncLlmListWithConnections() {
                try {
                    const conns = getLlmConnections();
                    const allowed = new Set(conns.map(c => computeConnGroup(c)));
                    const next = {};
                    Object.keys(llmList || {}).forEach(g => { if (allowed.has(g)) next[g] = llmList[g]; });
                    llmList = next;
                    if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                    if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                    if (typeof populateLlmSelect === 'function') populateLlmSelect();
                    if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                } catch {}
            }
            function rebuildLlmListFromConnections() {
                try {
                    const conns = getLlmConnections();
                    const next = {};
                    conns.forEach(conn => {
                        const ids = (getModelsCache(conn.id) || []).filter(id => {
                            const prov = detectProvider(conn.base || '');
                            const caps = getModelCaps(prov, id);
                            if (caps.unsupportedReason) return false;
                            return !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id);
                        });
                        if (ids.length) next[computeConnGroup(conn)] = Array.from(new Set(ids)).sort();
                    });
                    llmList = next;
                    if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                    if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                    if (typeof populateLlmSelect === 'function') populateLlmSelect();
                    if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                } catch {}
            }

            async function fetchModelsForConn(conn) {
                try {
                    if (!conn) throw new Error('no connection');
                    let items = [];
                    if (conn.server) {
                        if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) throw new Error('proxy not configured');
                        await detectFnVariants();
                        const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                        const headersFn = await buildFnHeaders();
                        let res;
                        if (FN_VARIANTS.aiProxy === 'new') {
                            res = await fetch(baseFn + '/proxy-ai-api', { method: 'POST', headers: headersFn, body: JSON.stringify({ config_id: conn.id, path: 'models', method: 'GET' }) });
                        } else {
                            res = await fetch(baseFn + '/proxy-llm', { method: 'POST', headers: headersFn, body: JSON.stringify({ conn_id: conn.id, path: 'models', method: 'GET' }) });
                        }
                        if (!res.ok) throw new Error('models request failed');
                        const data = await res.json();
                        items = (data.data || data.models || data) || [];
                    } else {
                        throw new Error('Local LLM connections are not allowed. Please store this connection on server.');
                    }
                    const ids = Array.from(new Set(items
                        .map(m => m.id || m.name || m.model)
                        .filter(Boolean)
                        .filter(id => {
                            const prov = detectProvider(conn.base || '');
                            const caps = getModelCaps(prov, id);
                            if (caps.unsupportedReason) return false;
                            return !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id);
                        })
                    )).sort();
                    setModelsCache(conn.id, ids);
                    persistAllModelCachesToServer();
                    // Merge into llmList under this connection's label
                    try {
                        const prov = detectProvider(conn.base || '');
                        const label = `${prov === 'openai' ? 'openai' : prov} — ${getConnLabel(conn)}`;
                        llmList = llmList || {};
                        llmList[label] = ids;
                        if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                        if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                        if (typeof populateLlmSelect === 'function') populateLlmSelect();
                        if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                        // prune any stray groups not tied to current connections
                        syncLlmListWithConnections();
                    } catch {}
                    return ids;
                } catch (e) {
                    // Provider-specific fallback: some providers (e.g., x.ai) may not expose /models
                    try {
                        const prov = detectProvider(conn?.base || '');
                        if (prov === 'xai') {
                            const ids = [
                                'grok-3-beta',
                                'grok-3-fast-beta',
                                'grok-3-mini-beta',
                                'grok-3-mini-fast-beta',
                                'grok-2-image-1212',
                                'grok-2-1212',
                                'grok-2-vision-1212'
                            ];
                            setModelsCache(conn.id, ids);
                            persistAllModelCachesToServer();
                            try {
                                const label = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[label] = ids;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            // keep lists coherent
                            syncLlmListWithConnections();
                            return ids;
                        }
                    } catch {}
                    throw e;
                }
            }

            function renderLlmModelsPerConn() {
                if (!llmAvailableModelsEl) return;
                const list = getLlmConnections();
                // Build grouped toggles per connection
                llmAvailableModelsEl.innerHTML = '';
                if (!list.length) {
                    llmAvailableModelsEl.innerHTML = '<div class="text-[--text-muted-dark]">No connections yet. Add an LLM API above.</div>';
                    return;
                }
                list.forEach((conn) => {
                    const prov = detectProvider(conn.base || '');
                    const label = getConnLabel(conn);
                    const header = document.createElement('div');
                    header.className = 'prompt-group-header flex items-center gap-2';
                    header.innerHTML = `<span class="toggle-icon">▶</span><span class="text-xs font-semibold text-[--text-muted-dark]">${label}</span>`;
                    const wrap = document.createElement('div');
                    wrap.className = 'pl-2 mt-1 hidden';
                    const actions = document.createElement('div');
                    actions.className = 'flex items-center justify-between mb-1 gap-2';
                    const left = document.createElement('div');
                    left.className = 'text-[10px] text-[--text-muted-dark] font-mono truncate';
                    left.textContent = conn.base || '';
                    const right = document.createElement('div');
                    right.className = 'flex items-center gap-2';
                    const loadBtn = document.createElement('button');
                    loadBtn.className = 'action-button text-xs';
                    loadBtn.textContent = 'Load models';
                    right.appendChild(loadBtn);
                    if (prov === 'xai') {
                        const autoBtn = document.createElement('button');
                        autoBtn.className = 'action-button text-xs';
                        autoBtn.textContent = 'Auto-import';
                        autoBtn.title = 'Add known x.ai models to this connection';
                        right.appendChild(autoBtn);
                        autoBtn.addEventListener('click', () => {
                            const known = [
                                'grok-3-beta',
                                'grok-3-fast-beta',
                                'grok-3-mini-beta',
                                'grok-3-mini-fast-beta',
                                'grok-2-image-1212',
                                'grok-2-1212',
                                'grok-2-vision-1212'
                            ];
                            const cached = getModelsCache(conn.id);
                            const next = Array.from(new Set([...(cached||[]), ...known]))
                                .filter(id => {
                                    const caps = getModelCaps('xai', id);
                                    if (caps.unsupportedReason) return false;
                                    return !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id);
                                })
                                .sort();
                            setModelsCache(conn.id, next);
                            persistAllModelCachesToServer();
                            try {
                                const group = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[group] = next;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            renderBody();
                        });
                    }
                    actions.appendChild(left);
                    actions.appendChild(right);
                    const body = document.createElement('div');
                    body.className = 'space-y-1 text-xs';
                    const controls = document.createElement('div');
                    controls.className = 'flex items-center gap-2 mt-1 flex-wrap';
                    const addInput = document.createElement('input');
                    addInput.placeholder = 'Add model id (e.g., gpt-4o-mini or grok-3-mini-beta)';
                    addInput.className = 'form-control compact-field rounded-md text-xs flex-1';
                    const addBtn = document.createElement('button');
                    addBtn.className = 'action-button text-xs';
                    addBtn.textContent = 'Add model';
                    const bulkInput = document.createElement('textarea');
                    bulkInput.rows = 3;
                    bulkInput.placeholder = 'Bulk add: paste JSON { "data": [{"id": "..."}], "object": "list" } or comma/space-separated ids';
                    bulkInput.className = 'form-control rounded-md text-xs flex-1';
                    const bulkBtn = document.createElement('button');
                    bulkBtn.className = 'action-button text-xs';
                    bulkBtn.textContent = 'Bulk add';
                    const status = document.createElement('span');
                    status.className = 'text-[10px] font-mono';
                    controls.appendChild(addInput); controls.appendChild(addBtn);
                    controls.appendChild(bulkInput); controls.appendChild(bulkBtn);
                    controls.appendChild(status);
                    const renderBody = (state) => {
                        const cached = getModelsCache(conn.id);
                        if (state === 'loading') { body.innerHTML = '<div class="text-[--text-muted-dark]">Loading…</div>'; return; }
                        if (!cached.length) {
                            const hint = prov === 'xai' ? ' Tip: for x.ai, try model id "grok-3-mini-beta".' : '';
                            body.innerHTML = `<div class="text-[--text-muted-dark]">No models cached. Click "Load models" or add a model id manually.${hint}</div>`;
                            return;
                        }
                        body.innerHTML = '';
                        cached.forEach(id => {
                            const row = document.createElement('div');
                            row.className = 'drawer-row';
                            row.innerHTML = `<div class="truncate"><span class="font-mono">${id}</span></div>`;
                            body.appendChild(row);
                        });
                    };
                    renderBody();
                    loadBtn.addEventListener('click', async () => {
                        renderBody('loading');
                        try { await fetchModelsForConn(conn); setStatus(status, true, 'OK', ''); } catch { body.innerHTML = '<div class="text-[--accent-red]">Failed to load models</div>'; setStatus(status, false, '', 'Fail'); return; }
                        renderBody();
                    });
                    addBtn.addEventListener('click', () => {
                        const id = (addInput.value || '').trim();
                        if (!id) return;
                        const cached = getModelsCache(conn.id);
                        if (!cached.includes(id)) {
                            if (/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id)) { addInput.value = ''; return; }
                            const next = [...cached, id].filter(x => !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(x)).sort();
                            setModelsCache(conn.id, next);
                            persistAllModelCachesToServer();
                            // update llmList grouping
                            try {
                                const prov = detectProvider(conn.base || '');
                                const group = `${prov === 'openai' ? 'openai' : prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[group] = next;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                        }
                        addInput.value = '';
                        renderBody();
                    });
                    bulkBtn.addEventListener('click', () => {
                        const raw = (bulkInput.value || '').trim();
                        if (!raw) return;
                        let ids = [];
                        // Try JSON first
                        try {
                            const obj = JSON.parse(raw);
                            const arr = (obj && (obj.data || obj.models || [])) || [];
                            ids = Array.from(new Set(arr.map(m => m.id || m.name || m.model).filter(Boolean)));
                        } catch {
                            // Fallback to delimiter-based parsing
                            ids = Array.from(new Set(raw.split(/[\s,]+/).map(s => s.trim()).filter(Boolean)));
                        }
                        if (!ids.length) return;
                        const cached = getModelsCache(conn.id);
                        const next = Array.from(new Set([...(cached||[]), ...ids]))
                            .filter(id => !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id))
                            .sort();
                        setModelsCache(conn.id, next);
                        persistAllModelCachesToServer();
                        try {
                            const prov = detectProvider(conn.base || '');
                            const group = `${prov === 'openai' ? 'openai' : prov} — ${getConnLabel(conn)}`;
                            llmList = llmList || {};
                            llmList[group] = next;
                            if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                            if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                            if (typeof populateLlmSelect === 'function') populateLlmSelect();
                            if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                        } catch {}
                        bulkInput.value = '';
                        renderBody();
                    });
                    let expanded = false;
                    header.addEventListener('click', () => {
                        expanded = !expanded;
                        header.querySelector('.toggle-icon').textContent = expanded ? '▼' : '▶';
                        header.classList.toggle('expanded', expanded);
                        wrap.classList.toggle('hidden', !expanded);
                    });
                    wrap.appendChild(actions);
                    wrap.appendChild(body);
                    wrap.appendChild(controls);
                    llmAvailableModelsEl.appendChild(header);
                    llmAvailableModelsEl.appendChild(wrap);
                });
            }

            async function loadAvailableModels() {
                // Backward-compat: fetch models for the active connection and then render groups
                try {
                    const active = (typeof getActiveLlmConn === 'function') ? getActiveLlmConn() : null;
                    if (active) await fetchModelsForConn(active);
                } catch {}
                renderLlmModelsPerConn();
            }

            async function loadAccessibleRepos(targetEl) {
                // Load into the provided container (API Console or Dock mirror)
                const target = targetEl || ghAvailableReposEl || dockGhAvailableReposEl;
                if (!target) return;
                target.innerHTML = '<div class="text-[--text-muted-dark]">Loading…</div>';
                try {
                    // Prefer listing both personal and org repos via REST
                    const res = await githubRequest('user/repos?per_page=100', { method: 'GET' });
                    if (!res.ok) throw new Error('repos request failed');
                    const repos = await res.json();
                    target.innerHTML = '';
                    // Group by owner/org prefix before '/'
                    const byOwner = {};
                    (repos || []).forEach(r => {
                        const full = r.full_name || `${r.owner?.login || ''}/${r.name}`;
                        const owner = full.split('/')[0] || 'unknown';
                        if (!byOwner[owner]) byOwner[owner] = [];
                        byOwner[owner].push({ id: String(r.id || full), full, name: r.name || full.split('/')[1] || full, isPrivate: !!r.private });
                    });
            Object.keys(byOwner).sort().forEach(owner => {
                        const header = document.createElement('div');
                        header.className = 'prompt-group-header flex items-center gap-2';
                        header.innerHTML = `<span class="toggle-icon">▶</span><span class="text-xs font-semibold text-[--text-muted-dark]">${owner}</span>`;
                        const list = document.createElement('div');
                        list.className = 'space-y-1 pl-2 mt-1 hidden';
                        let expanded = false;
                        header.addEventListener('click', () => {
                            expanded = !expanded;
                            header.querySelector('.toggle-icon').textContent = expanded ? '▼' : '▶';
                header.classList.toggle('expanded', expanded);
                            list.classList.toggle('hidden', !expanded);
                        });
                        (byOwner[owner] || []).sort((a,b) => a.full.localeCompare(b.full)).forEach(({ id, full, name, isPrivate }) => {
                            const row = document.createElement('div');
                            row.className = 'drawer-row';
                            // caret icon inline with name
                            row.innerHTML = `<div class="truncate flex items-center gap-2"><span class="toggle-icon">▶</span><span class="font-mono">${name}</span>${isPrivate ? ' <span class=\"text-[--text-muted-dark]\">(private)</span>' : ''}</div>`;
                            row.dataset.repoId = id;
                            row.dataset.repoFull = full;
                            // Visual caret toggle on click
                            row.addEventListener('click', () => {
                                const icon = row.querySelector('.toggle-icon');
                                if (icon) icon.textContent = icon.textContent === '▶' ? '▼' : '▶';
                                try {
                                    // Assign selection to current prompt-level repo
                                    currentGithubRepo = { id, full };
                                    // Visually mark selected within this list
                                    target.querySelectorAll('.drawer-row').forEach(r => r.classList.remove('selected'));
                                    row.classList.add('selected');
                                } catch {}
                            });
                            list.appendChild(row);
                        });
                        target.appendChild(header);
                        target.appendChild(list);
                    });
                    if (!Object.keys(byOwner).length) target.innerHTML = '<div class="text-[--text-muted-dark]">No repositories found.</div>';
                } catch (e) {
                    target.innerHTML = '<div class="text-[--accent-red]">Failed to load repos</div>';
                }
            }

            async function loadRepoFolders() {
                if (!ghRepoFoldersEl) return;
                ghRepoFoldersEl.innerHTML = '<div class="text-[--text-muted-dark]">Loading…</div>';
                try {
                    const conn = (typeof getActiveGithubConn === 'function') ? getActiveGithubConn() : null;
                    const repo = conn?.repo;
                    if (!repo) throw new Error('No active repo');
                    // List root-level contents as folders/files
                    const res = await githubRequest(`repos/${repo}/contents/`, { method: 'GET' });
                    if (!res.ok) throw new Error('contents request failed');
                    const items = await res.json();
                    ghRepoFoldersEl.innerHTML = '';
                    // Show directories first, then files
                    const dirs = (items || []).filter(it => it.type === 'dir');
                    const files = (items || []).filter(it => it.type !== 'dir');
                    const ordered = [...dirs, ...files];
                    ordered.forEach((it) => {
                        const isDir = it.type === 'dir';
                        const row = document.createElement('div');
                        row.className = 'drawer-row';
                        row.innerHTML = `<div class="truncate"><span class="font-mono">${it.path}</span>${isDir? ' <span class=\"text-[--text-muted-dark]\">(dir)</span>':''}</div>`;
                        ghRepoFoldersEl.appendChild(row);
                    });
                    if (!items || !items.length) ghRepoFoldersEl.innerHTML = '<div class="text-[--text-muted-dark]">No items found.</div>';
                } catch (e) {
                    ghRepoFoldersEl.innerHTML = '<div class="text-[--accent-red]">Failed to load folders</div>';
                }
            }

            if (llmLoadModelsBtn) llmLoadModelsBtn.addEventListener('click', loadAvailableModels);
            if (llmRebuildListBtn) llmRebuildListBtn.addEventListener('click', async () => {
                try {
                    if (supabaseClient) {
                        const { data: listsData } = await supabaseClient.from('global_lists').select('*');
                        const cacheMap = listsData?.find(l => l.name === 'llm_models_cache')?.data || {};
                        Object.entries(cacheMap).forEach(([connId, ids]) => {
                            try { localStorage.setItem(modelsCacheKey(connId), JSON.stringify(ids || [])); } catch {}
                        });
                    }
                } catch {}
                rebuildLlmListFromConnections();
            });
            if (ghLoadReposBtn) ghLoadReposBtn.addEventListener('click', () => loadAccessibleRepos(ghAvailableReposEl));
            if (ghReposToggle) ghReposToggle.addEventListener('click', () => {
                const box = document.getElementById('github-available-repos');
                if (!box) return;
                const isHidden = box.classList.contains('hidden');
                box.classList.toggle('hidden', !isHidden);
                if (ghReposCaret) ghReposCaret.textContent = isHidden ? '▼' : '▶';
                if (isHidden) loadAccessibleRepos(ghAvailableReposEl);
            });
            if (dockGhLoadReposBtn) dockGhLoadReposBtn.addEventListener('click', () => loadAccessibleRepos(dockGhAvailableReposEl));
            if (dockGhReposToggle) dockGhReposToggle.addEventListener('click', () => {
                const box = document.getElementById('dock-github-available-repos');
                if (!box) return;
                const isHidden = box.classList.contains('hidden');
                box.classList.toggle('hidden', !isHidden);
                if (dockGhReposCaret) dockGhReposCaret.textContent = isHidden ? '▼' : '▶';
                if (isHidden) loadAccessibleRepos(dockGhAvailableReposEl);
            });
            if (ghLoadFoldersBtn) ghLoadFoldersBtn.addEventListener('click', loadRepoFolders);
            if (ghRepoFoldersToggle) ghRepoFoldersToggle.addEventListener('click', () => {
                const box = document.getElementById('github-repo-folders');
                if (!box) return;
                const isHidden = box.classList.contains('hidden');
                box.classList.toggle('hidden', !isHidden);
                if (ghRepoFoldersCaret) ghRepoFoldersCaret.textContent = isHidden ? '▼' : '▶';
                if (isHidden) loadRepoFolders();
            });

            // --- IMPORT LOGIC ---
            const openImportModal = () => {
                // populate LLM select from existing llmList
                importLlmSelect.innerHTML = '<option value="generic">Unspecified</option>';
                Object.keys(llmList).sort().forEach(groupName => {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = groupName;
                    (llmList[groupName] || []).sort().forEach(llm => {
                        const option = document.createElement('option');
                        option.value = llm;
                        option.textContent = llm;
                        optgroup.appendChild(option);
                    });
                    importLlmSelect.appendChild(optgroup);
                });
                // Default name from filename (without extension)
                const base = pendingImportFilename ? pendingImportFilename.replace(/\.[^.]+$/, '') : '';
                importPromptNameInput.value = base;
                importProjectInput.value = '';
                // Default LLM to current editor selection if not 'generic'
                try {
                    if (llmSelect && llmSelect.value && llmSelect.value !== 'generic') {
                        importLlmSelect.value = llmSelect.value;
                    }
                } catch {}
                importModal.classList.remove('hidden');
                importPromptNameInput.focus();
            };
            const closeImportModal = () => {
                importModal.classList.add('hidden');
            };
            const readFileAsArrayBuffer = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
            const readFileAsText = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
            const extractTextFromPdf = async (arrayBuffer) => {
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let text = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    const strings = content.items.map(item => item.str);
                    text += strings.join(' ') + '\n\n';
                }
                return text.trim();
            };
            const extractTextFromDocx = async (arrayBuffer) => {
                const { value } = await window.mammoth.extractRawText({ arrayBuffer });
                return (value || '').trim();
            };
            
            // --- Import from Git helpers ---
            let gitSelectedRepoFull = '';
            let gitSelectedFile = null;
            let gitFilesCache = [];

            const openImportGitModal = async () => {
                gitSelectedRepoFull = (currentGithubRepo && currentGithubRepo.full) || '';
                gitSelectedFile = null;
                gitFilesCache = [];
                if (gitBrowserRepos) gitBrowserRepos.innerHTML = '<div class="text-[--text-muted-dark]">Loading repos…</div>';
                if (gitBrowserFiles) gitBrowserFiles.innerHTML = '<div class="text-[--text-muted-dark]">Select a repository to list Markdown files.</div>';
                if (gitImportConfirmBtn) gitImportConfirmBtn.disabled = true;
                if (importGitModal) importGitModal.classList.remove('hidden');
                await renderGitReposList();
                if (gitSelectedRepoFull) {
                    await listMarkdownFilesForRepo(gitSelectedRepoFull);
                }
            };

            const closeImportGitModal = () => {
                if (importGitModal) importGitModal.classList.add('hidden');
            };

            async function renderGitReposList() {
                if (!gitBrowserRepos) return;
                try {
                    gitBrowserRepos.innerHTML = '<div class="text-[--text-muted-dark]">Loading…</div>';
                    const res = await githubRequest('user/repos?per_page=100', { method: 'GET' });
                    if (!res.ok) throw new Error('repos request failed');
                    const repos = await res.json();
                    const byOwner = {};
                    (repos || []).forEach(r => {
                        const full = r.full_name || `${r.owner?.login || ''}/${r.name}`;
                        const owner = full.split('/')[0] || 'unknown';
                        if (!byOwner[owner]) byOwner[owner] = [];
                        byOwner[owner].push({ full, name: r.name || full.split('/')[1] || full });
                    });
                    gitBrowserRepos.innerHTML = '';
                    Object.keys(byOwner).sort().forEach(owner => {
                        const header = document.createElement('div');
                        header.className = 'prompt-group-header flex items-center gap-2';
                        header.innerHTML = `<span class="toggle-icon">▶</span><span class="text-xs font-semibold text-[--text-muted-dark]">${owner}</span>`;
                        const list = document.createElement('div');
                        list.className = 'space-y-1 pl-2 mt-1 hidden';
                        let expanded = owner === (gitSelectedRepoFull?.split('/')[0] || '');
                        header.addEventListener('click', () => {
                            expanded = !expanded;
                            header.querySelector('.toggle-icon').textContent = expanded ? '▼' : '▶';
                            header.classList.toggle('expanded', expanded);
                            list.classList.toggle('hidden', !expanded);
                        });
                        if (expanded) {
                            header.querySelector('.toggle-icon').textContent = '▼';
                            list.classList.remove('hidden');
                        }
                        (byOwner[owner] || []).sort((a,b) => a.full.localeCompare(b.full)).forEach(({ full, name }) => {
                            const row = document.createElement('div');
                            row.className = 'drawer-row';
                            row.innerHTML = `<div class=\"truncate flex items-center gap-2\"><span class=\"toggle-icon ${full===gitSelectedRepoFull?'opacity-100':'opacity-40'}\">●</span><span class=\"font-mono\">${name}</span></div>`;
                            row.addEventListener('click', async () => {
                                gitSelectedRepoFull = full;
                                gitSelectedFile = null;
                                if (gitImportConfirmBtn) gitImportConfirmBtn.disabled = true;
                                gitBrowserRepos.querySelectorAll('.drawer-row').forEach(r => r.classList.remove('selected'));
                                row.classList.add('selected');
                                await listMarkdownFilesForRepo(full);
                            });
                            if (full === gitSelectedRepoFull) row.classList.add('selected');
                            list.appendChild(row);
                        });
                        gitBrowserRepos.appendChild(header);
                        gitBrowserRepos.appendChild(list);
                    });
                    if (!Object.keys(byOwner).length) gitBrowserRepos.innerHTML = '<div class="text-[--text-muted-dark]">No repositories found.</div>';
                } catch (e) {
                    console.error(e);
                    gitBrowserRepos.innerHTML = '<div class="text-[--accent-red]">Failed to load repos</div>';
                }
            }

            async function listMarkdownFilesForRepo(repoFull) {
                if (!gitBrowserFiles) return;
                gitBrowserFiles.innerHTML = '<div class="text-[--text-muted-dark]">Scanning repository…</div>';
                gitFilesCache = [];
                try {
                    // Get default branch
                    const repoRes = await githubRequest(`repos/${repoFull}`, { method: 'GET' });
                    if (!repoRes.ok) throw new Error('repo request failed');
                    const repoInfo = await repoRes.json();
                    const defaultBranch = repoInfo.default_branch || 'main';
                    // Get ref to obtain commit sha
                    const refRes = await githubRequest(`repos/${repoFull}/git/refs/heads/${defaultBranch}`, { method: 'GET' });
                    if (!refRes.ok) throw new Error('ref request failed');
                    const refInfo = await refRes.json();
                    const commitSha = refInfo && (Array.isArray(refInfo) ? refInfo[0]?.object?.sha : refInfo.object?.sha);
                    if (!commitSha) throw new Error('no commit sha');
                    const commitRes = await githubRequest(`repos/${repoFull}/git/commits/${commitSha}`, { method: 'GET' });
                    if (!commitRes.ok) throw new Error('commit request failed');
                    const commitInfo = await commitRes.json();
                    const treeSha = commitInfo?.tree?.sha;
                    if (!treeSha) throw new Error('no tree sha');
                    const treeRes = await githubRequest(`repos/${repoFull}/git/trees/${treeSha}?recursive=1`, { method: 'GET' });
                    if (!treeRes.ok) throw new Error('tree request failed');
                    const tree = await treeRes.json();
                    const all = (tree.tree || []).filter(it => it.type === 'blob' && /\.md$/i.test(it.path || ''));
                    gitFilesCache = all.map(f => ({ path: f.path }));
                    renderGitFilesList();
                } catch (e) {
                    console.error(e);
                    gitBrowserFiles.innerHTML = '<div class="text-[--accent-red]">Failed to scan repository</div>';
                }
            }

            function renderGitFilesList() {
                if (!gitBrowserFiles) return;
                const filter = (gitFilesFilterInput?.value || '').toLowerCase();
                const filtered = gitFilesCache.filter(f => !filter || f.path.toLowerCase().includes(filter));
                if (!filtered.length) {
                    gitBrowserFiles.innerHTML = '<div class="text-[--text-muted-dark]">No markdown files found.</div>';
                    return;
                }
                gitBrowserFiles.innerHTML = '';
                filtered.forEach(({ path }) => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.innerHTML = `<div class="truncate font-mono">${path}</div>`;
                    row.addEventListener('click', () => {
                        gitSelectedFile = path;
                        if (gitImportConfirmBtn) gitImportConfirmBtn.disabled = false;
                        gitBrowserFiles.querySelectorAll('.drawer-row').forEach(r => r.classList.remove('selected'));
                        row.classList.add('selected');
                        const base = path.split('/').pop().replace(/\.[^.]+$/, '');
                        if (gitImportTitleInput && !gitImportTitleInput.value) gitImportTitleInput.value = base;
                    });
                    gitBrowserFiles.appendChild(row);
                });
            }

            async function fetchMarkdownFile(repoFull, filePath) {
                const res = await githubRequest(`repos/${repoFull}/contents/${encodeURIComponent(filePath)}`, { method: 'GET' });
                if (!res.ok) throw new Error('file request failed');
                const json = await res.json();
                const b64 = (json.content || '').replace(/\n/g, '');
                return decodeBase64Utf8(b64);
            }

            function decodeBase64Utf8(b64) {
                try {
                    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
                    const decoder = new TextDecoder('utf-8');
                    return decoder.decode(bytes);
                } catch (e) {
                    try { return atob(b64); } catch { return ''; }
                }
            }
            const handleImportFile = async (file) => {
                const name = file.name.toLowerCase();
                pendingImportFilename = file.name;
                try {
                    if (name.endsWith('.txt') || name.endsWith('.md')) {
                        pendingImportedText = await readFileAsText(file);
                    } else if (name.endsWith('.pdf')) {
                        const ab = await readFileAsArrayBuffer(file);
                        pendingImportedText = await extractTextFromPdf(ab);
                    } else if (name.endsWith('.docx')) {
                        const ab = await readFileAsArrayBuffer(file);
                        pendingImportedText = await extractTextFromDocx(ab);
                    } else if (name.endsWith('.doc')) {
                        pendingImportedText = '';
                        showModal('Unsupported file', 'Please convert .doc to .docx and try again.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                        return;
                    } else {
                        pendingImportedText = '';
                        showModal('Unsupported file', 'Supported formats: .txt, .md, .pdf, .docx', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                        return;
                    }
                    openImportModal();
                } catch (e) {
                    console.error('Import error:', e);
                    showModal('Import failed', 'Could not read this file. Please try another.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                }
            };
            if (importBtn && importFileInput) {
                importBtn.addEventListener('click', () => importFileInput.click());
                importFileInput.addEventListener('change', () => {
                    const file = importFileInput.files?.[0];
                    if (file) handleImportFile(file);
                    importFileInput.value = '';
                });
            }
            if (importFromGitBtn) {
                importFromGitBtn.addEventListener('click', () => openImportGitModal());
            }
            if (closeImportGitModalBtn) closeImportGitModalBtn.addEventListener('click', closeImportGitModal);
            if (gitImportCancelBtn) gitImportCancelBtn.addEventListener('click', closeImportGitModal);
            if (gitBrowserLoadReposBtn) gitBrowserLoadReposBtn.addEventListener('click', renderGitReposList);
            if (refreshGitBrowserBtn) refreshGitBrowserBtn.addEventListener('click', async () => {
                await renderGitReposList();
                if (gitSelectedRepoFull) await listMarkdownFilesForRepo(gitSelectedRepoFull);
            });
            if (gitFilesFilterInput) gitFilesFilterInput.addEventListener('input', renderGitFilesList);
            if (gitImportConfirmBtn) gitImportConfirmBtn.addEventListener('click', async () => {
                try {
                    if (!gitSelectedRepoFull || !gitSelectedFile) return;
                    const md = await fetchMarkdownFile(gitSelectedRepoFull, gitSelectedFile);
                    if (!md) return;
                    mainEditor.value = md;
                    updateEditorStats();
                    renderVariables();
                    const title = gitImportTitleInput?.value.trim();
                    const project = gitImportProjectInput?.value.trim();
                    if (title) titleInput.value = title;
                    if (project) {
                        projectInput.value = project;
                        if (!projectNames.includes(project)) {
                            projectNames.push(project);
                            saveProjectNamesToStorage();
                            updateGlobalList('projects', projectNames);
                        }
                    }
                    currentGithubRepo = { id: gitSelectedRepoFull, full: gitSelectedRepoFull };
                    lastImportedGitFilePath = gitSelectedFile;
                    closeImportGitModal();
                } catch (e) {
                    console.error(e);
                    showModal('Import error', 'Failed to fetch the selected Markdown file.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                }
            });

            // Close Import-from-Git on overlay click
            if (importGitModal) {
                importGitModal.addEventListener('click', (e) => {
                    if (e.target === importGitModal) closeImportGitModal();
                });
            }

            // --- Commit Changes logic ---
            const openCommitModal = async () => {
                if (!currentGithubRepo || !currentGithubRepo.full) {
                    showModal('GitHub repo not set', 'Select a repository in the Dock > GitHub before committing.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                    return;
                }
                if (commitRepoLabel) commitRepoLabel.textContent = currentGithubRepo.full;
                const candidatePath = (commitFilePathInput?.value?.trim()) || lastImportedGitFilePath || (selectedVersionId ? (prompts.find(p => p.id === selectedVersionId)?.githubFilePath || '') : '');
                if (commitFilePathInput) commitFilePathInput.value = candidatePath || '';
                if (commitMessageInput) commitMessageInput.value = `Update ${titleInput.value || 'prompt'}`;
                // Load branches
                await populateCommitBranches(currentGithubRepo.full);
                // Load latest commit info
                await updateLatestCommitInfo(currentGithubRepo.full, commitBranchSelect?.value);
                commitModal.classList.remove('hidden');
                commitMessageInput?.focus();
            };

            const closeCommitModal = () => commitModal.classList.add('hidden');

            async function commitFileToGitHub(repoFull, path, content, message, branch) {
                // First, try to get existing file to retrieve its SHA
                let sha = null;
                try {
                    const suffix = branch ? `?ref=${encodeURIComponent(branch)}` : '';
                    const head = await githubRequest(`repos/${repoFull}/contents/${encodeURIComponent(path)}${suffix}`, { method: 'GET' });
                    if (head.ok) {
                        const info = await head.json();
                        sha = info.sha || null;
                    }
                } catch {}
                const body = {
                    message: message || `Update ${path}`,
                    content: btoa(unescape(encodeURIComponent(content))),
                    sha: sha || undefined,
                    branch: branch || undefined
                };
                const res = await githubRequest(`repos/${repoFull}/contents/${encodeURIComponent(path)}`, { method: 'PUT', body: JSON.stringify(body) });
                return res.ok;
            }

            async function populateCommitBranches(repoFull) {
                if (!commitBranchSelect) return;
                commitBranchSelect.innerHTML = '<option>Loading…</option>';
                try {
                    const res = await githubRequest(`repos/${repoFull}/branches?per_page=100`, { method: 'GET' });
                    if (!res.ok) throw new Error('branches failed');
                    const branches = await res.json();
                    const repoRes = await githubRequest(`repos/${repoFull}`, { method: 'GET' });
                    const repoInfo = repoRes.ok ? await repoRes.json() : {};
                    const defaultBranch = repoInfo.default_branch || 'main';
                    commitBranchSelect.innerHTML = '';
                    (branches || []).forEach(b => {
                        const opt = document.createElement('option');
                        opt.value = b.name;
                        opt.textContent = b.name + (b.name === defaultBranch ? ' (default)' : '');
                        commitBranchSelect.appendChild(opt);
                    });
                    commitBranchSelect.value = defaultBranch;
                } catch (e) {
                    commitBranchSelect.innerHTML = '<option value="main">main</option>';
                }
            }

            async function updateLatestCommitInfo(repoFull, branch) {
                if (!commitLatestInfo) return;
                commitLatestInfo.textContent = 'Loading…';
                try {
                    const br = branch || 'main';
                    const res = await githubRequest(`repos/${repoFull}/commits?sha=${encodeURIComponent(br)}&per_page=1`, { method: 'GET' });
                    if (!res.ok) throw new Error('commits failed');
                    const items = await res.json();
                    const c = items[0];
                    if (!c) { commitLatestInfo.textContent = 'No commits found.'; return; }
                    const msg = c.commit?.message?.split('\n')[0] || '';
                    const sha = c.sha?.slice(0, 7) || '';
                    const author = c.commit?.author?.name || c.author?.login || 'unknown';
                    const date = c.commit?.author?.date || '';
                    commitLatestInfo.textContent = `${sha} — ${msg} · ${author} · ${new Date(date).toLocaleString()}`;
                } catch (e) {
                    commitLatestInfo.textContent = 'Failed to load latest commit.';
                }
            }

            if (commitChangesBtn) commitChangesBtn.addEventListener('click', openCommitModal);
            if (closeCommitModalBtn) closeCommitModalBtn.addEventListener('click', closeCommitModal);
            if (cancelCommitBtn) cancelCommitBtn.addEventListener('click', closeCommitModal);
            if (confirmCommitBtn) confirmCommitBtn.addEventListener('click', async () => {
                try {
                    const repoFull = currentGithubRepo?.full;
                    const path = commitFilePathInput?.value.trim();
                    const message = commitMessageInput?.value.trim() || `Update ${path}`;
                    const branch = commitBranchSelect?.value;
                    if (!repoFull || !path) {
                        showValidationAlert('Repository and file path are required.');
                        return;
                    }
                    const ok = await commitFileToGitHub(repoFull, path, mainEditor.value, message, branch);
                    if (!ok) throw new Error('Commit failed');
                    lastImportedGitFilePath = path;
                    // Persist file path to selected version in-memory (will save on next Save Changes/Version)
                    if (selectedVersionId) {
                        const idx = prompts.findIndex(p => p.id === selectedVersionId);
                        if (idx !== -1) { prompts[idx].githubFilePath = path; }
                    }
                    showModal('Committed', 'Changes committed to GitHub.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                    closeCommitModal();
                } catch (e) {
                    console.error(e);
                    showModal('Commit error', 'Failed to commit changes. Check your connection, permissions, and path.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                }
            });

            if (commitBranchSelect) commitBranchSelect.addEventListener('change', () => {
                if (currentGithubRepo?.full) updateLatestCommitInfo(currentGithubRepo.full, commitBranchSelect.value);
            });
            if (closeImportModalBtn) closeImportModalBtn.addEventListener('click', closeImportModal);
            if (cancelImportBtn) cancelImportBtn.addEventListener('click', closeImportModal);
            if (confirmImportBtn) confirmImportBtn.addEventListener('click', async () => {
                const title = importPromptNameInput.value.trim() || 'Imported Document';
                const project = importProjectInput.value.trim();
                const llm = importLlmSelect.value || 'generic';
                if (!pendingImportedText) { closeImportModal(); return; }
                const promptId = getUUID();
                const now = new Date().toISOString();
                const newItem = {
                    id: getUUID(),
                    promptId,
                    title,
                    project,
                    llm,
                    content: pendingImportedText,
                    comments: '',
                    version: '1.0',
                    date: now,
                    status: 'write',
                    tags: [],
                    temperature: 0.7,
                    topP: 0.9,
                    effort: 'Medium',
                    parentId: '',
                };
                // Track new project names
                if (project && !projectNames.includes(project)) {
                    projectNames.push(project);
                    saveProjectNamesToStorage();
                    updateGlobalList('projects', projectNames);
                }
                // Save locally
                prompts.push(newItem);
                savePromptsToStorage();
                // Try to upsert remotely
                const saved = await upsertItem('prompts', mapPromptUIToDb(newItem));
                if (!saved) console.warn('Remote save failed or offline; kept local');
                // Refresh UI bits
                renderVersionsList();
                loadVersionIntoEditor(newItem.id);
                closeImportModal();
                pendingImportedText = '';
            });

            // --- TEXT EDITOR ENHANCEMENTS ---
            // Formatting helpers and toolbar bindings removed

            // Tab/Shift+Tab indentation in textarea
            mainEditor.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = mainEditor.selectionStart;
                    const end = mainEditor.selectionEnd;
                    const value = mainEditor.value;
                    const sel = value.slice(start, end);
                    const isMulti = sel.includes('\n');
                    if (e.shiftKey) {
                        // outdent
                        if (isMulti) {
                            const pre = value.slice(0, start);
                            const post = value.slice(end);
                            const lines = sel.split('\n').map((l) => l.replace(/^(\t| {4})/, ''));
                            const result = lines.join('\n');
                            mainEditor.value = pre + result + post;
                            mainEditor.setSelectionRange(start, start + result.length);
                        } else {
                            const before = value.slice(0, start);
                            const after = value.slice(end);
                            const lineStart = before.lastIndexOf('\n') + 1;
                            const line = value.slice(lineStart, end);
                            const newLine = line.replace(/^(\t| {4})/, '');
                            const delta = line.length - newLine.length;
                            mainEditor.value = value.slice(0, lineStart) + newLine + after;
                            const newPos = start - delta;
                            mainEditor.setSelectionRange(newPos, newPos);
                        }
                    } else {
                        // indent
                        const indent = '\t';
                        if (isMulti) {
                            const pre = value.slice(0, start);
                            const post = value.slice(end);
                            const lines = sel.split('\n').map((l) => indent + l);
                            const result = lines.join('\n');
                            mainEditor.value = pre + result + post;
                            mainEditor.setSelectionRange(start + indent.length, start + result.length);
                        } else {
                            const before = value.slice(0, start);
                            const after = value.slice(end);
                            mainEditor.value = before + indent + after;
                            mainEditor.setSelectionRange(start + indent.length, start + indent.length);
                        }
                    }
                    mainEditor.dispatchEvent(new Event('input'));
                }
            });

            const renderVariables = () => {
                const content = mainEditor.value;
                const variableRegex = /\{\{([a-zA-Z0-9_]+)\}\}/g;
                let match;
                const variables = new Set();
                while ((match = variableRegex.exec(content)) !== null) {
                    variables.add(match[1]);
                }

                if (variables.size === 0) {
                    variablesSection.classList.add('hidden');
                    return;
                }

                variablesSection.classList.remove('hidden');
                variablesContainer.innerHTML = '';
                variables.forEach(varName => {
                    const varInputHTML = `
                        <div class="flex items-center gap-2">
                            <label for="var-${varName}" class="w-1/3 text-sm text-[--text-muted-dark] font-mono">${varName}:</label>
                            <input type="text" id="var-${varName}" name="${varName}" class="w-2/3 form-control rounded-md py-1 px-2 text-sm focus:ring-2 focus:ring-fuchsia-500 focus:border-fuchsia-500">
                        </div>
                    `;
                    variablesContainer.innerHTML += varInputHTML;
                });
            };
            
            const updateSlidersUI = () => {
                // Kept for backward compatibility (no-op)
            };

            // --- FUNÇÕES DE LÓGICA ---
            const showModal = (title, text, buttons, options = {}) => {
                confirmModalTitle.textContent = title;
                confirmModalText.innerHTML = text;
                confirmModalButtons.innerHTML = '';
                buttons.forEach(btn => {
                    const buttonEl = document.createElement('button');
                    buttonEl.className = btn.className;
                    buttonEl.textContent = btn.text;
                    buttonEl.onclick = btn.onClick;
                    confirmModalButtons.appendChild(buttonEl);
                });
            
                if (options.showInput) {
                    confirmModalInput.value = options.inputValue || '';
                    confirmModalInput.placeholder = options.inputPlaceholder || '';
                    confirmModalInputContainer.classList.remove('hidden');
                } else {
                    confirmModalInputContainer.classList.add('hidden');
                }
            
                confirmModal.classList.remove('hidden');
            };
            
            const hideModal = () => {
                confirmModal.classList.add('hidden');
            };
            
            const showValidationAlert = (message) => {
                showModal('Required Field', message, [
                    { text: 'OK', className: 'action-button primary', onClick: hideModal }
                ]);
            };
            
            const showDeleteModal = (type, id) => {
                itemToDelete = { type, id };
                const title = 'Confirm Deletion';
                const text = type === 'group' 
                    ? 'Are you sure you want to delete this prompt and all its versions? This action cannot be undone.'
                    : 'Are you sure you want to delete this specific version?';
            
                showModal(title, text, [
                    { text: 'Cancel', className: 'action-button', onClick: hideModal },
                    { text: 'Delete', className: 'action-button bg-[--accent-red] text-white border-[--accent-red-hover] hover:bg-[--accent-red-hover]', onClick: executeDelete }
                ]);
            };
            
            const showDependencyViewer = (dependencyId) => {
                const prompt = prompts.find(p => p.id === dependencyId);
                if (prompt) {
                    dependencyViewerTitle.textContent = `${prompt.title} (v${prompt.version})`;
                    dependencyViewerContent.textContent = prompt.content;
                    dependencyViewerModal.classList.remove('hidden');
                }
            };
            
            const showCommentsViewer = (promptId) => {
                const prompt = prompts.find(p => String(p.id) === String(promptId));
                if (prompt && prompt.comments) {
                    commentsViewerTitle.textContent = `Comments - ${prompt.title} (v${prompt.version})`;
                    commentsViewerContent.textContent = prompt.comments;
                    commentsViewerModal.classList.remove('hidden');
                }
            };
            
            const executeDelete = async () => {
                if (!itemToDelete.id) return;

                if (itemToDelete.type === 'group') {
                    await deleteItemsByPromptId(itemToDelete.id);
                    prompts = prompts.filter(p => String(p.promptId) !== String(itemToDelete.id));
                    if (selectedVersionId && !prompts.some(p => String(p.id) === String(selectedVersionId))) {
                        clearEditorForNewPrompt();
                    }
                } else if (itemToDelete.type === 'version') {
                    await deleteItem('prompts', itemToDelete.id);
                    prompts = prompts.filter(p => String(p.id) !== String(itemToDelete.id));
                    if (String(selectedVersionId) === String(itemToDelete.id)) {
                        clearEditorForNewPrompt();
                    }
                }
                hideModal();
                renderVersionsList();
            };
            
            const clearEditorForNewPrompt = () => {
                titleInput.value = '';
                projectInput.value = '';
                mainEditor.value = '';
                commentsTextarea.value = '';
                commentsSection.classList.add('hidden');
                selectedVersionId = null;
                llmSelect.value = 'generic';
                currentGithubRepo = null;
                currentDependencies = [];
                updateStatusSelectorUI('write');
                updateEditorStats();
                renderVariables();
                renderDynamicSettings(); // Reset dynamic settings to defaults
                renderDependencyBar([]);
                titleInput.focus();
                populateProjectDataList();
                renderVersionsList(); 
                renderPromptTags([]);
                tagsInput.value = '';
                renderNavigationMap();
                updateSnippetButtons();
            };
            
            const loadVersionIntoEditor = (versionId) => {
                const promptVersion = prompts.find(p => p.id === versionId);
                if (!promptVersion) return;
                titleInput.value = promptVersion.title;
                projectInput.value = promptVersion.project;
                mainEditor.value = promptVersion.content;
                commentsTextarea.value = promptVersion.comments || '';
                llmSelect.value = promptVersion.llm || 'generic';
                currentGithubRepo = promptVersion.githubRepo ? { id: promptVersion.githubRepo, full: promptVersion.githubRepoFull || '' } : null;
                selectedVersionId = versionId;
                updateStatusSelectorUI(promptVersion.status);
                updateEditorStats();
                renderVariables();
                renderDynamicSettings(
                    promptVersion.modelSettings || {
                        temperature: promptVersion.temperature,
                        topP: promptVersion.topP,
                        effort: (typeof promptVersion.effort === 'string') ? effortLevels.indexOf(promptVersion.effort) : undefined
                    }
                );
                expandedPromptGroups.add(String(promptVersion.promptId));
            
                const depsToShow = (promptVersion.dependencies && promptVersion.dependencies.length)
                    ? promptVersion.dependencies
                    : (promptVersion.parentId ? [promptVersion.parentId] : []);
                renderDependencyBar(depsToShow);
            
                populateProjectDataList();
                renderVersionsList(); 
                renderPromptTags(promptVersion.tags);
                tagsInput.value = '';
                renderNavigationMap();
                updateSnippetButtons();
            };
            
            const saveVersion = async (isMajor = false) => {
                const title = titleInput.value.trim();
                const project = projectInput.value.trim();
                const content = mainEditor.value.trim();
                const comments = commentsTextarea.value.trim();
                const activeStatus = document.querySelector('.status-option.active')?.dataset.status || 'write';
                const llm = llmSelect.value;
                const selectedDepIds = currentDependencies.map(String);
                const parentId = selectedDepIds.length === 1 ? selectedDepIds[0] : null; // legacy parentId
                const dyn = collectDynamicSettings();
                const temperature = dyn.temperature ?? 0.7;
                const topP = dyn.topP ?? 0.9;
                const effort = dyn.effort !== undefined ? effortLevels[dyn.effort] || 'Medium' : (effortLevels[1]);

                if (!project || !title || !content || llm === 'generic') {
                    showValidationAlert('Project, Title, Content, and Target LLM are required fields.');
                    return;
                }

                const currentTags = [...tagsContainer.querySelectorAll('.prompt-tag span')].map(span => span.textContent);

                let newVersionNumber;
                let promptIdToUse;

                if (selectedVersionId === null) {
                    // CASO 1: Nenhum prompt selecionado (clicou em "Add Prompt").
                    // Sempre cria um novo prompt pai, versão 1.0.
                    promptIdToUse = getUUID();
                    newVersionNumber = '1.0';
                } else {
                    // CASO 2: Um prompt existente está selecionado.
                    const currentPrompt = prompts.find(p => String(p.id) === String(selectedVersionId));
                    promptIdToUse = currentPrompt.promptId;
                    const versionsOfSamePrompt = prompts.filter(p => p.promptId === promptIdToUse);
                    
                    const latestVersion = versionsOfSamePrompt.sort((a, b) => {
                        const [majorA, minorA = 0] = a.version.split('.').map(Number);
                        const [majorB, minorB = 0] = b.version.split('.').map(Number);
                        if (majorA !== majorB) return majorB - majorA;
                        return minorB - minorA;
                    })[0];
                    
                    const [major, minor = 0] = latestVersion.version.split('.').map(Number);

                    if (isMajor) {
                        // Se for "Save Major", incrementa o número principal e zera o secundário.
                        newVersionNumber = `${major + 1}.0`;
                    } else {
                        // Se for "Save New" (minor), incrementa o número secundário.
                        newVersionNumber = `${major}.${(minor || 0) + 1}`;
                    }
                }

                const newVersion = {
                    id: getUUID(),
                    promptId: promptIdToUse, // <-- propriedade atualizada
                    title, project, content,
                    version: newVersionNumber, status: activeStatus, llm, date: new Date().toISOString(), parentId,
                    dependencies: selectedDepIds,
                    temperature, topP, effort, tags: currentTags, comments,
                    modelSettings: dyn,
                    githubRepo: currentGithubRepo && currentGithubRepo.id ? currentGithubRepo.id : '',
                    githubRepoFull: currentGithubRepo && currentGithubRepo.full ? currentGithubRepo.full : '',
                    githubFilePath: (typeof commitFilePathInput !== 'undefined' && commitFilePathInput?.value) ? commitFilePathInput.value.trim() : (typeof lastImportedGitFilePath !== 'undefined' ? lastImportedGitFilePath : '')
                };

                const rows = await upsertItem('prompts', mapPromptUIToDb(newVersion));
                const saved = rows && rows[0] ? rows[0] : newVersion;
                prompts.push(saved);
                loadVersionIntoEditor(saved.id);
            };
            
            const forkVersion = async () => {
                if (!selectedVersionId) {
                    showValidationAlert('Please select a version to fork.');
                    return;
                }
            
                const originalPrompt = prompts.find(p => String(p.id) === String(selectedVersionId));
                if (!originalPrompt) return;
            
                const newFork = {
                    id: getUUID(),
                    promptId: getUUID(), // Cria um novo grupo (ID de prompt)
                    title: `(Fork) ${originalPrompt.title}`,
                    project: originalPrompt.project,
                    content: originalPrompt.content,
                    version: '1.0',
                    status: 'write',
                    llm: originalPrompt.llm,
                    date: new Date().toISOString(),
                    parentId: String(selectedVersionId), // Mantém o link com a versão original
                    temperature: originalPrompt.temperature,
                    topP: originalPrompt.topP,
                    effort: originalPrompt.effort,
                    tags: [...originalPrompt.tags], // Cria uma cópia das tags
                    comments: `Fork of version ${originalPrompt.version}. Original comment: ${originalPrompt.comments || 'None.'}`
                };
            
                const rows = await upsertItem('prompts', mapPromptUIToDb(newFork));
                const saved = rows && rows[0] ? rows[0] : newFork;
                prompts.push(saved);
                savePromptsToStorage();
                loadVersionIntoEditor(saved.id);
            };
            
            const downloadFile = (format) => {
                if (!selectedVersionId) {
                    showValidationAlert('Please select a version to download.');
                    return;
                }
                const version = prompts.find(p => String(p.id) === String(selectedVersionId));
                let content, filename, mimeType;
                if (format === 'json') {
                    content = JSON.stringify(version, null, 2);
                    filename = `${version.title.replace(/ /g, '_')}_v${version.version}.json`;
                    mimeType = 'application/json';
                } else if (format === 'md') {
                    content = `# ${version.title} (v${version.version})\n\n**Project:** ${version.project}\n**Status:** ${version.status}\n**LLM:** ${version.llm}\n**Tags:** ${version.tags.join(', ')}\n**Temperature:** ${version.temperature}\n**Top P:** ${version.topP}\n**Effort:** ${version.effort}\n\n---\n\n${version.content}`;
                    filename = `${version.title.replace(/ /g, '_')}_v${version.version}.md`;
                    mimeType = 'text/markdown';
                } else if (format === 'txt') {
                    content = `${version.title} (v${version.version})\n\nProject: ${version.project}\nStatus: ${version.status}\nLLM: ${version.llm}\nTags: ${version.tags.join(', ')}\nTemperature: ${version.temperature}\nTop P: ${version.topP}\nEffort: ${version.effort}\n\n---\n\n${version.content}`;
                    filename = `${version.title.replace(/ /g, '_')}_v${version.version}.txt`;
                    mimeType = 'text/plain';
                }
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([content], { type: mimeType }));
                a.download = filename;
                a.click();
                URL.revokeObjectURL(a.href);
            };

        const toggleReadMode = () => {
                const isHidden = readModeModal.classList.contains('hidden');
                if (isHidden) {
                    const currentContent = mainEditor.value;
                    let processedContent = currentContent;
                    document.querySelectorAll('#variables-container input').forEach(input => {
                        const varName = input.name;
                        const varValue = input.value || `{{${varName}}}`;
                        processedContent = processedContent.replace(new RegExp(`\\{\\{${varName}\\}\\}`, 'g'), varValue);
                    });

            // Header and metadata
            const currentTitle = titleInput.value || '';
            const currentProject = projectInput.value || '';
            const currentLLM = llmSelect.value || '';
            const currentComments = commentsTextarea.value || '';

            // Stats
            const charCount = processedContent.length;
            const wordCount = processedContent.trim().split(/\s+/).filter(Boolean).length;
            const tokenCount = Math.ceil(charCount / 4);

            document.getElementById('read-mode-title').textContent = currentTitle || '(Untitled)';
            const currentRepoText = (currentGithubRepo && (currentGithubRepo.full || currentGithubRepo.id)) ? (currentGithubRepo.full || currentGithubRepo.id) : 'N/A';
            document.getElementById('read-mode-meta').textContent = `Project: ${currentProject || 'N/A'} · LLM: ${currentLLM || 'N/A'} · Repo: ${currentRepoText}`;
                    document.getElementById('read-mode-stats').textContent = `${tokenCount} tokens / ${wordCount} words / ${charCount} characters`;
            document.getElementById('read-mode-comments').textContent = currentComments ? `Comments: ${currentComments}` : '';

            readModeContent.textContent = processedContent;
                    readModeModal.classList.remove('hidden');
                    mainContent.classList.add('read-mode-blur');
                    mainHeader.style.zIndex = 60; // Traz o header para frente
                    readModeIconClosed.classList.add('hidden');
                    readModeIconOpen.classList.remove('hidden');
                } else {
                    readModeModal.classList.add('hidden');
                    mainContent.classList.remove('read-mode-blur');
                    mainHeader.style.zIndex = 20; // Retorna z-index ao normal
                    readModeIconClosed.classList.remove('hidden');
                    readModeIconOpen.classList.add('hidden');
            document.getElementById('read-mode-title').textContent = '';
            document.getElementById('read-mode-meta').textContent = '';
            document.getElementById('read-mode-stats').textContent = '';
            document.getElementById('read-mode-comments').textContent = '';
                }
            };

            // --- LÓGICA DE BUSCA E SUBSTITUIÇÃO ---
            const toggleFindReplaceBar = (show) => {
                if (show) {
                    findReplaceBar.classList.add('visible');
                    findInput.focus();
                } else {
                    findReplaceBar.classList.remove('visible');
                    mainEditor.focus();
                    // Limpa o estado da busca ao fechar
                    findState = { matches: [], currentIndex: -1, query: '' };
                    updateFindUI();
                }
            };

            const executeFind = () => {
                const query = findInput.value;
                if (!query) {
                    findState = { matches: [], currentIndex: -1, query: '' };
                    updateFindUI();
                    return;
                }
                
                if (query === findState.query) return; // Não busca de novo se a query for a mesma

                const text = mainEditor.value;
                const regex = new RegExp(query, 'gi');
                let match;
                findState.matches = [];
                while ((match = regex.exec(text)) !== null) {
                    findState.matches.push({
                        index: match.index,
                        length: match[0].length
                    });
                }
                findState.query = query;
                findState.currentIndex = findState.matches.length > 0 ? 0 : -1;
                updateFindUI();
                highlightCurrentMatch();
            };

            const updateFindUI = () => {
                const { matches, currentIndex } = findState;
                const total = matches.length;
                
                if (total > 0) {
                    findCounter.textContent = `${currentIndex + 1}/${total}`;
                } else {
                    findCounter.textContent = '0/0';
                }

                nextBtn.disabled = currentIndex >= total - 1;
                prevBtn.disabled = currentIndex <= 0;
                replaceBtn.disabled = total === 0;
                replaceAllBtn.disabled = total === 0;
            };

            const highlightCurrentMatch = () => {
                mainEditor.focus();
                const { matches, currentIndex } = findState;
                if (currentIndex !== -1) {
                    const match = matches[currentIndex];
                    mainEditor.setSelectionRange(match.index, match.index + match.length);
                }
            };

            const goToNextMatch = () => {
                if (findState.currentIndex < findState.matches.length - 1) {
                    findState.currentIndex++;
                    updateFindUI();
                    highlightCurrentMatch();
                }
            };

            const goToPrevMatch = () => {
                if (findState.currentIndex > 0) {
                    findState.currentIndex--;
                    updateFindUI();
                    highlightCurrentMatch();
                }
            };

            const executeReplace = () => {
                const { matches, currentIndex } = findState;
                if (currentIndex === -1) return;

                const replaceText = replaceInput.value;
                const match = matches[currentIndex];
                const originalText = mainEditor.value;

                mainEditor.value = originalText.substring(0, match.index) + replaceText + originalText.substring(match.index + match.length);
                
                // Após substituir, refaz a busca para atualizar os índices e os botões
                executeFind();
                updateSnippetButtons();
            };

            const executeReplaceAll = () => {
                const { matches } = findState;
                if (matches.length === 0) return;

                const findText = findInput.value;
                const replaceText = replaceInput.value;
                const regex = new RegExp(findText, 'gi');
                
                mainEditor.value = mainEditor.value.replace(regex, replaceText);

                // Limpa o estado da busca e atualiza os botões
                executeFind();
                updateSnippetButtons();
            };

            const populateGraphFilters = () => {
                graphProjectFilter.innerHTML = '<option value="all">All Projects</option>';
                const existingProjects = [...new Set(prompts.map(p => p.project).filter(Boolean))].sort();
                existingProjects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project;
                    option.textContent = project;
                    graphProjectFilter.appendChild(option);
                });
            };

            // =================================================================
            // FUNÇÃO DO GRÁFICO DE DEPENDÊNCIAS
            // =================================================================
            const renderDependencyGraph = (filters = {}) => {
                const svg = d3.select("#dependency-graph-svg");
                const container = svg.node().parentElement;
                const width = container.clientWidth;
                const height = container.clientHeight;

                svg.selectAll("*").remove(); 

                let promptsToRender = [...prompts];
                if (filters.project && filters.project !== 'all') {
                    promptsToRender = prompts.filter(p => p.project === filters.project);
                }

                if (promptsToRender.length === 0) {
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height / 2)
                        .attr("text-anchor", "middle")
                        .style("fill", "var(--text-muted-dark)")
                        .text("No prompts to display for the selected filter.");
                    return;
                }

                const nodes = promptsToRender.map(p => ({
                    id: p.id,
                    title: p.title,
                    version: p.version,
                    group: p.promptId,
                    promptData: p 
                }));
                const nodeIds = new Set(nodes.map(n => n.id));

                const links = [];
                prompts.forEach(p => {
                    const depIds = (p.dependencies && p.dependencies.length) ? p.dependencies : (p.parentId ? [p.parentId] : []);
                    depIds.forEach(depId => {
                        if (depId !== null && nodeIds.has(p.id) && nodeIds.has(depId)) {
                            links.push({ source: depId, target: p.id });
                        }
                    });
                });

                const simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id).distance(150).strength(0.5))
                    .force("charge", d3.forceManyBody().strength(-400))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("x", d3.forceX(width / 2).strength(0.05))
                    .force("y", d3.forceY(height / 2).strength(0.05));

                const g = svg.append("g");
                
                g.append('defs').append('marker')
                    .attr('id', 'arrowhead')
                    .attr('viewBox', '-0 -5 10 10')
                    .attr('refX', 23)
                    .attr('refY', 0)
                    .attr('orient', 'auto')
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .append('svg:path')
                    .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                    .attr('fill', 'var(--border-dark)');

                const link = g.append("g")
                    .attr("class", "graph-links")
                    .selectAll("line")
                    .data(links)
                    .join("line")
                    .attr("class", "graph-link")
                    .attr("marker-end", "url(#arrowhead)");

                const node = g.append("g")
                    .attr("class", "graph-nodes")
                    .selectAll("g")
                    .data(nodes)
                    .join("g")
                    .attr("class", "graph-node")
                    .call(drag(simulation));

                const color = d3.scaleOrdinal(d3.schemeTableau10);

                node.append("circle")
                    .attr("r", 12)
                    .attr("fill", d => color(d.group));

                node.append("text")
                    .text(d => `${d.title} v${d.version}`)
                    .attr('y', -20);

                node.on('mouseover', (event, d) => {
                    const promptData = d.promptData;
                    graphTooltip.style.opacity = 1;
                    graphTooltip.innerHTML = `
                        <h3 class="font-bold text-base mb-2 truncate" style="color: var(--accent-fuchsia);">${promptData.title}</h3>
                        <div class="space-y-1">
                            <p><strong class="text-[--text-muted-dark] font-normal">Project:</strong> ${promptData.project || 'N/A'}</p>
                            <p><strong class="text-[--text-muted-dark] font-normal">LLM:</strong> ${promptData.llm || 'N/A'}</p>
                        </div>
                        <div class="mt-3 pt-2 border-t border-[--border-dark] grid grid-cols-3 gap-2 text-center font-mono">
                            <div><p class="text-[--text-muted-dark] text-xs">Temp</p><p class="font-semibold text-sm">${promptData.temperature}</p></div>
                            <div><p class="text-[--text-muted-dark] text-xs">Top P</p><p class="font-semibold text-sm">${promptData.topP}</p></div>
                            <div><p class="text-[--text-muted-dark] text-xs">Effort</p><p class="font-semibold text-sm">${promptData.effort}</p></div>
                        </div>
                    `;
                    const svgRect = svg.node().getBoundingClientRect();
                    graphTooltip.style.left = (event.clientX - svgRect.left + 15) + 'px';
                    graphTooltip.style.top = (event.clientY - svgRect.top + 15) + 'px';
                })
                .on('mouseout', () => {
                    graphTooltip.style.opacity = 0;
                });

                node.on("click", async (event, d) => {
                    if (isCreatingConnection) {
                        if (!firstNodeForConnection) {
                            firstNodeForConnection = d;
                            d3.select(event.currentTarget).classed('selected-for-connection', true);
                        } else {
                            if (firstNodeForConnection.id !== d.id) {
                                const childPrompt = prompts.find(p => p.id === d.id);
                                if (childPrompt) {
                                    // Ensure dependencies array exists and add the new dependency if not present
                                    if (!Array.isArray(childPrompt.dependencies)) childPrompt.dependencies = [];
                                    if (!childPrompt.dependencies.includes(firstNodeForConnection.id)) {
                                        childPrompt.dependencies.push(firstNodeForConnection.id);
                                    }
                                    // Keep legacy parentId in sync if exactly one dependency
                                    childPrompt.parentId = (childPrompt.dependencies.length === 1) ? childPrompt.dependencies[0] : null;
                                    savePromptsToStorage();
                                    renderDependencyGraph({ project: graphProjectFilter.value });
                                    await upsertItem('prompts', mapPromptUIToDb(childPrompt));
                                    if (selectedVersionId && String(selectedVersionId) === String(childPrompt.id)) {
                                        renderDependencyBar(childPrompt.dependencies);
                                    }
                                }
                            }
                            isCreatingConnection = false;
                            firstNodeForConnection = null;
                            createConnectionBtn.classList.remove('active');
                            d3.selectAll('.graph-node').classed('selected-for-connection', false);
                        }
                    } else {
                        loadVersionIntoEditor(d.id);
                        dependencyGraphModal.classList.add('hidden');
                    }
                });

                link.on('click', (event, d) => {
                    event.stopPropagation();
                    link.classed('selected', false);
                    d3.select(event.currentTarget).classed('selected', true);
                    selectedLinkForDeletion = d;
                    deleteConnectionBtn.disabled = false;
                });

                svg.on('click', () => {
                    link.classed('selected', false);
                    selectedLinkForDeletion = null;
                    deleteConnectionBtn.disabled = true;
                });

                simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node.attr("transform", d => `translate(${d.x},${d.y})`);
                });

                svg.call(d3.zoom().on("zoom", (event) => {
                    g.attr("transform", event.transform);
                }));

                function drag(simulation) {
                    function dragstarted(event, d) {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        d.fx = d.x; d.fy = d.y;
                    }
                    function dragged(event, d) {
                        d.fx = event.x; d.fy = event.y;
                    }
                    function dragended(event, d) {
                        if (!event.active) simulation.alphaTarget(0);
                        d.fx = null; d.fy = null;
                    }
                    return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
                }
            };

            // --- LÓGICA DO SNIPPET COPY (NOVO) ---
            const updateSnippetButtons = () => {
                snippetButtonsOverlay.innerHTML = '';
                snippets = [];
                const text = mainEditor.value;
                
                const openTags = [];
                const tagRegex = /<(\/)?([a-zA-Z][\w-]*)/g;
                let match;

                while ((match = tagRegex.exec(text)) !== null) {
                    const isClosing = match[1] === '/';
                    const tagName = match[2];
                    const tagIndex = match.index;

                    if (isClosing) {
                        for (let i = openTags.length - 1; i >= 0; i--) {
                            if (openTags[i].name === tagName && !openTags[i].closed) {
                                openTags[i].closed = true;
                                const blockStartIndex = openTags[i].index;
                                const blockEndIndex = tagIndex + match[0].length + 1;
                                const blockContent = text.substring(blockStartIndex, blockEndIndex);
                                
                                const textUpToStart = text.substring(0, blockStartIndex);
                                const startLineNumber = textUpToStart.split('\n').length - 1;

                                snippets.push({ content: blockContent });
                                const snippetIndex = snippets.length - 1;

                                const button = document.createElement('button');
                                button.className = 'copy-snippet-btn';
                                button.title = 'Copy XML Snippet';
                                button.dataset.snippetIndex = snippetIndex;
                                button.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>`;

                                const styles = getComputedStyle(mainEditor);
                                const lineHeight = parseFloat(styles.lineHeight);
                                const paddingTop = parseFloat(styles.paddingTop);
                                const scrollTop = mainEditor.scrollTop;
                                const scrollLeft = mainEditor.scrollLeft;

                                button.style.top = `${(startLineNumber * lineHeight) + paddingTop - scrollTop}px`;
                                button.style.right = `${15 - scrollLeft}px`;

                                snippetButtonsOverlay.appendChild(button);
                                break; 
                            }
                        }
                    } else {
                        openTags.push({ name: tagName, index: tagIndex, closed: false });
                    }
                }
            };

            const renderPromptTags = (tags = []) => {
                tagsContainer.innerHTML = '';
                const projectTag = `#${projectInput.value.trim().toLowerCase().replace(/\s+/g, '-')}`;
                const llmTag = `#${llmSelect.value.toLowerCase()}`;
                
                if (projectInput.value.trim()) {
                    tagsContainer.appendChild(createTagEl(projectTag, true));
                }
                if (llmSelect.value !== 'generic') {
                    tagsContainer.appendChild(createTagEl(llmTag, true));
                }

                tags.forEach(tag => {
                    if (tag !== projectTag && tag !== llmTag) {
                        const tagEl = createTagEl(tag, false);
                        tagsContainer.appendChild(tagEl);
                    }
                });
            };

            const createTagEl = (tag, isAuto) => {
                const tagEl = document.createElement('div');
                tagEl.className = isAuto ? 'prompt-tag auto-tag' : 'prompt-tag';
                let html = `<span>${tag}</span>`;
                if (!isAuto) {
                    html += `<button class="remove-tag-btn" data-tag="${tag}">&times;</button>`;
                }
                tagEl.innerHTML = html;
                return tagEl;
            };

            const getAllUniqueTags = () => {
                const allTags = new Set();
                prompts.forEach(p => {
                    if (p.tags) {
                        p.tags.forEach(tag => allTags.add(tag));
                    }
                });
                return [...allTags].sort();
            }

            const renderNavigationMap = () => {
                const content = mainEditor.value;
                const xmlTagRegex = /<([a-zA-Z][\w-]*)/g;
                let match;
                const tags = [];

                while ((match = xmlTagRegex.exec(content)) !== null) {
                    tags.push({
                        name: match[1],
                        index: match.index
                    });
                }

                if (tags.length === 0) {
                    navigationMap.innerHTML = '';
                    navigationMap.classList.add('hidden');
                    return;
                }

                navigationMap.innerHTML = '<span class="text-xs font-bold text-[--text-muted-dark] self-center">Quick Nav:</span>';
                tags.forEach(tag => {
                    const tagEl = document.createElement('button');
                    tagEl.className = 'nav-map-tag';
                    tagEl.textContent = tag.name;
                    tagEl.dataset.index = tag.index;
                    navigationMap.appendChild(tagEl);
                });
                navigationMap.classList.remove('hidden');
            };

            // --- Drawer list renderers ---
            const setSelectedClass = (container, selector) => {
                if (!container) return;
                container.querySelectorAll('.drawer-row').forEach(el => el.classList.remove('selected'));
                const sel = selector ? container.querySelector(selector) : null;
                if (sel) sel.classList.add('selected');
            };

            const renderProjectListDrawer = () => {
                if (!projectListDrawer) return;
                projectListDrawer.innerHTML = '';
                const q = (document.getElementById('project-search-input')?.value || '').toLowerCase();
                const projects = Array.from(new Set(prompts.map(p => p.project).filter(Boolean).concat(projectNames)))
                    .filter(n => !q || n.toLowerCase().includes(q))
                    .sort();
                projects.forEach(name => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = name;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${name}</span>`;
                    row.addEventListener('click', () => {
                        const current = projectListDrawer.querySelector('.drawer-row.selected');
                        const isSame = current && current.dataset.value === name;
                        if (isSame) {
                            projectInput.value = '';
                            setSelectedClass(projectListDrawer, null);
                        } else {
                            projectInput.value = name;
                            renderPromptTags([...tagsContainer.querySelectorAll('.prompt-tag:not(.auto-tag) span')].map(s => s.textContent));
                            setSelectedClass(projectListDrawer, `[data-value=\"${CSS.escape(name)}\"]`);
                        }
                    });
                    projectListDrawer.appendChild(row);
                });
                if (projectInput && projectInput.value) setSelectedClass(projectListDrawer, `[data-value="${CSS.escape(projectInput.value)}"]`);
            };

            // GitHub panel: repos list and project assignment
            const githubListDrawer = document.getElementById('github-list-drawer');
            const githubAssignHint = document.getElementById('github-assign-hint');
            const renderGithubListDrawer = () => {
                if (!githubListDrawer) return;
                githubListDrawer.innerHTML = '';
                let repos = [];
                try { repos = JSON.parse(localStorage.getItem('github_repo_list') || '[]'); } catch {}
                const q = (document.getElementById('github-search-input')?.value || '').toLowerCase();
                const activeProject = (document.getElementById('project-name-input-aside')?.value || '').trim();
                if (githubAssignHint) {
                    githubAssignHint.textContent = activeProject ? `Assign a repository to project: ${activeProject}` : 'Select a project first in the Project panel to assign a repository.';
                }
                repos
                    .map(r => ({ id: r.id, label: r.repo || r.id }))
                    .filter(r => !q || r.label.toLowerCase().includes(q))
                    .sort((a,b) => a.label.localeCompare(b.label))
                    .forEach(({ id, label }) => {
                        const row = document.createElement('div');
                        row.className = 'drawer-row';
                        row.dataset.value = id;
                        row.innerHTML = `<span class="truncate text-sm font-mono">${label}</span>`;
                        const isSelected = activeProject && projectRepoMap[activeProject] === id;
                        if (isSelected) row.classList.add('selected');
                        row.addEventListener('click', () => {
                            if (!activeProject) return;
                            projectRepoMap[activeProject] = id;
                            saveProjectRepoMapToStorage();
                            try { updateGlobalList('project_repo_map', projectRepoMap); } catch {}
                            renderGithubListDrawer();
                        });
                        githubListDrawer.appendChild(row);
                    });
            };

            // Persisted expanded state for LLM groups
            let expandedLlmGroups = new Set();

            const renderLlmListDrawer = () => {
                if (!llmListDrawer) return;
                llmListDrawer.innerHTML = '';
                const q = (document.getElementById('llm-search-input')?.value || '').toLowerCase();
                // Special generic row
                const addRow = (label, value) => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = value;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${label}</span>`;
                    row.addEventListener('click', () => {
                        const current = llmListDrawer.querySelector('.drawer-row.selected');
                        const isSame = current && current.dataset.value === value;
                        if (isSame) {
                            llmSelect.value = 'generic';
                            llmSelect.dispatchEvent(new Event('change'));
                            setSelectedClass(llmListDrawer, `[data-value=\"generic\"]`);
                        } else {
                            llmSelect.value = value;
                            llmSelect.dispatchEvent(new Event('change'));
                            setSelectedClass(llmListDrawer, `[data-value=\"${CSS.escape(value)}\"]`);
                        }
                    });
                    llmListDrawer.appendChild(row);
                };

                if (!q || 'generic'.includes(q)) addRow('generic', 'generic');

                // Groups
                const groups = Object.keys(llmList).sort();
                groups.forEach(group => {
                    const models = (llmList[group] || []).slice().sort();
                    const groupMatches = !q || group.toLowerCase().includes(q);
                    const groupModels = models.filter(m => !q || m.toLowerCase().includes(q));
                    if (!groupMatches && groupModels.length === 0) return;
                    const groupContainer = document.createElement('div');
                    groupContainer.className = 'mb-1';

                    const header = document.createElement('div');
                    header.className = 'prompt-group-header flex items-center justify-between';
                    header.innerHTML = `
                        <div class="flex items-center gap-2">
                            <span class="toggle-icon">▶</span>
                            <span class="text-xs font-semibold text-[--text-muted-dark]">${group}</span>
                        </div>
                    `;
                    groupContainer.appendChild(header);

                    const list = document.createElement('div');
                    list.className = 'space-y-1 pl-6 mt-1';
                    groupContainer.appendChild(list);

                    // Expand logic: maintain state and auto-expand when searching
                    let isExpanded = expandedLlmGroups.has(group) || (!!q && (groupMatches || groupModels.length > 0));
                    const applyExpand = () => {
                        header.classList.toggle('expanded', isExpanded);
                        header.querySelector('.toggle-icon').textContent = isExpanded ? '▼' : '▶';
                        list.style.display = isExpanded ? '' : 'none';
                    };
                    applyExpand();

                    header.addEventListener('click', () => {
                        isExpanded = !isExpanded;
                        if (isExpanded) expandedLlmGroups.add(group); else expandedLlmGroups.delete(group);
                        applyExpand();
                    });

                    groupModels.forEach(model => list.appendChild((() => { const tmp = document.createElement('div'); addRow(model, model); return llmListDrawer.lastChild; })()));

                    llmListDrawer.appendChild(groupContainer);
                });

                if (llmSelect && llmSelect.value) setSelectedClass(llmListDrawer, `[data-value=\"${CSS.escape(llmSelect.value)}\"]`);
            };

            const renderTagsListDrawer = () => {
                if (!tagsListDrawer) return;
                tagsListDrawer.innerHTML = '';
                // union of used tags and library-only general tags
                const GENERAL_TAGS_LIB_KEY = 'promptManagerApp_generalTagsLib';
                let generalTagsLib = [];
                try { generalTagsLib = JSON.parse(localStorage.getItem(GENERAL_TAGS_LIB_KEY) || '[]'); } catch {}
                const q = (document.getElementById('tags-search-input')?.value || '').toLowerCase();
                const all = Array.from(new Set([...getAllUniqueTags(), ...generalTagsLib]))
                    .filter(t => !q || t.toLowerCase().includes(q))
                    .sort();
                const currentTags = new Set([...tagsContainer.querySelectorAll('.prompt-tag:not(.auto-tag) span')].map(s => s.textContent));
                all.forEach(tag => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = tag;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${tag}</span>`;
                    const isSelected = currentTags.has(tag);
                    if (isSelected) row.classList.add('selected');
                    row.addEventListener('click', () => {
                        if (currentTags.has(tag)) {
                            // remove from chips
                            const chip = Array.from(tagsContainer.querySelectorAll('.prompt-tag:not(.auto-tag)')).find(div => div.querySelector('span')?.textContent === tag);
                            if (chip) chip.remove();
                            currentTags.delete(tag);
                            row.classList.remove('selected');
                            if (currentTags.size === 0) { /* no-op: dock highlight removed */ }
                        } else {
                            const tagEl = createTagEl(tag, false);
                            tagsContainer.appendChild(tagEl);
                            currentTags.add(tag);
                            row.classList.add('selected');
                            /* dock highlight removed */
                        }
                    });
                    tagsListDrawer.appendChild(row);
                });
            };

            const renderXmlTagsListDrawer = () => {
                if (!xmlTagsListDrawer) return;
                xmlTagsListDrawer.innerHTML = '';
                const q = (document.getElementById('xml-search-input')?.value || '').toLowerCase();
                xmlTags.slice().filter(t => !q || t.toLowerCase().includes(q)).sort().forEach(tag => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = tag;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${tag}</span>`;
                    row.addEventListener('click', () => {
                        const current = xmlTagsListDrawer.querySelector('.drawer-row.selected');
                        const isSame = current && current.dataset.value === tag;
                        if (isSame) {
                            setSelectedClass(xmlTagsListDrawer, null);
                        } else {
                            const start = mainEditor.selectionStart;
                            const end = mainEditor.selectionEnd;
                            const text = mainEditor.value;
                            const selectedText = text.substring(start, end);
                            const tagText = selectedText ? `<${tag}>\n${selectedText}\n</${tag}>` : `<${tag}>\n\n</${tag}>`;
                            const newCursorPosition = start + (selectedText ? tagText.length : tag.length + 3);
                            mainEditor.value = text.substring(0, start) + tagText + text.substring(end);
                            mainEditor.focus();
                            mainEditor.setSelectionRange(newCursorPosition, newCursorPosition);
                            mainEditor.dispatchEvent(new Event('input', { bubbles: true }));
                            setSelectedClass(xmlTagsListDrawer, `[data-value=\"${CSS.escape(tag)}\"]`);
                        }
                    });
                    xmlTagsListDrawer.appendChild(row);
                });
            };

            const renderVarLibraryListDrawer = () => {
                if (!varLibraryListDrawer) return;
                varLibraryListDrawer.innerHTML = '';
                const q = (document.getElementById('var-search-input')?.value || '').toLowerCase();
                varLibrary.slice().filter(v => !q || v.toLowerCase().includes(q)).sort().forEach(v => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = v;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${v}</span>`;
                    row.addEventListener('click', () => {
                        const current = varLibraryListDrawer.querySelector('.drawer-row.selected');
                        const isSame = current && current.dataset.value === v;
                        if (isSame) {
                            setSelectedClass(varLibraryListDrawer, null);
                        } else {
                            const start = mainEditor.selectionStart;
                            const end = mainEditor.selectionEnd;
                            const text = mainEditor.value;
                            mainEditor.value = text.substring(0, start) + v + text.substring(end);
                            mainEditor.focus();
                            mainEditor.setSelectionRange(start + v.length, start + v.length);
                            mainEditor.dispatchEvent(new Event('input', { bubbles: true }));
                            setSelectedClass(varLibraryListDrawer, `[data-value=\"${CSS.escape(v)}\"]`);
                        }
                    });
                    varLibraryListDrawer.appendChild(row);
                });
            };

            const renderAddInputListDrawer = () => {
                if (!addInputListDrawer) return;
                addInputListDrawer.innerHTML = '';
                const q = (document.getElementById('input-search-input')?.value || '').toLowerCase();
                inputGallery.slice().filter(i => !q || i.name.toLowerCase().includes(q)).sort((a,b) => a.name.localeCompare(b.name)).forEach(item => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = item.id;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${item.name}</span>`;
                    row.addEventListener('click', () => {
                        const current = addInputListDrawer.querySelector('.drawer-row.selected');
                        const isSame = current && current.dataset.value === String(item.id);
                        if (isSame) {
                            setSelectedClass(addInputListDrawer, null);
                        } else {
                            const content = item.content;
                            const start = mainEditor.selectionStart;
                            const end = mainEditor.selectionEnd;
                            const text = mainEditor.value;
                            mainEditor.value = text.substring(0, start) + content + text.substring(end);
                            mainEditor.focus();
                            mainEditor.setSelectionRange(start + content.length, start + content.length);
                            mainEditor.dispatchEvent(new Event('input', { bubbles: true }));
                            setSelectedClass(addInputListDrawer, `[data-value=\"${CSS.escape(item.id)}\"]`);
                        }
                    });
                    addInputListDrawer.appendChild(row);
                });
            };

            // Removed dock icon highlight behavior per request.

            // --- Drawer searches and add actions ---
            // Search inputs
            const projectSearchEl = document.getElementById('project-search-input');
            if (projectSearchEl) projectSearchEl.addEventListener('input', renderProjectListDrawer);
            const llmSearchEl = document.getElementById('llm-search-input');
            if (llmSearchEl) llmSearchEl.addEventListener('input', renderLlmListDrawer);
            const githubSearchEl = document.getElementById('github-search-input');
            if (githubSearchEl) githubSearchEl.addEventListener('input', renderGithubListDrawer);
            const tagsSearchEl = document.getElementById('tags-search-input');
            if (tagsSearchEl) tagsSearchEl.addEventListener('input', renderTagsListDrawer);
            const xmlSearchEl = document.getElementById('xml-search-input');
            if (xmlSearchEl) xmlSearchEl.addEventListener('input', renderXmlTagsListDrawer);
            const varSearchEl = document.getElementById('var-search-input');
            if (varSearchEl) varSearchEl.addEventListener('input', renderVarLibraryListDrawer);
            const inputSearchEl = document.getElementById('input-search-input');
            if (inputSearchEl) inputSearchEl.addEventListener('input', renderAddInputListDrawer);

            // Add buttons
            const projectAddBtn = document.getElementById('project-add-btn');
            if (projectAddBtn) projectAddBtn.addEventListener('click', () => {
                const name = (prompt('New project name:') || '').trim();
                if (!name) return;
                if (!projectNames.includes(name)) {
                    projectNames.push(name);
                    saveProjectNamesToStorage();
                    updateGlobalList('projects', projectNames);
                }
                // Update hidden datalist so imports and others see it immediately
                const datalist = document.getElementById('project-list-aside');
                if (datalist) {
                    const exists = [...datalist.options].some(o => o.value === name);
                    if (!exists) {
                        const opt = document.createElement('option');
                        opt.value = name;
                        datalist.appendChild(opt);
                    }
                }
                renderProjectListDrawer();
            });

            const tagsAddBtn = document.getElementById('tags-add-btn');
            if (tagsAddBtn) tagsAddBtn.addEventListener('click', () => {
                let tag = (prompt('New tag (with or without #):') || '').trim();
                if (!tag) return;
                if (!tag.startsWith('#')) tag = `#${tag}`;
                const GENERAL_TAGS_LIB_KEY = 'promptManagerApp_generalTagsLib';
                let generalTagsLib = [];
                try { generalTagsLib = JSON.parse(localStorage.getItem(GENERAL_TAGS_LIB_KEY) || '[]'); } catch {}
                if (!generalTagsLib.includes(tag)) {
                    generalTagsLib.push(tag);
                    try { localStorage.setItem(GENERAL_TAGS_LIB_KEY, JSON.stringify(generalTagsLib)); } catch {}
                    updateGlobalList('general_tags_library', generalTagsLib);
                }
                renderTagsListDrawer();
            });

            // --- LÓGICA DO GERENCIADOR DE LISTAS ---
            // Persisted expanded state for LLM groups inside List Manager
            let expandedLlmManagerGroups = new Set();

            const renderListManager = () => {
                xmlTagsManagerContainer.innerHTML = '';
                varLibraryManagerContainer.innerHTML = '';
                generalTagsManagerContainer.innerHTML = '';
                llmManagerContainer.innerHTML = '';

                const createManagerItemEl = (value, type, options = {}) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'manager-tag flex justify-between items-center';
                    itemEl.dataset.value = value;
                    itemEl.dataset.type = type;
                    if (options.category) {
                        itemEl.dataset.category = options.category;
                    }
                    itemEl.innerHTML = `
                        <span class="truncate" contenteditable="true">${value}</span>
                        <button class="remove-tag-btn p-1">&times;</button>
                    `;
                    return itemEl;
                };

                xmlTags.sort().forEach(tag => xmlTagsManagerContainer.appendChild(createManagerItemEl(tag, 'xml')));
                varLibrary.sort().forEach(tag => varLibraryManagerContainer.appendChild(createManagerItemEl(tag, 'var')));
                // Combine used tags with library-only general tags so newly added appear immediately
                const GENERAL_TAGS_LIB_KEY = 'promptManagerApp_generalTagsLib';
                let generalTagsLib = [];
                try { generalTagsLib = JSON.parse(localStorage.getItem(GENERAL_TAGS_LIB_KEY) || '[]'); } catch {}
                const combinedGeneral = Array.from(new Set([...
                    getAllUniqueTags(),
                    ...generalTagsLib
                ])).sort();
                combinedGeneral.forEach(tag => generalTagsManagerContainer.appendChild(createManagerItemEl(tag, 'general')));

                Object.keys(llmList).sort().forEach(category => {
                    const categoryContainer = document.createElement('div');
                    categoryContainer.className = 'mb-3';
                    
                    const categoryHeader = document.createElement('div');
                    categoryHeader.className = 'manager-tag flex justify-between items-center font-bold bg-[#2a2a2a]';
                    categoryHeader.dataset.value = category;
                    categoryHeader.dataset.type = 'llm-category';
                    categoryHeader.innerHTML = `
                        <span class="toggle-icon">▶</span>
                        <span class="truncate" contenteditable="true">${category}</span>
                        <button class="remove-tag-btn p-1">&times;</button>
                    `;
                    
                    const modelsContainer = document.createElement('div');
                    modelsContainer.className = 'pl-2 mt-2 space-y-2';
                    
                    llmList[category].sort().forEach(model => {
                        modelsContainer.appendChild(createManagerItemEl(model, 'llm-model', { category }));
                    });
                    // Toggle expand/collapse state per category
                    let isExpanded = expandedLlmManagerGroups.has(category);
                    const applyExpand = () => {
                        const caret = categoryHeader.querySelector('.toggle-icon');
                        if (caret) caret.textContent = isExpanded ? '▼' : '▶';
                        modelsContainer.style.display = isExpanded ? '' : 'none';
                    };
                    applyExpand();
                    categoryHeader.addEventListener('click', (ev) => {
                        const isRemove = ev.target && ev.target.closest('.remove-tag-btn');
                        const isEditing = ev.target && ev.target.matches('[contenteditable="true"]');
                        if (isRemove || isEditing) return; // don't toggle when deleting or editing name
                        isExpanded = !isExpanded;
                        if (isExpanded) expandedLlmManagerGroups.add(category); else expandedLlmManagerGroups.delete(category);
                        applyExpand();
                    });
                    
                    categoryContainer.appendChild(categoryHeader);
                    categoryContainer.appendChild(modelsContainer);
                    llmManagerContainer.appendChild(categoryContainer);
                });
            };

            const updateListItem = (type, oldVal, newVal, options = {}) => {
                if (!newVal || oldVal === newVal) return;

        if (type === 'xml') {
                    const index = xmlTags.indexOf(oldVal);
                    if (index > -1 && !xmlTags.includes(newVal)) {
                        xmlTags[index] = newVal;
            saveXmlTagsToStorage();
            // Persist XML tags rename to Supabase
            updateGlobalList('xml_tags', xmlTags);
                    }
                } else if (type === 'var') {
                    const index = varLibrary.indexOf(oldVal);
                    if (index > -1 && !varLibrary.includes(newVal)) {
                        varLibrary[index] = newVal;
            saveVarLibraryToStorage();
            // Persist Var Library rename to Supabase
            updateGlobalList('var_library', varLibrary);
                    }
                } else if (type === 'general') {
                    prompts.forEach(p => {
                        if (p.tags && p.tags.includes(oldVal)) {
                            p.tags = p.tags.map(t => t === oldVal ? newVal : t);
                        }
                    });
                    savePromptsToStorage();
                    try { upsertItem('prompts', prompts.map(mapPromptUIToDb)); } catch (e) { console.error('Supabase upsert failed for prompts (general rename):', e); }
                } else if (type === 'llm-category') {
                    if (llmList[oldVal] && !llmList[newVal]) {
                        llmList[newVal] = llmList[oldVal];
                        delete llmList[oldVal];
                        saveLlmListToStorage();
                        updateGlobalList('llm_list', llmList);
                        populateLlmSelect();
                    }
                } else if (type === 'llm-model') {
                    const { category } = options;
                    if (llmList[category]) {
                        const index = llmList[category].indexOf(oldVal);
                        if (index > -1 && !llmList[category].includes(newVal)) {
                            llmList[category][index] = newVal;
                            prompts.forEach(p => { if (p.llm === oldVal) p.llm = newVal; });
                            saveLlmListToStorage();
                            // Persist updated llmList to Supabase
                            updateGlobalList('llm_list', llmList);
                            savePromptsToStorage();
                            try { upsertItem('prompts', prompts.map(mapPromptUIToDb)); } catch (e) { console.error('Supabase upsert failed for prompts (llm-model rename):', e); }
                            populateLlmSelect();
                        }
                    }
                }
                renderListManager();
            };

            // --- LÓGICA DA GALERIA DE INPUTS ---
            const renderInputGallery = () => {
                inputGalleryList.innerHTML = '';
                const selectedProject = (typeof inputGalleryProjectFilter !== 'undefined' && inputGalleryProjectFilter) ? inputGalleryProjectFilter.value : 'all';
                const list = inputGallery
                    .filter(i => selectedProject === 'all' ? true : (i.project || '') === selectedProject)
                    .sort((a,b) => a.name.localeCompare(b.name));
                list.forEach(input => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'input-gallery-item';
                    itemEl.dataset.id = input.id;
                    if(input.id === selectedInputId) {
                        itemEl.classList.add('selected');
                    }
                    itemEl.innerHTML = `
                        <span class="truncate flex-grow">${input.name}</span>
                        ${input.project ? `<span class="ml-2 text-xs text-[--text-muted-dark]">${input.project}</span>` : ''}
                        <button class="remove-btn p-1" data-action="delete-input" data-id="${input.id}">
                            <svg class="w-4 h-4 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    `;
                    inputGalleryList.appendChild(itemEl);
                });
            };

            const clearInputEditor = () => {
                selectedInputId = null;
                inputGalleryId.value = '';
                inputGalleryName.value = '';
                inputGalleryEditor.value = '';
                if (inputGalleryProjectAssign) populateProjectAssignList(inputGalleryProjectAssign);
                if (inputGalleryProjectAssign) {
                    const currentFilter = (inputGalleryProjectFilter && inputGalleryProjectFilter.value) ? inputGalleryProjectFilter.value : 'all';
                    inputGalleryProjectAssign.value = currentFilter === 'all' ? '' : currentFilter;
                }
                inputGalleryName.focus();
                renderInputGallery();
            };

            const loadInputForEditing = (id) => {
                const input = inputGallery.find(i => i.id === id);
                if (input) {
                    selectedInputId = id;
                    inputGalleryId.value = input.id;
                    inputGalleryName.value = input.name;
                    inputGalleryEditor.value = input.content;
                    if (inputGalleryProjectAssign) {
                        populateProjectAssignList(inputGalleryProjectAssign);
                        inputGalleryProjectAssign.value = input.project || '';
                    }
                    renderInputGallery();
                }
            };

            const saveCurrentInput = async () => {
                const name = inputGalleryName.value.trim();
                const content = inputGalleryEditor.value.trim();
                const project = inputGalleryProjectAssign ? (inputGalleryProjectAssign.value || '') : '';
                const currentId = selectedInputId;

                if (!name || !content) {
                    showModal('Error', 'Input name and content cannot be empty.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                    return;
                }

                let itemToSave;

                if (currentId) { // Editando um existente
                    const index = inputGallery.findIndex(i => i.id === currentId);
                    if (index > -1) {
                        inputGallery[index].name = name;
                        inputGallery[index].content = content;
                        inputGallery[index].project = project;
                        itemToSave = inputGallery[index];
                    }
                } else { // Criando um novo
                    const newId = getUUID();
                    itemToSave = { id: newId, name, content, project };
                    inputGallery.push(itemToSave);
                    selectedInputId = newId;
                }
                
                if (itemToSave) {
                    await upsertItem('input_gallery', itemToSave); // Salva apenas o item modificado/novo
                }

                saveInputGalleryToStorage();
                // Track new project names
                if (project && !projectNames.includes(project)) {
                    projectNames.push(project);
                    saveProjectNamesToStorage();
                    updateGlobalList('projects', projectNames);
                }
                // Refresh filter options after a possible new project
                if (inputGalleryProjectFilter) {
                    const prev = inputGalleryProjectFilter.value;
                    populateProjectList(inputGalleryProjectFilter);
                    inputGalleryProjectFilter.value = prev;
                }
                renderInputGallery();
            };

            const deleteInputFromGallery = async (id) => {
                // Deleta primeiro do Supabase
                await deleteItem('input_gallery', id);

                // Depois atualiza o estado local
                inputGallery = inputGallery.filter(i => i.id !== id);
                saveInputGalleryToStorage();
                
                if (selectedInputId === id) {
                    clearInputEditor();
                } else {
                    renderInputGallery();
                }
            };

            // --- LÓGICA DO NODE FLOW ---
            const renderNodeFlowPrompts = () => {
                nodeFlowPromptList.innerHTML = '';
                const selectedProject = nodeFlowProjectFilter.value;

                const filteredPrompts = selectedProject === 'all' 
                    ? prompts 
                    : prompts.filter(p => p.project === selectedProject);

                const groupedPrompts = filteredPrompts.reduce((acc, p) => {
                    if (!acc[p.promptId]) {
                        acc[p.promptId] = { title: p.title, project: p.project, versions: [] };
                    }
                    acc[p.promptId].versions.push(p);
                    return acc;
                }, {});

                Object.values(groupedPrompts).forEach(group => {
                    group.versions.sort((a, b) => parseFloat(b.version) - parseFloat(a.version)).forEach(version => {
                         const card = document.createElement('div');
                         card.className = 'node-flow-prompt-card p-2 rounded-md';
                         card.draggable = true;
                         card.dataset.versionId = version.id;
                         card.innerHTML = `
                             <h4 class="font-semibold text-sm truncate">${version.title} (v${version.version})</h4>
                             <p class="text-xs text-[--text-muted-dark] truncate">${version.project || 'No Project'}</p>
                         `;
                         nodeFlowPromptList.appendChild(card);
                    });
                });
            };
            
            const renderFlowNodes = () => {
                nodeFlowContent.innerHTML = '';
                flowNodes.forEach(nodeData => {
                    const nodeEl = document.createElement('div');
                    nodeEl.className = 'flow-node gallery-card standard-card bg-[--card-bg-dark] border border-[--border-dark] rounded-md p-3 flex flex-col text-xs text-[--text-dark]';
                    nodeEl.id = `flow-node-${nodeData.id}`;
                    nodeEl.style.left = `${nodeData.x}px`;
                    nodeEl.style.top = `${nodeData.y}px`;
                    nodeEl.dataset.nodeId = nodeData.id;

                    const prompt = prompts.find(p => p.id === nodeData.promptId);
                    if (prompt) {
                        let dependencyTitle = 'N/A';
                         if (prompt.parentId) {
                             const parentPrompt = prompts.find(p => p.id === prompt.parentId);
                             if (parentPrompt) dependencyTitle = `${parentPrompt.title} (v${parentPrompt.version})`;
                         }
                        const depCount = Array.isArray(prompt.dependencies) ? prompt.dependencies.length : (prompt.parentId ? 1 : 0);
                        nodeEl.innerHTML = `
                            <div class="flex items-center gap-2 mb-1">
                                <h3 class="font-bold text-base truncate pr-2 flex-1 min-w-0" style="color: var(--accent-fuchsia);">${prompt.title}</h3>
                                <span class="text-xs font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5 shrink-0">v${prompt.version}</span>
                            </div>
                            <div class="mb-1">
                                <span class="text-[10px] font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5">${depCount} ${depCount === 1 ? 'dependency' : 'dependencies'}</span>
                            </div>
                            <div class="space-y-1 flex-grow">
                                <p><strong class="text-[--text-muted-dark] font-normal">Project:</strong> ${prompt.project || 'N/A'}</p>
                                <p><strong class="text-[--text-muted-dark] font-normal">LLM:</strong> ${prompt.llm || 'N/A'}</p>
                            </div>
                            <div class="mt-3 pt-2 border-t border-[--border-dark] grid grid-cols-3 gap-2 text-center font-mono">
                                <div><p class="text-[--text-muted-dark] text-xs">Temp</p><p class="font-semibold text-sm">${prompt.temperature}</p></div>
                                <div><p class="text-[--text-muted-dark] text-xs">Top P</p><p class="font-semibold text-sm">${prompt.topP}</p></div>
                                <div><p class="text-[--text-muted-dark] text-xs">Effort</p><p class="font-semibold text-sm">${prompt.effort}</p></div>
                            </div>
                            <div class="connector output" data-node-id="${nodeData.id}"></div>
                        `;
                    } else {
                         nodeEl.innerHTML = `Prompt not found`;
                    }
                    nodeFlowContent.appendChild(nodeEl);
                });
            }

            const renderFlowConnections = () => {
                const svg = d3.select("#connections-group");
                svg.selectAll("path").remove();
                
                // Pega a posição do canvas para converter as coordenadas do viewport
                const canvasRect = nodeFlowCanvas.getBoundingClientRect();
            
                flowConnections.forEach(conn => {
                    const sourceNodeEl = document.getElementById(`flow-node-${conn.source}`);
                    const targetNodeEl = document.getElementById(`flow-node-${conn.target}`);
                    if (sourceNodeEl && targetNodeEl) {
                        const sourceRect = sourceNodeEl.getBoundingClientRect();
                        const targetRect = targetNodeEl.getBoundingClientRect();
            
                        const startX = sourceRect.right - canvasRect.left;
                        const startY = sourceRect.top + (sourceRect.height / 2) - canvasRect.top;
                        const endX = targetRect.left - canvasRect.left;
                        const endY = targetRect.top + (targetRect.height / 2) - canvasRect.top;
            
                        svg.append('path')
                            .attr('d', `M ${startX} ${startY} C ${startX + 60} ${startY} ${endX - 60} ${endY} ${endX} ${endY}`)
                            .attr('class', 'connection-line')
                            .attr('data-source', conn.source)
                            .attr('data-target', conn.target);
                    }
                });
            }
            
            const renderSavedFlowsList = () => {
                savedFlowsDropdown.innerHTML = '<option value="">Load a saved flow...</option>';
                savedFlows.forEach(flow => {
                    const option = document.createElement('option');
                    option.value = flow.name;
                    option.textContent = flow.name;
                    savedFlowsDropdown.appendChild(option);
                });
            };

            const loadFlow = (flowName) => {
                const flow = savedFlows.find(f => f.name === flowName);
                if (flow) {
                    flowNodes = flow.nodes;
                    flowConnections = flow.connections;
                    renderFlowNodes();
                    renderFlowConnections();
                    // Update delete button based on content loaded
                    if (typeof refreshDeleteFlowState === 'function') refreshDeleteFlowState();
                }
            };

            // --- MANIPULADORES DE EVENTOS ---
            versionsHistoryList.addEventListener('click', (e) => {
                const target = e.target;
                const item = target.closest('.version-item');
                const header = target.closest('.prompt-group-header');
                const deleteGroupBtn = target.closest('[data-action="delete-group"]');

                if (deleteGroupBtn) {
                    e.stopPropagation();
                    const promptId = deleteGroupBtn.dataset.promptId;
                    showDeleteModal('group', promptId);
                } else if (header) {
                    const promptId = header.dataset.promptId;
                    if (expandedPromptGroups.has(promptId)) {
                        expandedPromptGroups.delete(promptId);
                    } else {
                        expandedPromptGroups.add(promptId);
                    }
                    renderVersionsList();
                } else if (target.matches('input[type="checkbox"]')) {
                    const versionId = target.dataset.id;
                    const promptId = target.dataset.promptId;
                    
                    if (target.checked) {
                        if (activeComparisonPromptId !== null && activeComparisonPromptId !== promptId) {
                            versionsToCompare.clear();
                            activeComparisonPromptId = null;
                        }
                        
                        versionsToCompare.add(versionId);
                        activeComparisonPromptId = promptId;

                        if (versionsToCompare.size > 2) {
                            const firstId = versionsToCompare.values().next().value;
                            versionsToCompare.delete(firstId);
                        }
                    } else {
                        versionsToCompare.delete(versionId);
                        if (versionsToCompare.size === 0) {
                            activeComparisonPromptId = null;
                        }
                    }

                    document.querySelectorAll('#versions-history-list input[type="checkbox"]').forEach(cb => {
                        const cbVersionId = cb.dataset.id;
                        const cbPromptId = cb.dataset.promptId;
                        cb.checked = versionsToCompare.has(cbVersionId);
                        if (activeComparisonPromptId !== null) {
                            cb.disabled = String(cbPromptId) !== String(activeComparisonPromptId);
                        } else {
                            cb.disabled = false;
                        }
                    });

                    compareVersionsBtn.disabled = versionsToCompare.size !== 2;

                } else if (item) {
                    const actionTarget = target.closest('[data-action="select"]');
                     if (actionTarget) {
                         loadVersionIntoEditor(actionTarget.dataset.id);
                     }
                }
            });

            statusContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.status-option');
                if(target) updateStatusSelectorUI(target.dataset.status);
            });

            statusFilterContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.filter-tag-btn');
                if (target) {
                    activeStatusFilter = target.dataset.filter;
                    updateStatusFilterUI();
                    renderVersionsList();
                }
            });

            mainEditor.addEventListener('input', () => {
                updateEditorStats();
                renderVariables();
                renderNavigationMap();
                updateSnippetButtons();
            });
            mainEditor.addEventListener('scroll', updateSnippetButtons);

            searchInput.addEventListener('input', () => renderVersionsList());

            copyPromptBtn.addEventListener('click', () => {
                let textToCopy = mainEditor.value;
                document.querySelectorAll('#variables-container input').forEach(input => {
                    const varName = input.name;
                    const varValue = input.value;
                    textToCopy = textToCopy.replace(new RegExp(`\\{\\{${varName}\\}\\}`, 'g'), varValue);
                });
                
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                textArea.style.position = 'fixed';
                textArea.style.top = '-9999px';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        copyPromptBtn.classList.add('text-green-500');
                        setTimeout(() => {
                            copyPromptBtn.classList.remove('text-green-500');
                        }, 2000);
                    }
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
                document.body.removeChild(textArea);
            });

            deleteVersionBtn.addEventListener('click', () => {
                if (selectedVersionId) showDeleteModal('version', selectedVersionId);
                else showValidationAlert('No version selected to delete.');
            });

            addPromptBtn.addEventListener('click', clearEditorForNewPrompt);
            addMajorVersionBtn.addEventListener('click', () => saveVersion(true));
            addMinorVersionBtn.addEventListener('click', () => saveVersion(false));
            forkVersionBtn.addEventListener('click', forkVersion);
            if (llmSelect) llmSelect.addEventListener('change', () => {
                // When model changes, re-render model-specific settings using dynamic schema
                const current = selectedVersionId ? prompts.find(p => p.id === selectedVersionId)?.modelSettings : {};
                renderDynamicSettings(current || {});
            });
            const saveChanges = async () => {
                if (!selectedVersionId) {
                    showValidationAlert('No prompt selected to save changes.');
                    return;
                }
                const promptIndex = prompts.findIndex(p => p.id === selectedVersionId);
                if (promptIndex === -1) return;

                const promptToUpdate = { ...prompts[promptIndex] }; // Cria uma cópia para editar

                promptToUpdate.title = titleInput.value.trim();
                promptToUpdate.project = projectInput.value.trim();
                promptToUpdate.content = mainEditor.value;
                promptToUpdate.comments = commentsTextarea.value;
                promptToUpdate.llm = llmSelect.value;
                promptToUpdate.status = document.querySelector('.status-option.active')?.dataset.status || promptToUpdate.status;
                // Temperature/TopP/Effort now come from dynamic settings below
                promptToUpdate.date = new Date().toISOString();
                promptToUpdate.tags = [...tagsContainer.querySelectorAll('.prompt-tag span')].map(span => span.textContent);
                // Persist dependencies edited via the bottom bar
                promptToUpdate.dependencies = currentDependencies.map(String);
                promptToUpdate.parentId = (promptToUpdate.dependencies.length === 1) ? promptToUpdate.dependencies[0] : null;
                // Persist GitHub repo selection at prompt level
                if (currentGithubRepo && currentGithubRepo.id) {
                    promptToUpdate.githubRepo = currentGithubRepo.id;
                    promptToUpdate.githubRepoFull = currentGithubRepo.full || '';
                } else {
                    promptToUpdate.githubRepo = '';
                    promptToUpdate.githubRepoFull = '';
                }
                // Persist GitHub file path if set
                if (typeof commitFilePathInput !== 'undefined' && commitFilePathInput?.value) {
                    promptToUpdate.githubFilePath = commitFilePathInput.value.trim();
                } else if (lastImportedGitFilePath) {
                    promptToUpdate.githubFilePath = lastImportedGitFilePath;
                }

                // Merge dynamic settings back into legacy fields
                const dyn = collectDynamicSettings();
                promptToUpdate.temperature = dyn.temperature ?? promptToUpdate.temperature;
                promptToUpdate.topP = dyn.topP ?? promptToUpdate.topP;
                if (dyn.effort !== undefined) promptToUpdate.effort = effortLevels[dyn.effort] || promptToUpdate.effort;
                promptToUpdate.modelSettings = dyn;

                await upsertItem('prompts', mapPromptUIToDb(promptToUpdate)); // Salva no Supabase

                prompts[promptIndex] = promptToUpdate; // Atualiza o estado local
                renderVersionsList();
                updateSnippetButtons();
            };

            document.getElementById('save-changes-btn').addEventListener('click', saveChanges);
            // Dependency manager events
            if (editDependenciesBtn) {
                editDependenciesBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (dependenciesDropdown.classList.contains('hidden')) openDependenciesDropdown();
                    else closeDependenciesDropdown();
                });
            }
            if (depsCancelBtn) depsCancelBtn.addEventListener('click', closeDependenciesDropdown);
            if (depsApplyBtn) depsApplyBtn.addEventListener('click', () => {
                const checked = [...dependenciesList.querySelectorAll('input[type="checkbox"]:checked')].map(cb => cb.dataset.id);
                renderDependencyBar(checked);
                updateSnippetButtons();
                closeDependenciesDropdown();
            });
            if (dependenciesSearch) dependenciesSearch.addEventListener('input', () => renderDependenciesDropdown(dependenciesSearch.value));
            // Close dropdown on outside click
            document.addEventListener('click', (e) => {
                const pop = document.getElementById('dependencies-popover');
                if (!pop) return;
                if (!pop.contains(e.target)) closeDependenciesDropdown();
            });
            downloadJsonBtn.addEventListener('click', () => downloadFile('json'));
            downloadMdBtn.addEventListener('click', () => downloadFile('md'));
            downloadTxtBtn.addEventListener('click', () => downloadFile('txt'));

            // Legacy sliders removed; dynamic settings UI handles values now
            
            // --- Eventos da Galeria e Modais ---
            if (dashboardBtn) dashboardBtn.addEventListener('click', () => {
                if (dashboardModal) dashboardModal.classList.remove('hidden');
            });
            galleryBtn.addEventListener('click', () => {
                renderGallery();
                galleryModal.classList.remove('hidden');
            });

            closeGalleryBtn.addEventListener('click', () => galleryModal.classList.add('hidden'));
            galleryModal.addEventListener('click', (e) => {
                if (e.target === galleryModal) galleryModal.classList.add('hidden');
            });

            projectsBtn.addEventListener('click', () => {
                renderProjectsView();
                projectsModal.classList.remove('hidden');
            });
            closeProjectsBtn.addEventListener('click', () => projectsModal.classList.add('hidden'));
            projectsModal.addEventListener('click', (e) => {
                if (e.target === projectsModal) projectsModal.classList.add('hidden');
            });
            projectsListContainer.addEventListener('click', (e) => {
                const rowTarget = e.target.closest('tr[data-id]');
                const commentBtn = e.target.closest('[data-action="view-comments"]');

                if (commentBtn) {
                    e.stopPropagation(); // Impede que o clique na linha seja disparado
                    const promptId = commentBtn.dataset.id;
                    showCommentsViewer(promptId);
                } else if (rowTarget) {
                    const promptId = rowTarget.dataset.id;
                    loadVersionIntoEditor(promptId);
                    projectsModal.classList.add('hidden');
                }
            });

            templatesBtn.addEventListener('click', () => {
                if (templatesProjectFilter) {
                    const prev = templatesProjectFilter.value;
                    populateProjectList(templatesProjectFilter);
                    templatesProjectFilter.value = prev || 'all';
                }
                renderTemplatesGrid();
                templatesModal.classList.remove('hidden');
            });
            closeTemplatesBtn.addEventListener('click', () => templatesModal.classList.add('hidden'));
            templatesModal.addEventListener('click', (e) => {
                if (e.target === templatesModal) templatesModal.classList.add('hidden');
            });
            if (templatesProjectFilter) templatesProjectFilter.addEventListener('change', renderTemplatesGrid);
            
            templatesGridContainer.addEventListener('click', (e) => {
                const card = e.target.closest('.gallery-card');
                if (!card) return;

                const actionButton = e.target.closest('[data-action]');
                const templateId = card.dataset.id;
                const template = templates.find(t => String(t.id) === String(templateId));
                if (!template) return;

                const action = actionButton ? actionButton.dataset.action : 'load-template';

                if (action === 'load-template') {
                    clearEditorForNewPrompt();
                    titleInput.value = template.title;
                    projectInput.value = template.project;
                    mainEditor.value = template.content;
                    llmSelect.value = template.llm;
                    // Apply dependencies from template (multi) or legacy parentId
                    const tDeps = (template.dependencies && template.dependencies.length) ? template.dependencies : (template.parentId ? [template.parentId] : []);
                    renderDependencyBar(tDeps);
                    updateSlidersUI(template);
                    updateEditorStats();
                    renderVariables();
                    renderPromptTags(template.tags);
                    templatesModal.classList.add('hidden');
                    updateSnippetButtons();
                } else if (action === 'delete-template') {
                    showModal(
                        'Confirm Deletion',
                        `Are you sure you want to delete the template "${template.name}"?`,
                        [
                            { text: 'Cancel', className: 'action-button', onClick: hideModal },
                            { 
                                text: 'Delete', 
                                className: 'action-button bg-[--accent-red] text-white border-[--accent-red-hover] hover:bg-[--accent-red-hover]', 
                                onClick: async () => {
                                    templates = templates.filter(t => t.id !== templateId);
                                    saveTemplatesToStorage();
                                    await deleteItem('templates', templateId);
                                    renderTemplatesGrid();
                                    hideModal();
                                }
                            }
                        ]
                    );
                }
            });

            saveAsTemplateBtn.addEventListener('click', () => {
                const content = mainEditor.value.trim();
                if (!content) {
                    showValidationAlert('The editor is empty. Write something to save as a template.');
                    return;
                }

                const currentTags = [...tagsContainer.querySelectorAll('.prompt-tag span')].map(span => span.textContent);

                const dynNow = collectDynamicSettings();
                const templateData = {
                    title: titleInput.value.trim(),
                    project: projectInput.value.trim(),
                    content: content,
                    llm: llmSelect.value,
                    temperature: dynNow.temperature ?? 0.7,
                    topP: dynNow.topP ?? 0.9,
                    effort: dynNow.effort !== undefined ? effortLevels[dynNow.effort] : 'Medium',
                    parentId: (currentDependencies.length === 1) ? currentDependencies[0] : null,
                    dependencies: currentDependencies.map(String),
                    tags: currentTags
                };

                showModal(
                    'Save as Template',
                    'Enter a name for this template:',
                    [
                        { text: 'Cancel', className: 'action-button', onClick: hideModal },
                        { 
                            text: 'Save', 
                            className: 'action-button primary', 
                            onClick: async () => {
                                const templateName = document.getElementById('confirm-modal-input').value.trim();
                                if (templateName) {
                                    const newTemplate = { ...templateData, name: templateName, id: Date.now() };
                                    templates.push(newTemplate);
                                    saveTemplatesToStorage();
                                    await upsertItem('templates', newTemplate);
                                    hideModal();
                                    setTimeout(() => {
                                        // Ensure the success modal can be closed properly
                                        showModal('Success', `Template "${templateName}" saved.`, [
                                            { text: 'OK', className: 'action-button primary', onClick: hideModal }
                                        ]);
                                    }, 300);
                                }
                            } 
                        }
                    ],
                    { showInput: true, inputPlaceholder: 'Template name...' }
                );
            });

            dependencyTagContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.dependency-tag');
                if (target) {
                    const dependencyId = target.dataset.dependencyId;
                    showDependencyViewer(dependencyId);
                }
            });

            closeDependencyViewerBtn.addEventListener('click', () => dependencyViewerModal.classList.add('hidden'));
            dependencyViewerModal.addEventListener('click', (e) => {
                if (e.target === dependencyViewerModal) dependencyViewerModal.classList.add('hidden');
            });
            
            closeCommentsViewerBtn.addEventListener('click', () => commentsViewerModal.classList.add('hidden'));
            commentsViewerModal.addEventListener('click', (e) => {
                if (e.target === commentsViewerModal) commentsViewerModal.classList.add('hidden');
            });

            readModeBtn.addEventListener('click', toggleReadMode);
            readModeModal.addEventListener('click', (e) => {
                if (e.target === readModeModal) {
                    toggleReadMode();
                }
            });
            
            compareVersionsBtn.addEventListener('click', () => {
                if (!hasDiff) {
                    showModal('Unavailable', 'Diff engine not loaded. Connect to the internet and reload to compare versions.', [
                        { text: 'OK', className: 'action-button primary', onClick: hideModal }
                    ]);
                    return;
                }
                const [id1, id2] = Array.from(versionsToCompare);
                let version1 = prompts.find(p => String(p.id) === String(id1));
                let version2 = prompts.find(p => String(p.id) === String(id2));

                if (version1 && version2) {
                    // Garante que a versão 1 seja sempre a mais antiga
                    if (parseFloat(version1.version) > parseFloat(version2.version)) {
                        [version1, version2] = [version2, version1];
                    }

                    const dmp = new diff_match_patch();
                    
                    const diff1 = dmp.diff_main(version1.content, version2.content);
                    dmp.diff_cleanupSemantic(diff1);
                    
                    const diff2 = dmp.diff_main(version2.content, version1.content);
                    dmp.diff_cleanupSemantic(diff2);
                    
                    const cleanHtml = (html) => {
                        return html
                            .replace(/&para;/g, '')
                            .replace(/ style="background:(#e6ffe6|#ffe6e6);"/gi, '');
                    };

                    diffModalTitle.textContent = `Comparing v${version1.version} vs v${version2.version}`;
                    diffTitleA.textContent = `Version ${version1.version}`;
                    diffTitleB.textContent = `Version ${version2.version}`;
                    const metaA = `LLM: ${version1.llm || 'N/A'} · Temp: ${version1.temperature ?? 'N/A'} · Top P: ${version1.topP ?? 'N/A'} · Effort: ${version1.effort || 'N/A'} · Repo: ${version1.githubRepoFull || version1.githubRepo || 'N/A'}`;
                    const metaB = `LLM: ${version2.llm || 'N/A'} · Temp: ${version2.temperature ?? 'N/A'} · Top P: ${version2.topP ?? 'N/A'} · Effort: ${version2.effort || 'N/A'} · Repo: ${version2.githubRepoFull || version2.githubRepo || 'N/A'}`;
                    document.getElementById('diff-meta-a').textContent = metaA;
                    document.getElementById('diff-meta-b').textContent = metaB;
                    document.getElementById('diff-comments-a').textContent = (version1.comments && version1.comments.trim()) ? `Comments: ${version1.comments}` : '';
                    document.getElementById('diff-comments-b').textContent = (version2.comments && version2.comments.trim()) ? `Comments: ${version2.comments}` : '';
                    diffPanelA.innerHTML = cleanHtml(dmp.diff_prettyHtml(diff1));
                    diffPanelB.innerHTML = cleanHtml(dmp.diff_prettyHtml(diff2));

                    diffModal.classList.remove('hidden');
                }
            });
            closeDiffModalBtn.addEventListener('click', () => diffModal.classList.add('hidden'));
            diffModal.addEventListener('click', (e) => {
                if (e.target === diffModal) {
                    diffModal.classList.add('hidden');
                }
            });

            // --- EVENTOS DE BUSCA E SUBSTITUIÇÃO ---
            findBtn.addEventListener('click', () => toggleFindReplaceBar(true));
            closeFindBtn.addEventListener('click', () => toggleFindReplaceBar(false));
            findInput.addEventListener('input', executeFind);
            findInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    goToNextMatch();
                }
            });
            nextBtn.addEventListener('click', goToNextMatch);
            prevBtn.addEventListener('click', goToPrevMatch);
            replaceBtn.addEventListener('click', executeReplace);
            replaceAllBtn.addEventListener('click', executeReplaceAll);

            // --- EVENTOS DO GRÁFICO ---
            graphViewBtn.addEventListener('click', () => {
                if (!hasD3) {
                    showModal('Unavailable', 'Graph requires D3 which is not loaded (offline).', [
                        { text: 'OK', className: 'action-button primary', onClick: hideModal }
                    ]);
                    return;
                }
                dependencyGraphModal.classList.remove('hidden');
                populateGraphFilters();
                // Pequeno delay para garantir que o container tenha as dimensões corretas antes de renderizar
                setTimeout(() => renderDependencyGraph({ project: graphProjectFilter.value }), 50); 
            });
            closeDependencyGraphBtn.addEventListener('click', () => dependencyGraphModal.classList.add('hidden'));
            dependencyGraphModal.addEventListener('click', e => {
                if (e.target === dependencyGraphModal) {
                    dependencyGraphModal.classList.add('hidden');
                }
            });
            graphProjectFilter.addEventListener('change', () => {
                const selectedProject = graphProjectFilter.value;
                renderDependencyGraph({ project: selectedProject });
            });
            createConnectionBtn.addEventListener('click', (e) => {
                isCreatingConnection = !isCreatingConnection;
                e.currentTarget.classList.toggle('active', isCreatingConnection);
                // Se o modo de conexão for desativado, reseta o estado
                if (!isCreatingConnection) {
                    firstNodeForConnection = null;
                    d3.selectAll('.graph-node').classed('selected-for-connection', false);
                }
            });
            deleteConnectionBtn.addEventListener('click', async () => {
                if (selectedLinkForDeletion) {
                    const childId = String(selectedLinkForDeletion.target.id);
                    const parentIdToRemove = String(selectedLinkForDeletion.source.id);
                    const childPrompt = prompts.find(p => String(p.id) === childId);
                    if (childPrompt) {
                        if (!Array.isArray(childPrompt.dependencies)) childPrompt.dependencies = childPrompt.parentId ? [childPrompt.parentId] : [];
                        childPrompt.dependencies = childPrompt.dependencies.filter(id => String(id) !== parentIdToRemove);
                        childPrompt.parentId = (childPrompt.dependencies.length === 1) ? childPrompt.dependencies[0] : null;
                        savePromptsToStorage();
                        await upsertItem('prompts', mapPromptUIToDb(childPrompt));
                        renderDependencyGraph({ project: graphProjectFilter.value });
                        if (selectedVersionId && String(selectedVersionId) === String(childPrompt.id)) {
                            renderDependencyBar(childPrompt.dependencies);
                        }
                        selectedLinkForDeletion = null;
                        deleteConnectionBtn.disabled = true;
                    }
                }
            });

            // --- EVENTOS DAS TAGS ---
            tagsContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.remove-tag-btn');
                if (target) {
                    target.parentElement.remove();
                }
            });
            
            projectInput.addEventListener('input', () => renderPromptTags([...tagsContainer.querySelectorAll('.prompt-tag:not(.auto-tag) span')].map(s => s.textContent)));
            llmSelect.addEventListener('change', () => renderPromptTags([...tagsContainer.querySelectorAll('.prompt-tag:not(.auto-tag) span')].map(s => s.textContent)));

            // --- EVENTOS DA BIBLIOTECA DE VARIÁVEIS E XML ---
            const setupDropdown = (input, dropdown, library, onSelect, onAdd) => {
                const renderDropdown = (showAll = false) => {
                    const filter = input.value.toLowerCase();
                    const items = library(); // Get the items from the provided function
                    const itemsToShow = (showAll) ? items : items.filter(item => item.toLowerCase().includes(filter));
                    
                    dropdown.innerHTML = '';
                    if (itemsToShow.length > 0) {
                        itemsToShow.forEach(item => {
                            const itemEl = document.createElement('div');
                            itemEl.className = 'custom-dropdown-item';
                            itemEl.textContent = item;
                            itemEl.addEventListener('mousedown', (e) => { 
                                e.preventDefault();
                                onSelect(item);
                                input.value = '';
                                dropdown.classList.add('hidden');
                            });
                            dropdown.appendChild(itemEl);
                        });
                        dropdown.classList.remove('hidden');
                    } else {
                        dropdown.classList.add('hidden');
                    }
                };

                input.addEventListener('focus', () => renderDropdown(true));
                input.addEventListener('input', () => renderDropdown(false));
                input.addEventListener('blur', () => setTimeout(() => dropdown.classList.add('hidden'), 150));
                if(onAdd) {
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            onAdd();
                        }
                    });
                }
            };

            // Setup header Add actions (inputs removed, we prompt)
            const headerAddXmlBtn = document.getElementById('add-xml-tag-btn');
            const headerAddVarBtn = document.getElementById('add-var-library-btn');
            if (headerAddXmlBtn) headerAddXmlBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showModal('Add XML Tag', 'Enter a new XML tag name:', [
                    { text: 'Cancel', className: 'action-button', onClick: hideModal },
                    { text: 'Add', className: 'action-button primary', onClick: () => { addCurrentXmlTag(); hideModal(); renderXmlTagsListDrawer(); } }
                ], { showInput: true, inputPlaceholder: 'tag-name' });
            });
            if (headerAddVarBtn) headerAddVarBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showModal('Add Variable', 'Enter a new variable name (with or without {{}}):', [
                    { text: 'Cancel', className: 'action-button', onClick: hideModal },
                    { text: 'Add', className: 'action-button primary', onClick: () => { addCurrentVarToLibrary(); hideModal(); renderVarLibraryListDrawer(); } }
                ], { showInput: true, inputPlaceholder: '{{var_name}}' });
            });
            
            // --- EVENTOS DO GERENCIADOR DE LISTAS ---
            listManagerBtn.addEventListener('click', () => {
                renderListManager();
                listManagerModal.classList.remove('hidden');
            });

            closeListManagerBtn.addEventListener('click', () => {
                listManagerModal.classList.add('hidden');
            });
            
            listManagerModal.addEventListener('click', (e) => {
                if (e.target === listManagerModal) {
                    listManagerModal.classList.add('hidden');
                }
            });

            listManagerModal.addEventListener('focusout', (e) => {
                const span = e.target;
                if (span.matches('.manager-tag span[contenteditable="true"]')) {
                    const parent = span.parentElement;
                    const oldVal = parent.dataset.value;
                    const newVal = span.textContent.trim();
                    const type = parent.dataset.type;
                    const category = parent.dataset.category;

                    if (newVal !== oldVal) {
                        updateListItem(type, oldVal, newVal, { category });
                    }
                }
            });

            listManagerModal.addEventListener('keydown', (e) => {
                const span = e.target;
                if (span.matches('.manager-tag span[contenteditable="true"]') && e.key === 'Enter') {
                    e.preventDefault();
                    span.blur();
                }
            });

            listManagerModal.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-tag-btn');

                if (removeBtn) {
                    const parent = removeBtn.parentElement;
                    const value = parent.dataset.value;
                    const type = parent.dataset.type;
                    const category = parent.dataset.category;

                    showModal(
                        'Confirm Deletion',
                        `Are you sure you want to delete the item "${value}"? This action cannot be undone.`,
                        [
                            { text: 'Cancel', className: 'action-button', onClick: async () => await hideModal },
                            { 
                                text: 'Delete', 
                                className: 'action-button bg-[--accent-red] text-white border-[--accent-red-hover] hover:bg-[--accent-red-hover]', 
                                onClick: async () => {
                                    let updatePrompts = false;
                                    switch (type) {
                                        case 'xml':
                                            xmlTags = xmlTags.filter(t => t !== value);
                                            saveXmlTagsToStorage();
                                            // Persist XML tags delete to Supabase
                                            updateGlobalList('xml_tags', xmlTags);
                                            break;
                                        case 'var':
                                            varLibrary = varLibrary.filter(t => t !== value);
                                            saveVarLibraryToStorage();
                                            // Persist Var Library delete to Supabase
                                            updateGlobalList('var_library', varLibrary);
                                            break;
                                        case 'llm-category': delete llmList[value]; saveLlmListToStorage(); populateLlmSelect(); break;
                                        case 'llm-model':
                                            if (llmList[category]) {
                                                llmList[category] = llmList[category].filter(m => m !== value);
                                                saveLlmListToStorage();
                                                updateGlobalList('llm_list', llmList);
                                                populateLlmSelect();
                                                updatePrompts = true;
                                            }
                                            break;
                                        case 'general':
                                            // Remove from all prompts and from general tags library cache
                                            updatePrompts = true;
                                            try {
                                                const GENERAL_TAGS_LIB_KEY = 'promptManagerApp_generalTagsLib';
                                                let generalTagsLib = JSON.parse(localStorage.getItem(GENERAL_TAGS_LIB_KEY) || '[]');
                                                if (generalTagsLib.includes(value)) {
                                                    generalTagsLib = generalTagsLib.filter(t => t !== value);
                                                    localStorage.setItem(GENERAL_TAGS_LIB_KEY, JSON.stringify(generalTagsLib));
                                                    updateGlobalList('general_tags_library', generalTagsLib);
                                                }
                                            } catch {}
                                            break;
                                    }

                                    if (updatePrompts) {
                                        prompts.forEach(p => {
                                            if (type === 'llm-model' && p.llm === value) p.llm = 'generic';
                                            if (type === 'general' && p.tags) p.tags = p.tags.filter(t => t !== value);
                                        });
                                        savePromptsToStorage();
                                        await upsertItem('prompts', prompts.map(mapPromptUIToDb));
                                        if (selectedVersionId) loadVersionIntoEditor(selectedVersionId);
                                        
                                    }
                                    
                                    renderListManager();
                                    hideModal();
                                }
                            }
                        ]
                    );
                }
            });

        addXmlTagManagerBtn.addEventListener('click', () => {
                const tagName = addXmlTagManagerInput.value.trim();
                if (tagName && !xmlTags.includes(tagName)) {
                    xmlTags.push(tagName);
                    saveXmlTagsToStorage();
            // Persist XML tags add to Supabase
            updateGlobalList('xml_tags', xmlTags);
                    addXmlTagManagerInput.value = '';
                    renderListManager();
                }
            });

            addVarLibraryManagerBtn.addEventListener('click', () => {
                let varName = addVarLibraryManagerInput.value.trim();
                if (varName) {
                    if (!varName.startsWith('{{') || !varName.endsWith('}}')) {
                        varName = `{{${varName.replace(/{{|}}/g, '')}}}`;
                    }
                    if (!varLibrary.includes(varName)) {
                        varLibrary.push(varName);
                        saveVarLibraryToStorage();
                        // Persist Var Library add to Supabase
                        updateGlobalList('var_library', varLibrary);
                        addVarLibraryManagerInput.value = '';
                        renderListManager();
                    }
                }
            });

            addLlmCategoryManagerBtn.addEventListener('click', () => {
                const categoryName = addLlmCategoryManagerInput.value.trim();
                if (categoryName && !llmList[categoryName]) {
                    llmList[categoryName] = [];
                    saveLlmListToStorage();
                    updateGlobalList('llm_list', llmList);
                    addLlmCategoryManagerInput.value = '';
                    renderListManager();
                    populateLlmSelect();
                }
            });

            // Add new General Tag (applies globally, adds to prompts only when used; here we maintain a synthetic list via union of prompts tags)
            addGeneralTagManagerBtn.addEventListener('click', () => {
                let tagName = addGeneralTagManagerInput.value.trim();
                if (!tagName) return;
                if (!tagName.startsWith('#')) tagName = `#${tagName}`;

                // If tag already exists among all prompts, just clear input and refresh list
                const existing = getAllUniqueTags();
                if (existing.includes(tagName)) {
                    addGeneralTagManagerInput.value = '';
                    renderListManager();
                    return;
                }

                // Otherwise, we add it to no prompt by default, but to keep it visible we can persist it in a pseudo library list in global_lists
                // Approach: store a dedicated list 'general_tags_library' to maintain available general tags not yet used
                // First, try to fetch from localStorage (mirroring global list cache if any), else start with []
                const GENERAL_TAGS_LIB_KEY = 'promptManagerApp_generalTagsLib';
                let generalTagsLib = [];
                try { generalTagsLib = JSON.parse(localStorage.getItem(GENERAL_TAGS_LIB_KEY) || '[]'); } catch {}
                if (!generalTagsLib.includes(tagName)) generalTagsLib.push(tagName);
                localStorage.setItem(GENERAL_TAGS_LIB_KEY, JSON.stringify(generalTagsLib));
                // Persist to Supabase if available using global_lists
                updateGlobalList('general_tags_library', generalTagsLib);

                addGeneralTagManagerInput.value = '';
                renderListManager();
            });

            // --- EVENTOS DO INPUT GALLERY ---
            inputGalleryBtn.addEventListener('click', () => {
                if (inputGalleryProjectFilter) populateProjectList(inputGalleryProjectFilter);
                if (inputGalleryProjectAssign) populateProjectAssignList(inputGalleryProjectAssign);
                renderInputGallery();
                clearInputEditor(); // Começa com um editor limpo
                inputGalleryModal.classList.remove('hidden');
            });

            closeInputGalleryBtn.addEventListener('click', () => {
                inputGalleryModal.classList.add('hidden');
            });

            inputGalleryModal.addEventListener('click', (e) => {
                if (e.target === inputGalleryModal) {
                    inputGalleryModal.classList.add('hidden');
                }
            });

            addNewInputBtn.addEventListener('click', clearInputEditor);
            saveInputGalleryBtn.addEventListener('click', saveCurrentInput);
            if (inputGalleryProjectFilter) inputGalleryProjectFilter.addEventListener('change', renderInputGallery);

            inputGalleryList.addEventListener('click', (e) => {
                const item = e.target.closest('.input-gallery-item');
                const deleteBtn = e.target.closest('[data-action="delete-input"]');

                if (deleteBtn) {
                    e.stopPropagation();
                    const idToDelete = deleteBtn.dataset.id;
                    deleteInputFromGallery(idToDelete);
                } else if (item) {
                    const idToLoad = item.dataset.id;
                    loadInputForEditing(idToLoad);
                }
            });
            
            // Add Input now uses the in-drawer list; dropdown removed

            // --- EVENTO DO SNIPPET COPY ---
            snippetButtonsOverlay.addEventListener('click', (e) => {
                const button = e.target.closest('.copy-snippet-btn');
                if (button) {
                    const index = parseInt(button.dataset.snippetIndex, 10);
                    if (snippets[index]) {
                        const textToCopy = snippets[index].content;
                        
                        const textArea = document.createElement('textarea');
                        textArea.value = textToCopy;
                        textArea.style.position = 'fixed';
                        textArea.style.opacity = '0';
                        document.body.appendChild(textArea);
                        textArea.select();
                        try {
                            document.execCommand('copy');
                            button.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>`;
                            button.classList.add('copied');
                            setTimeout(() => {
                                button.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>`;
                                button.classList.remove('copied');
                            }, 1500);
                        } catch (err) {
                            console.error('Failed to copy snippet:', err);
                        }
                        document.body.removeChild(textArea);
                    }
                }
            });


            // --- Evento do Mapa de Navegação ---
            navigationMap.addEventListener('click', (e) => {
                const target = e.target.closest('.nav-map-tag');
                if (target) {
                    const index = parseInt(target.dataset.index, 10);
                    mainEditor.focus();
                    mainEditor.setSelectionRange(index, index);
                }
            });

            // --- EVENTOS DO NODE FLOW ---
            const zoom = hasD3 ? d3.zoom()
                .scaleExtent([0.2, 2])
                .on("zoom", (event) => {
                    currentTransform = event.transform;
                    nodeFlowContent.style.transform = `translate(${currentTransform.x}px, ${currentTransform.y}px) scale(${currentTransform.k})`;
                    if (hasD3) d3.select("#connections-group").attr("transform", null); // Remove transform do grupo!
                    renderFlowConnections();
                }) : null;
                
            if (hasD3) {
                d3.select("#node-flow-canvas").call(zoom);
            }

            nodeFlowBtn.addEventListener('click', () => {
                if (!hasD3) {
                    showModal('Unavailable', 'Node Flow requires D3 which is not loaded (offline).', [
                        { text: 'OK', className: 'action-button primary', onClick: hideModal }
                    ]);
                    return;
                }
                populateProjectList(nodeFlowProjectFilter);
                renderNodeFlowPrompts();
                renderSavedFlowsList();
                // Always open empty: reset working canvas state
                flowNodes = [];
                flowConnections = [];
                renderFlowNodes();
                renderFlowConnections();
                if (deleteFlowBtn) deleteFlowBtn.disabled = true;
                nodeFlowModal.classList.remove('hidden');
            });
            closeNodeFlowBtn.addEventListener('click', () => nodeFlowModal.classList.add('hidden'));
            nodeFlowModal.addEventListener('click', (e) => {
                if (e.target === nodeFlowModal) {
                    nodeFlowModal.classList.add('hidden');
                }
            });
            nodeFlowProjectFilter.addEventListener('change', renderNodeFlowPrompts);

        saveFlowBtn.addEventListener('click', () => {
                showModal('Save Flow', 'Enter a name for this flow:', [
                    { text: 'Cancel', className: 'action-button', onClick: hideModal },
            { text: 'Save', className: 'action-button primary', onClick: async () => {
                        const flowName = confirmModalInput.value.trim();
                        if (flowName) {
                            const existing = savedFlows.findIndex(f => f.name === flowName);
                            const flowData = { name: flowName, nodes: flowNodes, connections: flowConnections };
                            if (existing > -1) {
                                savedFlows[existing] = flowData;
                            } else {
                                savedFlows.push(flowData);
                            }
                            saveFlowsToStorage();
                await upsertItem('node_flows', flowData);
                            renderSavedFlowsList();
                            savedFlowsDropdown.value = flowName;
                            hideModal();
                        }
                    }}
                ], { showInput: true, inputPlaceholder: 'My awesome flow...' });
            });

            savedFlowsDropdown.addEventListener('change', (e) => {
                const flowName = e.target.value;
                if (flowName) {
                    loadFlow(flowName);
                    // Enable delete even if no nodes (so user can remove saved record)
                    if (typeof refreshDeleteFlowState === 'function') refreshDeleteFlowState();
                }
            });

            nodeFlowPromptList.addEventListener('dragstart', (e) => {
                const target = e.target.closest('.node-flow-prompt-card');
                if(target) {
                    e.dataTransfer.setData('text/plain', target.dataset.versionId);
                    e.dataTransfer.effectAllowed = 'copy';
                }
            });

            nodeFlowCanvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });

            nodeFlowCanvas.addEventListener('drop', (e) => {
                e.preventDefault();
                const versionId = e.dataTransfer.getData('text/plain');
                const canvasRect = nodeFlowCanvas.getBoundingClientRect();
                
                const x = (e.clientX - canvasRect.left - currentTransform.x) / currentTransform.k;
                const y = (e.clientY - canvasRect.top - currentTransform.y) / currentTransform.k;

                const newNode = {
                    id: getUUID(),
                    promptId: versionId,
                    x: x - 140, // Centraliza o card no drop
                    y: y - 80,
                };
                flowNodes.push(newNode);
                renderFlowNodes();
                if (typeof refreshDeleteFlowState === 'function') refreshDeleteFlowState();
            });
            
            nodeFlowCanvas.addEventListener('mousedown', (e) => {
                if (e.target.closest('.flow-node')) return;
                nodeFlowCanvas.style.cursor = 'grabbing';
            });
            
            nodeFlowCanvas.addEventListener('mouseup', () => {
                 nodeFlowCanvas.style.cursor = 'grab';
            });

            nodeFlowContent.addEventListener('mousedown', (e) => {
                const nodeEl = e.target.closest('.flow-node');
                const connectorEl = e.target.closest('.connector');

                if (connectorEl) {
                    e.stopPropagation(); 
                    isDrawingConnection = true;
                    connectionStartNodeId = connectorEl.dataset.nodeId;
                    
                    const startNodeEl = document.getElementById(`flow-node-${connectionStartNodeId}`);
                    const startNodeData = flowNodes.find(n => n.id == connectionStartNodeId);

                    if (startNodeData) {
                        const sourceX = startNodeData.x + startNodeEl.offsetWidth;
                        const sourceY = startNodeData.y + startNodeEl.offsetHeight / 2;
                        const [startX, startY] = currentTransform.apply([sourceX, sourceY]);

                        tempLine = d3.select("#node-flow-connections")
                            .append('path')
                            .attr('d', `M ${startX} ${startY} C ${startX} ${startY} ${startX} ${startY} ${startX} ${startY}`)
                            .attr('class', 'connection-line')
                            .style('stroke-dasharray', '5, 5');
                    }

                } else if (nodeEl) {
                    e.stopPropagation(); 
                    isDraggingNode = true;
                    const nodeId = nodeEl.dataset.nodeId;
                    const nodeData = flowNodes.find(n => n.id == nodeId);

                    const moveHandler = (moveEvent) => {
                        if (!isDraggingNode) return;
                        nodeData.x += moveEvent.movementX / currentTransform.k;
                        nodeData.y += moveEvent.movementY / currentTransform.k;
                        nodeEl.style.left = `${nodeData.x}px`;
                        nodeEl.style.top = `${nodeData.y}px`;
                        renderFlowConnections();
                    };

                    const upHandler = () => {
                        isDraggingNode = false;
                        document.removeEventListener('mousemove', moveHandler);
                        document.removeEventListener('mouseup', upHandler);
                    };

                    document.addEventListener('mousemove', moveHandler);
                    document.addEventListener('mouseup', upHandler);
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDrawingConnection || !tempLine) return;
                const canvasRect = nodeFlowCanvas.getBoundingClientRect();
                const startNodeEl = document.getElementById(`flow-node-${connectionStartNodeId}`);
                const startNodeData = flowNodes.find(n => n.id == connectionStartNodeId);

                if (startNodeData && startNodeEl) {
                    const sourceX = startNodeData.x + startNodeEl.offsetWidth;
                    const sourceY = startNodeData.y + startNodeEl.offsetHeight / 2;
                    const [startX, startY] = currentTransform.apply([sourceX, sourceY]);

                    const endX = e.clientX - canvasRect.left;
                    const endY = e.clientY - canvasRect.top;
                    
                    tempLine.attr('d', `M ${startX} ${startY} C ${startX + 60} ${startY} ${endX - 60} ${endY} ${endX} ${endY}`);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (isDrawingConnection) {
                    const targetNodeEl = e.target.closest('.flow-node');
                    if (targetNodeEl && targetNodeEl.dataset.nodeId !== connectionStartNodeId) {
                        const targetNodeId = targetNodeEl.dataset.nodeId;
                        const exists = flowConnections.some(c => c.source == connectionStartNodeId && c.target == targetNodeId);
                        if (!exists) {
                            flowConnections.push({ source: connectionStartNodeId, target: targetNodeId });
                        }
                    }
                    if(tempLine) tempLine.remove();
                    isDrawingConnection = false;
                    connectionStartNodeId = null;
                    tempLine = null;
                    renderFlowConnections();
                }
            });

            // Helper: enable/disable Delete Flow button
            // Enable if there are nodes on canvas OR a saved flow is selected in dropdown
            const refreshDeleteFlowState = () => {
                if (!deleteFlowBtn) return;
                const hasNodes = flowNodes.length > 0;
                const hasSelectedSaved = savedFlowsDropdown && savedFlowsDropdown.value;
                deleteFlowBtn.disabled = !(hasNodes || hasSelectedSaved);
            };

            // Delete entire flow (nodes + connections) and any saved record
            const deleteFlow = async () => {
                // If a saved flow is selected, remove it from savedFlows and Supabase
                const selectedName = savedFlowsDropdown ? savedFlowsDropdown.value : '';
                if (selectedName) {
                    // Remove locally
                    savedFlows = savedFlows.filter(f => f.name !== selectedName);
                    saveFlowsToStorage();
                    renderSavedFlowsList();
                    if (savedFlowsDropdown) savedFlowsDropdown.value = '';
                    // Try to remove from Supabase (if online)
                    try { await deleteNodeFlowByName(selectedName); } catch (e) { console.error(e); }
                }

                // Clear working canvas state
                flowNodes = [];
                flowConnections = [];
                renderFlowNodes();
                renderFlowConnections();
                refreshDeleteFlowState();
            };

            // Toolbar button to delete whole flow with confirmation
            if (deleteFlowBtn) {
                deleteFlowBtn.addEventListener('click', () => {
                    // Allow deletion if canvas has nodes or a saved flow is selected
                    const canDelete = flowNodes.length > 0 || (savedFlowsDropdown && savedFlowsDropdown.value);
                    if (!canDelete) return;
                    showModal(
                        'Delete Flow',
                        'Delete the entire flow (all nodes and connections)? This cannot be undone.',
                        [
                            { text: 'Cancel', className: 'action-button', onClick: hideModal },
                            { text: 'Delete', className: 'action-button bg-[--accent-red] text-white border-[--accent-red-hover] hover:bg-[--accent-red-hover]', onClick: async () => { hideModal(); await deleteFlow(); } }
                        ]
                    );
                });
            }

            nodeFlowContent.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const nodeEl = e.target.closest('.flow-node');
                if (nodeEl) {
                    const nodeId = nodeEl.dataset.nodeId;
                    flowNodes = flowNodes.filter(n => n.id != nodeId);
                    flowConnections = flowConnections.filter(c => c.source != nodeId && c.target != nodeId);
                    renderFlowNodes();
                    renderFlowConnections();
                    if (typeof refreshDeleteFlowState === 'function') refreshDeleteFlowState();
                }
            });
            
            nodeFlowConnections.addEventListener('contextmenu', (e) => {
                 e.preventDefault();
                 const lineEl = e.target.closest('.connection-line');
                 if (lineEl) {
                    const source = lineEl.dataset.source;
                    const target = lineEl.dataset.target;
                    flowConnections = flowConnections.filter(c => !(c.source == source && c.target == target));
                    renderFlowConnections();
                 }
            });


            // --- Atalhos do teclado ---
            document.addEventListener('keydown', (e) => {
                // Atalho para abrir/fechar busca
                if (e.ctrlKey && e.key === 'f') {
                    e.preventDefault();
                    const isVisible = findReplaceBar.classList.contains('visible');
                    toggleFindReplaceBar(!isVisible);
                }
                // Atalho para fechar modais e busca com ESC
                if (e.key === "Escape") {
                    if (!readModeModal.classList.contains('hidden')) {
                        toggleReadMode();
                    }
                    if (findReplaceBar.classList.contains('visible')) {
                        toggleFindReplaceBar(false);
                    }
                    if (!dependencyGraphModal.classList.contains('hidden')) {
                        dependencyGraphModal.classList.add('hidden');
                    }
                    if (!listManagerModal.classList.contains('hidden')) {
                        listManagerModal.classList.add('hidden');
                    }
                    if (!inputGalleryModal.classList.contains('hidden')) {
                        inputGalleryModal.classList.add('hidden');
                    }
                    if (!nodeFlowModal.classList.contains('hidden')) {
                        nodeFlowModal.classList.add('hidden');
                    }
                }
            });

            toggleCommentsBtn.addEventListener('click', () => {
                commentsSection.classList.toggle('hidden');
            });

            // --- INICIALIZAÇÃO ---
                        const initializeApp = async () => {
                                try {
                                    if (supabaseClient) {
                                        const { data } = await supabaseClient.auth.getSession();
                                        if (!data?.session && typeof window.openLoginModal === 'function') {
                                            window.openLoginModal();
                                        }
                                    }
                                } catch {}
                                await loadDataFromSupabase(); // Espera os dados do Supabase carregarem
                populateLlmSelect();
                // Auto-run Diagnostics: verify and filter models to only OK ones
                try { await verifyAndFilterModels(); } catch {}
                // After filtering, repopulate model UIs
                populateLlmSelect();
                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                // Ensure dynamic settings reflect the selected model's capabilities
                try { renderDynamicSettings(); } catch {}
                clearEditorForNewPrompt();
            };

            initializeApp();
        });

  
    </script>
</body>
</html>