<!-- ...existing code... -->
<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PromptMana</title>
    <!-- Loading Tailwind CSS and Google Fonts -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <!-- External Libraries -->
    <script>
    // Carrega modelos automaticamente para todas as conexões após login/session
    async function autoLoadAllModels() {
        try {
            if (typeof getLlmConnections !== 'function') return;
            const conns = getLlmConnections();
            if (!Array.isArray(conns) || !conns.length) return;
            for (const conn of conns) {
                try { await fetchModelsForConn(conn); } catch (e) { console.warn('Model load failed for', conn, e); }
            }
        } catch (e) { console.warn('Auto-load models failed', e); }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- PDF.js for PDF text extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>if (window['pdfjsLib']) { pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; }</script>
    <!-- Mammoth for DOCX text extraction -->
    <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
        <!-- DOMPurify for safe HTML sanitization -->
        <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js"></script>
        <script>
            // Lightweight helpers for safe HTML/text usage
            window.S = function S(value) {
                const str = String(value ?? '');
                if (window.DOMPurify) return window.DOMPurify.sanitize(str, { ALLOWED_TAGS: [], ALLOWED_ATTR: [] });
                // Fallback minimal escape
                return str
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/`/g, '&#96;');
            }
            window.setSafeHTML = function setSafeHTML(el, html, opts) {
                if (!el) return;
                if (window.DOMPurify) el.innerHTML = window.DOMPurify.sanitize(String(html ?? ''), opts || {});
                else el.innerHTML = String(html ?? '');
            }
        </script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Roboto Mono', 'monospace'],
                    },
                },
            },
        }
    </script>
    <style>
    /* Force compact charts in Dashboard using a fixed-height wrapper */
    #dashboard-modal .chart-box { height: 350px; }
    #dashboard-modal .chart-box > canvas { height: 100% !important; width: 100% !important; display: block; }
        :root {
            --bg-dark: #121212; /* Darker gray */
            --card-bg-dark: #1E1E1E; /* Darker card background */
            --border-dark: #2E2E2E; /* Darker border */
            --text-dark: #FFFDF2; /* Creme */
            --text-muted-dark: #808080; /* Cinza de texto mais escuro */
            --input-bg: #222222; /* Inputs/textarea fundo */
            --panel-bg: #121212; /* Painéis internos */
            /* Primary accent migrated to violet */
            --accent-fuchsia: #7711c5;
            --accent-fuchsia-hover: #9b30ed;
            --accent-mint: #0FFCBE;
            --accent-red: #dc2626;
            --accent-red-hover: #b91c1c;
            --diff-ins-bg: #517A18;
            --diff-del-bg: #CC5E5E;
            --highlight-bg: rgba(155, 48, 237, 0.35); /* Violet highlight for search */
            /* Theme-aware accents */
            --stat-color: var(--accent-mint); /* tokens/words/chars counters */
            --db-online-color: var(--accent-mint);
            --db-offline-color: var(--text-muted-dark);
        }
        /* Light theme: warm cream palette, lower contrast */
        [data-theme="light"] {
            --bg-dark: #f9f9f4; /* warm background */
            --card-bg-dark: #fbfbf7; /* soft card shell */
            --border-dark: #e2dfd2; /* warm light border */
            --text-dark: #2b2b24; /* warm slate */
            --text-muted-dark: #6f6d62; /* muted warm gray */
            --input-bg: #f6f5ee; /* creamy input bg */
            --panel-bg: #f7f6ef; /* subtle cream panels */
            --diff-ins-bg: #E7F6E7; /* soft green */
            --diff-del-bg: #F8E7E7; /* soft red */
            /* Use violet accents in light mode */
            --stat-color: #7711c5;
            --db-online-color: #7711c5;
            --db-offline-color: var(--text-muted-dark);
        }

        /* Light theme overrides for dark-leaning components */
    [data-theme="light"] .action-button:hover { background-color: #eeeedd; border-color: #e2dfd2; }
    [data-theme="light"] .prompt-group-header:hover { background-color: #eeeedd; }
    [data-theme="light"] .filter-tag-btn { background-color: #f0efe6; color: var(--text-muted-dark); border-color: var(--border-dark); }
    [data-theme="light"] .filter-tag-btn:hover { background-color: #e6e3d7; color: var(--text-dark); }
    [data-theme="light"] .xml-tag, [data-theme="light"] .dependency-tag, [data-theme="light"] .var-library-tag { background-color: #f0efe6; color: var(--text-dark); }
    [data-theme="light"] .nav-map-tag { background-color: #f0efe6; }
    [data-theme="light"] .status-selector { background-color: #f0efe6; border-color: var(--border-dark); }
    [data-theme="light"] .gallery-card:hover { box-shadow: 0 8px 14px -6px rgba(155, 48, 237, 0.12), 0 3px 5px -3px rgba(155, 48, 237, 0.08); }
    /* Light mode: theme switch rail must be visible over page background */
    [data-theme="light"] .theme-rail { background-color: #e6e3d7 !important; /* slightly darker than body */ }
        /* Node Flow canvas grid on light */
        [data-theme="light"] #node-flow-canvas {
            background-color: #f9f9f4;
            background-image: radial-gradient(circle, rgba(0,0,0,0.08) 1px, transparent 1px);
            background-size: 16px 16px;
            background-position: 0 0;
        }
        /* Auth hero background: gradient + subtle grain */
        .auth-hero {
            background: radial-gradient(80% 120% at 20% 10%, rgba(155,48,237,0.35) 0%, rgba(155,48,237,0.05) 40%, transparent 60%),
                        radial-gradient(70% 100% at 100% 100%, rgba(15,252,190,0.20) 0%, rgba(15,252,190,0.05) 45%, transparent 70%),
                        linear-gradient(180deg, #0b0b0b 0%, #121212 70%);
            position: relative;
        }
        /* Left-pane animated blob (branding) */
        .auth-left { position: relative; overflow: hidden; }
        .auth-left .blob {
            position: absolute; inset: -10% -20% -10% -20%;
            margin: auto;
            width: 80vmax; height: 80vmax;
            background: radial-gradient(35% 35% at 30% 30%, rgba(155,48,237,0.65), transparent 70%),
                        radial-gradient(35% 35% at 70% 60%, rgba(15,252,190,0.55), transparent 70%),
                        radial-gradient(55% 55% at 50% 50%, rgba(155,48,237,0.30), rgba(15,252,190,0.20) 60%, transparent 80%);
            filter: blur(60px);
            opacity: 0.6;
            animation: blob-morph 16s ease-in-out infinite alternate, blob-shift 24s ease-in-out infinite;
        }
        @keyframes blob-morph {
            0% { border-radius: 33% 67% 70% 30% / 30% 30% 70% 70%; transform: rotate(0deg) scale(1); }
            50% { border-radius: 53% 47% 35% 65% / 55% 25% 75% 45%; transform: rotate(18deg) scale(1.04); }
            100% { border-radius: 40% 60% 58% 42% / 43% 67% 33% 57%; transform: rotate(-14deg) scale(0.98); }
        }
        @keyframes blob-shift {
            0% { transform: translate3d(-2%, -1%, 0); }
            50% { transform: translate3d(2%, 1%, 0); }
            100% { transform: translate3d(-2%, 0%, 0); }
        }
        .auth-noise {
            position: absolute; inset: 0; mix-blend-mode: overlay; opacity: 0.15; pointer-events: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="140" height="140" viewBox="0 0 140 140"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23n)" opacity="0.4"/></svg>');
            background-size: 160px 160px;
            /* Keep grain only on the left half so the right pane stays clean */
            clip-path: inset(0 50% 0 0);
        }
        .auth-glass {
            background: rgba(255,255,255,0.04);
            border-color: rgba(255,255,255,0.08);
            box-shadow: 0 8px 30px rgba(0,0,0,0.35);
            backdrop-filter: saturate(150%) blur(12px);
        }
    /* Auth panel width: full within the right column */
    #login-modal .auth-glass { width: 100%; }
    #login-modal .auth-form { width: 100%; background-color: var(--card-bg-dark); border: 1px solid var(--border-dark); box-shadow: 0 8px 30px rgba(0,0,0,0.35); backdrop-filter: none; }
    /* Right column: flat dark background (no gradient/noise) */
    .auth-right { background-color: #0f0f10; position: relative; z-index: 1; }
    /* Additional light theme softening */
    [data-theme="light"] .manager-tag span[contenteditable]:focus { background-color: #eeeedd; }
    [data-theme="light"] .copy-snippet-btn { background-color: #eeeedd; color: var(--text-muted-dark); border-color: var(--border-dark); }
    [data-theme="light"] .input-gallery-item:hover { background-color: #eeeedd; }
    [data-theme="light"] .version-item:hover { background-color: #eeeedd; }
    [data-theme="light"] .prompt-tag, [data-theme="light"] .manager-tag { background-color: #f0efe6; color: var(--text-dark); }
    [data-theme="light"] .form-control { background-color: var(--input-bg); border: 1px solid var(--border-dark); color: var(--text-dark); }
    [data-theme="light"] .form-control::placeholder { color: var(--text-muted-dark); }
    [data-theme="light"] .form-control:focus, [data-theme="light"] #search-versions-input:focus { --tw-ring-color: #e2dfd2; border-color: #cfcbb8; }
    [data-theme="light"] input[type=range] { background: #e2dfd2; }
    [data-theme="light"] #projects-modal tr:hover { background-color: #eeeedd !important; }
    [data-theme="light"] #copy-prompt-btn:hover,
    [data-theme="light"] #find-btn:hover,
    [data-theme="light"] #toggle-comments-btn:hover,
    [data-theme="light"] #close-gallery-btn:hover,
    [data-theme="light"] #close-templates-btn:hover,
    [data-theme="light"] #close-projects-btn:hover,
    [data-theme="light"] #close-dependency-viewer-btn:hover,
    [data-theme="light"] #close-comments-viewer-btn:hover,
    [data-theme="light"] #close-diff-modal-btn:hover,
    [data-theme="light"] #close-dependency-graph-btn:hover,
    [data-theme="light"] #close-input-gallery-btn:hover,
    [data-theme="light"] #close-node-flow-btn:hover { background-color: #F3F4F6 !important; color: var(--text-dark); }
    [data-theme="light"] #close-dashboard-btn:hover { background-color: #eeeedd !important; color: var(--text-dark); }
    [data-theme="light"] #dashboard-btn:hover { background-color: #eeeedd !important; color: var(--text-dark); }
    [data-theme="light"] #close-api-console-btn:hover { background-color: #eeeedd !important; color: var(--text-dark); }
    [data-theme="light"] #api-console-btn:hover { background-color: #eeeedd !important; color: var(--text-dark); }
    /* Ensure Read Mode & Run buttons don't get dark bg on light mode */
    [data-theme="light"] #read-mode-btn:hover { background-color: #eeeedd !important; color: var(--text-dark); }
    [data-theme="light"] #run-prompt-btn:hover { background-color: #eeeedd !important; color: var(--text-dark); }
    /* Tailwind class badge override in light mode */
    [data-theme="light"] .bg-\[\#333\] { background-color: #e6e3d7 !important; color: var(--text-muted-dark) !important; }
    /* Generic override for any element using hover:bg-[#333] Tailwind utility in light mode */
    [data-theme="light"] [class*="hover:bg-[#333]"]:hover { background-color: #eeeedd !important; color: var(--text-dark) !important; }
    /* Light mode: keep Delete Version hover red, not cream */
    [data-theme="light"] #delete-version-btn:hover { background-color: rgba(220,38,38,0.12) !important; border-color: #dc2626 !important; }
    /* Light mode: soften diff panels to create clear separation */
    [data-theme="light"] .diff-view {
        background-color: var(--panel-bg);
        border: 1px solid var(--border-dark);
        box-shadow: 0 1px 2px rgba(0,0,0,0.03);
    }
    /* Light mode: cards inside gallery/templates should not blend with modal bg */
    [data-theme="light"] .gallery-card { background-color: #fbfbf7; border: 1px solid #e2dfd2; border-radius: 0.75rem; }
    [data-theme="light"] #gallery-grid > * { background-color: #fbfbf7; border: 1px solid #e2dfd2; border-radius: 0.75rem; }
    [data-theme="light"] #templates-grid-container > * { background-color: #fbfbf7; border: 1px solid #e2dfd2; border-radius: 0.75rem; }
    /* Light mode: input gallery list items need separation */
    [data-theme="light"] .input-gallery-item { background-color: #fbfbf7; border: 1px solid #e2dfd2; }
    /* Dependencies dropdown row hover */
    #dependencies-list > div:hover { background-color: #333333; }
    [data-theme="light"] #dependencies-list > div:hover { background-color: #eeeedd !important; color: var(--text-dark); }
    /* Dock icon hover */
    #config-dock button:hover { background-color: #333333; }
    [data-theme="light"] #config-dock button:hover { background-color: #eeeedd !important; color: var(--text-dark); }
    /* Dock icon selected state */
    
    /* Slightly increase spacing between dock icons */
    #config-dock .dock-item + .dock-item { margin-top: 6px; }
    /* Dock and Drawer backgrounds in light mode */
    [data-theme="light"] #config-dock { background-color: #f0efe6 !important; }
    [data-theme="light"] #config-drawer { background-color: #f0efe6 !important; }
        
        html, body { height: 100%; overflow: hidden; }
        body { background-color: var(--bg-dark); color: var(--text-dark); font-family: 'Inter', sans-serif; }
        #root { height: 100vh; }
    .sidebar { width: 256px; min-width: 256px; background-color: var(--card-bg-dark); border-right: 1px solid var(--border-dark); }
    .action-panel { width: 256px; min-width: 256px; background-color: var(--card-bg-dark); border-left: 1px solid var(--border-dark); }
        .main-editor-area { background-color: var(--bg-dark); }
        .editor-window { background-color: var(--card-bg-dark); border: 1px solid var(--border-dark); border-radius: 0.75rem; }
    .form-input, .llm-select { background-color: transparent; border: 0; color: var(--text-dark); }
        .form-input::placeholder { color: var(--text-muted-dark); }
    .form-input:focus, .llm-select:focus { outline: none; box-shadow: none; }
        
    .action-button { background-color: transparent; border: 1px solid var(--border-dark); font-size: 0.75rem; padding: 4px 8px; border-radius: 0.5rem; transition: background-color 0.2s, border-color 0.2s; }
    .action-button:hover { background-color: #333333; border-color: #444444; }
    /* Panels that previously used hardcoded bg should follow theme */
    .diff-view { background-color: var(--panel-bg); }
    /* Generic light-tone panel for viewer modals */
    .panel-soft { background-color: var(--panel-bg); border: 1px solid var(--border-dark); border-radius: 0.5rem; }
        .action-button:disabled { cursor: not-allowed; opacity: 0.5; }
        .action-button.primary { background-color: var(--accent-fuchsia); border-color: var(--accent-fuchsia-hover); color: white; }
        .action-button.primary:hover { background-color: var(--accent-fuchsia-hover); }
        .action-button.active {
            background-color: var(--accent-fuchsia);
            color: white;
            border-color: var(--accent-fuchsia-hover);
        }
    /* Compact inline field for top controls and managers */
    .compact-field { padding: 0.25rem 0.5rem; height: 2rem; line-height: 1.25rem; }
    .compact-width { width: 14rem; }

    /* Dock tooltip styles */
    .dock-item { position: relative; }
    .dock-tooltip {
        position: absolute;
        left: 52px; /* dock width (48px) + spacing */
        top: 50%;
        transform: translateY(-50%);
        background-color: var(--card-bg-dark);
        border: 1px solid var(--border-dark);
        color: var(--text-dark);
        padding: 2px 8px;
        font-size: 12px;
        line-height: 1.2;
        white-space: nowrap;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        opacity: 0;
        pointer-events: none;
        transition: opacity .15s ease-in-out;
        z-index: 50;
    }
    .dock-item:hover .dock-tooltip { opacity: 1; }

    /* Ensure drawer never overflows viewport */
    #config-drawer {
        width: 256px; /* default to match sidebar */
        max-width: calc(100vw - 56px); /* viewport minus dock(48px) and 8px breathing room */
    }
    /* Normalize select height */
    select.form-control.compact-field { height: 2rem; }
    /* Ensure internal text alignment */
    .form-control.compact-field { font-size: 0.875rem; }
    /* Consistent (slightly slimmer) height for left/right menu buttons */
    .nav-button { padding-top: 0.25rem; padding-bottom: 0.25rem; }
    /* Sidebar section separator spacing for clearer grouping */
    .section-sep { margin: 24px 0; }
        
        .prompt-group-header { cursor: pointer; padding: 8px; border-radius: 0.5rem; display: flex; align-items: center; justify-content: space-between; font-size: 0.875rem; font-weight: 500; }
        .prompt-group-header:hover { background-color: #333333; }
        .prompt-group-header .toggle-icon { margin-right: 8px; transition: transform 0.2s; color: var(--text-muted-dark); }
        .prompt-group-header.expanded .toggle-icon { transform: rotate(90deg); }
    /* Run Prompt preview toggles */
    .req-preview { background-color: var(--panel-bg); color: var(--text-muted-dark); }
    .req-preview.active { background-color: var(--accent-fuchsia); color: #fff; border-color: var(--accent-fuchsia-hover); }
    .req-preview:not(.active):hover { background-color: #333333; color: var(--text-dark); }
    /* Normalize small icon buttons (hit area and alignment) */
    #toggle-syntax-highlighting { line-height: 0; }

        .version-sub-list { padding-left: 12px; display: none; }
        .version-sub-list.expanded { display: block; }
        .version-item { cursor: pointer; padding: 6px 12px; border-radius: 0.5rem; transition: background-color 0.2s; display: flex; justify-content: space-between; align-items: center; font-size: 0.875rem; }
        .version-item:hover { background-color: #333333; }
        .version-item.selected { background-color: var(--accent-fuchsia); color: white; }
        .version-item.selected .text-gray-400, .version-item.selected .text-gray-500 { color: white; }
        /* Light mode: selected version uses a lighter fuchsia to avoid visual collision with the checkbox */
        [data-theme="light"] .version-item.selected {
            background-color: rgba(155, 48, 237, 0.30); /* ~30% */
            color: var(--text-dark);
        }
        [data-theme="light"] .version-item.selected .text-gray-400,
        [data-theme="light"] .version-item.selected .text-gray-500 { color: var(--text-dark); }
        /* Branded checkbox (used in Versions list) */
        .pm-checkbox {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 16px; height: 16px; display: inline-block; position: relative;
            border-radius: 4px; cursor: pointer; outline: none; flex-shrink: 0;
            background-color: transparent; border: 1px solid var(--border-dark);
            transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
        }
        /* Default (dark mode): mint box with dark checkmark */
        .pm-checkbox:hover { background-color: rgba(16, 185, 129, 0.12); }
        .pm-checkbox:focus { box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.25); border-color: var(--accent-mint); }
        .pm-checkbox:checked {
            background-color: var(--accent-mint); border-color: var(--accent-mint);
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M4 9l2.5 2.5L12 6" fill="none" stroke="%231a1a1a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
            background-repeat: no-repeat; background-position: center; background-size: 12px 12px;
        }
        /* Light mode: fuchsia box with white checkmark */
        [data-theme="light"] .pm-checkbox:hover { background-color: rgba(155, 48, 237, 0.10); }
        [data-theme="light"] .pm-checkbox:focus { box-shadow: 0 0 0 3px rgba(155, 48, 237, 0.25); border-color: var(--accent-fuchsia-hover); }
        [data-theme="light"] .pm-checkbox:checked {
            background-color: var(--accent-fuchsia); border-color: var(--accent-fuchsia-hover);
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M4 9l2.5 2.5L12 6" fill="none" stroke="%23ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
            background-repeat: no-repeat; background-position: center; background-size: 12px 12px;
        }
        /* Light mode readability for version labels */
        [data-theme="light"] #versions-history-list .text-white { color: var(--text-dark) !important; }
        [data-theme="light"] #versions-history-list .text-gray-400 { color: var(--text-muted-dark) !important; }
        [data-theme="light"] .version-item:hover { background-color: #eeeedd; }

        .status-selector { background-color: #333333; border: 1px solid var(--border-dark); }
        .status-option {
            border-right: 1px solid var(--border-dark);
            color: var(--text-muted-dark);
            transition: all 0.2s;
            /* Match Kanban button height (py-1, text-xs) while keeping horizontal px-4 */
            padding-top: 0.25rem;
            padding-bottom: 0.25rem;
            font-size: 0.75rem;
        }
        .status-option:last-child { border-right: none; }
        .status-option:hover { color: var(--text-dark); }
        .status-option.active { background-color: var(--accent-fuchsia); color: white; font-weight: 600; }

        /* Estilo unificado para botões de filtro (status e tags) */
        .filter-tag-btn {
            background-color: #333;
            color: var(--text-muted-dark);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            border: 1px solid var(--border-dark);
            cursor: pointer;
            transition: all 0.2s;
        }
        .filter-tag-btn:hover {
            color: var(--text-dark);
            background-color: #444444;
        }
        .filter-tag-btn.active {
            background-color: var(--accent-fuchsia);
            color: white;
            border-color: var(--accent-fuchsia-hover);
        }

    #editor-stats { color: var(--stat-color); }
    #read-mode-stats { color: var(--stat-color); }
    /* DB status pill color by state */
    #db-status-pill.online { color: var(--db-online-color); }
    #db-status-pill.offline { color: var(--db-offline-color); }
    #db-status-pill.loading { color: var(--text-muted-dark); }
    /* API STATUS uses button color directly; old llm-status-pill removed */

        .modal-overlay { transition: opacity 0.3s ease; }
        .modal-overlay.hidden { opacity: 0; pointer-events: none; }
        #confirm-modal { z-index: 60; } /* Z-index maior para o modal de confirmação */
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.75) !important;
        }

        .modal-overlay > div {
            background-color: var(--card-bg-dark) !important;
            border: 1px solid var(--border-dark) !important;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
            color: var(--text-dark);
        }
        
        .form-control {
            background-color: #222222;
            border: 1px solid #3a3a3a;
        }
        .form-control:focus, #search-versions-input:focus {
            --tw-ring-color: #444444;
            border-color: #555555;
        }

        /* Custom Range Slider Styles */
        input[type=range] { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #333; border-radius: 5px; outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: var(--accent-fuchsia); cursor: pointer; border-radius: 50%; }
        input[type=range]::-moz-range-thumb { width: 16px; height: 16px; background: var(--accent-fuchsia); cursor: pointer; border-radius: 50%; }

        .xml-tag, .dependency-tag, .var-library-tag {
            background-color: #333;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .xml-tag:hover, .dependency-tag:hover, .var-library-tag:hover {
            background-color: var(--accent-fuchsia);
        }
        .gallery-card {
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .gallery-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(155, 48, 237, 0.10), 0 4px 6px -2px rgba(155, 48, 237, 0.05);
        }
        /* Standard fixed-width card to match Node Flow node sizing */
        .standard-card {
            width: 280px; /* Match .flow-node width */
        }
        .read-mode-blur {
            filter: blur(5px);
            transition: filter 0.3s ease-in-out;
        }
        .diff-view del {
            background-color: var(--diff-del-bg);
            text-decoration: none;
            padding: 0.1em 0;
            border-radius: 2px;
        }
        .diff-view ins {
            background-color: var(--diff-ins-bg);
            text-decoration: none;
            padding: 0.1em 0;
            border-radius: 2px;
        }
        #find-replace-bar {
            transition: all 0.3s ease-in-out;
            max-height: 0;
            overflow: hidden;
            padding: 0;
            border-bottom: 0px solid var(--border-dark);
        }
        #find-replace-bar.visible {
             max-height: 100px; /* Altura suficiente para o conteúdo */
             padding: 0.5rem;
             border-bottom-width: 1px;
        }
        textarea::selection {
            background-color: var(--accent-fuchsia);
            color: white;
        }
        .highlight {
            background-color: var(--highlight-bg);
        }
        /* Estilos para o Gráfico de Dependências */
        #dependency-graph-svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #dependency-graph-svg:active {
            cursor: grabbing;
        }
        .graph-node {
             cursor: pointer;
        }
        .graph-node circle {
            stroke: var(--accent-fuchsia);
            stroke-width: 1.5px;
            transition: transform 0.2s, stroke-width 0.2s;
        }
        .graph-node:hover circle {
            transform: scale(1.2);
            stroke-width: 3px;
        }
        .graph-node.selected-for-connection circle {
            stroke: var(--accent-mint);
            stroke-width: 4px;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }
        .graph-node text {
            fill: var(--text-dark);
            font-size: 10px;
            pointer-events: none;
            text-anchor: middle;
            font-family: 'Inter', sans-serif;
        }
        .graph-link {
            stroke: var(--border-dark);
            stroke-opacity: 0.7;
            stroke-width: 1.5px;
            transition: stroke 0.2s, stroke-width 0.2s;
        }
        .graph-link:hover {
            stroke-width: 3px;
        }
        .graph-link.selected {
            stroke: var(--accent-red);
            stroke-width: 4px;
        }
        /* Editor title: reduce font size and field height (~-20px) */
        #prompt-title-input {
            font-size: 1rem !important; /* override text-xl */
            line-height: 1.25 !important;
            padding-top: 2px !important;
            padding-bottom: 2px !important; /* was py-2 (8px) */
            height: 32px !important; /* compact height */
        }
        /* Subtle blink ring to draw attention to action buttons */
        @keyframes pm-blink {
            0%, 100% { box-shadow: 0 0 0 0 rgba(119,17,197,0.0); }
            50% { box-shadow: 0 0 0 6px rgba(119,17,197,0.25); }
        }
        .blink-llm { animation: pm-blink 1.2s ease-in-out infinite; border-color: var(--accent-fuchsia); }
        #graph-tooltip {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            background-color: var(--card-bg-dark);
            border: 1px solid var(--border-dark);
            border-radius: 0.5rem;
            padding: 0.75rem;
            font-size: 0.75rem;
            min-width: 250px;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3), 0 4px 6px -2px rgba(0,0,0,0.25);
            z-index: 100;
        }
        /* Estilos para Tags */
        .prompt-tag, .manager-tag {
            background-color: #333;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-family: 'Roboto Mono', monospace;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .manager-tag span[contenteditable]:focus {
            outline: 1px solid var(--accent-fuchsia);
            background-color: #444;
        }
        .prompt-tag .remove-tag-btn, .manager-tag .remove-tag-btn {
            cursor: pointer;
            color: var(--text-muted-dark);
        }
        .prompt-tag .remove-tag-btn:hover, .manager-tag .remove-tag-btn:hover {
            color: var(--accent-red);
        }
        .prompt-tag.auto-tag {
            background-color: #2a2a2a;
            color: var(--text-muted-dark);
        }
        [data-theme="light"] .prompt-tag.auto-tag {
            background-color: #E5E7EB;
            color: var(--text-muted-dark);
        }
        /* Dropdown customizado */
        .custom-dropdown {
            position: absolute;
            z-index: 10;
            width: 100%;
            max-height: 150px;
            overflow-y: auto;
            background-color: var(--card-bg-dark);
            border: 1px solid var(--border-dark);
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
        }
        .custom-dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.875rem;
        }
        .custom-dropdown-item:hover {
            background-color: var(--accent-fuchsia);
            color: white;
        }
        [data-theme="light"] .custom-dropdown-item:hover {
            background-color: #F3F4F6;
            color: var(--text-dark);
        }
        /* Estilos do Mapa de Navegação */
        #navigation-map {
            display: flex;
            flex-wrap: wrap;
            gap: 4px; /* was 8px */
            align-items: center;
            padding: 2px 6px !important; /* override p-2 to reduce vertical space */
        }
        .nav-map-tag {
            background-color: #333;
            padding: 2px 6px; /* was 4px 10px */
            border-radius: 3px; /* was 4px */
            font-size: 0.6875rem; /* ~11px, was 12px */
            line-height: 1.2;
            font-family: 'Roboto Mono', monospace;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 1px solid var(--border-dark);
        }
        .nav-map-tag:hover {
            background-color: var(--accent-fuchsia);
            color: white;
        }
        /* Estilos para a lista da galeria de inputs */
        .input-gallery-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .input-gallery-item:hover {
            background-color: #333;
        }
        .input-gallery-item.selected {
            background-color: var(--accent-fuchsia);
            color: white;
        }
        .input-gallery-item .remove-btn {
            visibility: hidden;
            color: var(--text-muted-dark);
        }
        .input-gallery-item:hover .remove-btn {
            visibility: visible;
        }
        .input-gallery-item .remove-btn:hover {
            color: var(--accent-red);
        }
        /* Drawer list row */
        .drawer-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid var(--border-dark);
            background-color: var(--card-bg-dark);
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        .drawer-row:hover { background-color: #333; }
        .drawer-row.selected { background-color: var(--accent-fuchsia); color: #fff; border-color: var(--accent-fuchsia-hover); }
        [data-theme="light"] .drawer-row:hover { background-color: #F3F4F6; }
        [data-theme="light"] .drawer-row { background-color: #fff; }
    /* Estilos para Snippet Buttons (Copy/Save) */
        #editor-container {
            position: relative; /* ensure absolute children are bounded */
            overflow: hidden; /* Garante que os botões não saiam da área */
        }
        #snippet-buttons-overlay {
            pointer-events: none; /* O overlay em si não é clicável */
            inset: 0; /* ensure overlay covers editor-container */
            box-sizing: border-box; /* align absolute children with padding box */
        }
        /* Syntax highlighting overlay mirrors textarea content */
        #syntax-overlay {
            pointer-events: none;
            /* Match textarea wrapping behavior exactly to avoid reflow/jitter */
            white-space: pre-wrap;
            word-break: normal;
            overflow-wrap: normal;
            box-sizing: border-box; /* ensure padding matches content box like textarea */
            will-change: top; /* smoother scroll sync */
            z-index: 1;
            /* Default to transparent so we don't double-render text when disabled */
            color: transparent;
        }
        /* Token styles: color the font instead of painting background overlays */
        #syntax-overlay .hl-var { color: #3B82F6; /* blue-500 */ }
        #syntax-overlay .hl-xml { color: #10B981; /* emerald-500 */ }
    /* Ensure token spans inherit exact font metrics */
    #syntax-overlay .hl-var,
    #syntax-overlay .hl-xml { font: inherit; }
        /* When syntax highlighting is ON, hide textarea text and show overlay text */
        #editor-container.syntax-on #main-editor {
            color: transparent !important;
            /* Keep caret visible even when text is transparent */
            caret-color: var(--accent-mint);
        }
        #editor-container.syntax-on #syntax-overlay {
            color: inherit; /* overlay text uses normal text color except where token spans override */
        }
        /* Keep overlay mounted to stabilize rendering layers; just toggle visibility */
        #editor-container:not(.syntax-on) #syntax-overlay { visibility: hidden; opacity: 0; }
        #editor-container.syntax-on #syntax-overlay { visibility: visible; opacity: 1; }
    .copy-snippet-btn,
    .save-snippet-btn {
            /* static inside holder for proper sizing */
            position: relative;
            pointer-events: all; /* Torna o botão clicável */
            background-color: #333;
            color: var(--text-muted-dark);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 5; /* Garante que fique sobre o texto */
        }
        /* Container for copy+save buttons per snippet */
        .snippet-btn-holder {
            position: absolute;
            display: flex;
            gap: 6px;
            z-index: 5;
            right: 16px; /* default anchor inside editor padding */
            max-width: calc(100% - 16px);
            flex-wrap: nowrap;
        }
    /* Reduce editor font size to 12px */
    #main-editor { font-size: 0.75rem; }
    .copy-snippet-btn:hover,
    .save-snippet-btn:hover {
            background-color: var(--accent-fuchsia);
            color: white;
        }
        .copy-snippet-btn.copied {
            background-color: var(--diff-ins-bg);
            color: white;
            border-color: #3f6212;
        }
    [data-theme="light"] .copy-snippet-btn,
    [data-theme="light"] .save-snippet-btn { background-color: #eeeedd; color: var(--text-muted-dark); border-color: var(--border-dark); }
        
        /* --- ESTILOS NODE FLOW --- */
        #node-flow-canvas {
            background-color: #0c0c0c;
            background-image:
                radial-gradient(circle, rgba(255,255,255,0.07) 1px, transparent 1px);
            background-size:
                16px 16px; /* dots */
            background-position:
                0 0, 0 0, 0 0;
            overflow: hidden;
            position: relative;
        }
        #node-flow-canvas:active {
            cursor: grabbing;
        }
        .node-flow-prompt-card {
            background-color: var(--card-bg-dark);
            border: 1px solid var(--border-dark);
            cursor: grab;
        }
        .node-flow-prompt-card:active {
            cursor: grabbing;
        }
        #node-flow-content {
            position: absolute;
            width: 100%;
            height: 100%;
            /* O transform será aplicado via JS */
        }
        .flow-node {
            position: absolute;
            border: 1px solid var(--border-dark);
            background-color: var(--card-bg-dark); /* Added background to card */
            cursor: move;
            width: 280px; /* Fixed width for consistency */
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            user-select: none;
            transition: border-color 0.2s;
        }
        .flow-node:hover {
            border-color: var(--accent-fuchsia);
        }
        .flow-node.selected {
            border-color: var(--accent-red);
            box-shadow: 0 0 0 1px var(--accent-red) inset, 0 4px 6px rgba(0,0,0,0.3);
        }
    /* Node Flow: status pills and action icons */
    .flow-status { font-size: 11px; border-radius: 9999px; padding: 2px 8px; border: 1px solid var(--border-dark); display: inline-flex; align-items: center; gap: 4px; }
    .flow-status.idle { color: var(--text-muted-dark); }
    .flow-status.pending { color: var(--text-muted-dark); }
    .flow-status.running { color: #f59e0b; border-color: #f59e0b55; }
    .flow-status.success { color: var(--accent-mint); border-color: #0ffcb055; }
    .flow-status.error { color: var(--accent-red); border-color: #dc262655; }
    .node-actions button { padding: 4px; border-radius: 6px; border: 1px solid var(--border-dark); }
    .node-actions button:hover { background-color: #333; }
    [data-theme="light"] .node-actions button:hover { background-color: #eeeedd; }
        .flow-node .connector {
            position: absolute;
            width: 14px;
            height: 14px;
            background-color: #444;
            border: 1px solid var(--text-muted-dark);
            border-radius: 50%;
            cursor: crosshair;
            transition: background-color 0.2s, transform 0.2s;
            z-index: 10;
        }
        .flow-node:hover .connector {
            transform: scale(1.2);
        }
        .flow-node .connector:hover {
            background-color: var(--accent-mint);
        }
        .flow-node .connector.output {
            right: -7px;
            top: 50%;
            transform: translateY(-50%);
        }
        #node-flow-connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* let underlying nodes receive events */
        }
        .connection-line {
            stroke: var(--accent-fuchsia);
            stroke-width: 2;
            fill: none;
            pointer-events: stroke; /* allow hitting the path without blocking entire overlay */
            cursor: pointer;
        }
        .connection-line:hover {
            stroke-width: 4;
            stroke: var(--accent-red);
        }
    </style>
</head>
<body>

    <div id="root" class="flex flex-col h-screen">
    <header id="main-header" class="bg-[--card-bg-dark] border-b border-[--border-dark] px-6 py-2 flex items-center justify-between relative z-20">
            <div class="flex items-center gap-3">
                <!-- LOGO SVG -->
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: rotate(15deg);">
                    <path d="M9 21C9 21.5523 8.55228 22 8 22H7C6.44772 22 6 21.5523 6 21V20H9V21Z" fill="#5A5A5A"/>
                    <path d="M10 4H14C14.5523 4 15 3.55228 15 3V2C15 1.44772 14.5523 1 14 1H10C9.44772 1 9 1.44772 9 2V3C9 3.55228 9.44772 4 10 4Z" fill="#A8763E"/>
                    <path d="M17 9V8C17 6.34315 15.6569 5 14 5H10C8.34315 5 7 6.34315 7 8V9C4.23858 9 2 11.2386 2 14V17C2 19.2091 3.79086 21 6 21H9V20H6C4.34315 20 3 18.6569 3 17V14C3 11.7909 4.79086 10 7 10H17C19.2091 10 21 11.7909 21 14V17C21 18.6569 19.6569 20 18 20H15V21H18C20.2091 21 22 19.2091 22 17V14C22 11.2386 19.7614 9 17 9Z" fill="#5A5A5A"/>
                    <path d="M18 11H6C5.44772 11 5 11.4477 5 12V17C5 18.1046 5.89543 19 7 19H17C18.1046 19 19 18.1046 19 17V12C19 11.4477 18.5523 11 18 11Z" fill="url(#potion-gradient)"/>
                    <defs>
                        <linearGradient id="potion-gradient" x1="12" y1="11" x2="12" y2="19" gradientUnits="userSpaceOnUse">
                            <stop stop-color="#9b30ed"/>
                            <stop offset="1" stop-color="#F871B1"/>
                        </linearGradient>
                    </defs>
                </svg>
                <h1 class="text-xl font-bold font-mono" style="color: var(--accent-fuchsia);">PromptMana</h1>
            </div>
            <!-- Centered Read Mode button -->
            <div class="absolute inset-x-0 flex justify-center items-center gap-2 pointer-events-none">
                <button id="read-mode-btn" title="Read Mode" class="p-2 rounded-full hover:bg-[#333] pointer-events-auto">
                    <!-- Olho Fechado (Padrão) -->
                    <svg id="read-mode-icon-closed" class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M3.98 8.223A10.477 10.477 0 001.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.45 10.45 0 0112 4.5c4.756 0 8.773 3.162 10.065 7.498a10.522 10.522 0 01-4.293 5.774M6.228 6.228L3 3m3.228 3.228l3.65 3.65m7.894 7.894L21 21m-3.228-3.228l-3.65-3.65m0 0a3 3 0 10-4.243-4.243m4.243 4.243a3 3 0 01-4.243-4.243" />
                    </svg>
                    <!-- Olho Aberto (Oculto) -->
                    <svg id="read-mode-icon-open" class="w-6 h-6 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M2.036 12.322a1.012 1.012 0 010-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.432 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178z" />
                      <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                </button>
                <button id="run-prompt-btn" title="Run Prompt" class="p-2 rounded-full hover:bg-[#333] pointer-events-auto">
                    <!-- Play icon -->
                    <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M8 5.14v13.72c0 .79.86 1.27 1.54.84l10.62-6.86a1 1 0 000-1.68L9.54 4.3A1 1 0 008 5.14z" />
                    </svg>
                </button>
                <button id="dashboard-btn" title="Dashboard" class="p-2 rounded-full hover:bg-[#333] pointer-events-auto">
                    <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 3v18h18M7 15v3m5-7v7m5-11v11" />
                    </svg>
                </button>
            </div>
            <div class="flex items-center gap-1">
                <button id="theme-toggle" class="p-1.5" aria-label="Toggle theme" role="switch" aria-checked="false">
                    <!-- Sun/Moon switch: sun on the left, moon on the right, with a sliding thumb -->
                    <div class="relative w-12 h-6 rounded-full bg-[--panel-bg] flex items-center justify-between px-1 theme-rail">
                        <!-- Sun (left) -->
                        <svg id="icon-sun" class="w-3.5 h-3.5 text-[--accent-fuchsia]" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m0 13.5V21m9-9h-2.25M5.25 12H3m15.364 6.364l-1.591-1.591M7.227 7.227L5.636 5.636m12.728 0l-1.591 1.591M7.227 16.773l-1.591 1.591M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
                        </svg>
                        <!-- Moon (right) -->
                        <svg id="icon-moon" class="w-3.5 h-3.5 text-[--accent-mint]" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/>
                        </svg>
                        <!-- Thumb -->
                        <div id="theme-switch-thumb" class="absolute left-1 top-1 w-4 h-4 rounded-full bg-white shadow transition-transform duration-200 ease-in-out translate-x-0"></div>
                    </div>
                </button>
                <!-- Inline Auth placeholder removed (replaced by static Account button) -->
                                <div id="profile-inline" class="hidden items-center gap-1">
                                    <!-- email hidden per request -->
                                    <input id="profile-fullname" type="text" placeholder="Full name" class="form-control compact-field rounded-md text-xs w-40 hidden"/>
                                    <!-- inline Edit removed per request -->
                                    <button id="profile-save-btn" class="action-button text-xs hidden">Save</button>
                                </div>
                                <button id="account-btn" class="action-button p-1.5" aria-label="Account">Account</button>
            </div>
        </header>

                <!-- Auth Gate: Full-screen Login/Register (centered CTA + glass) -->
                <div id="login-modal" class="fixed inset-0 hidden z-50">
                    <div class="auth-hero w-full h-full relative flex items-stretch justify-center p-0">
                        <!-- Two-column wrapper -->
                        <div class="w-full h-full grid" style="grid-template-columns: 1fr 1fr;">
                            <!-- Left: Branding & animated blob -->
                            <div class="auth-left relative hidden md:block">
                                <div class="blob" aria-hidden="true"></div>
                                <div class="absolute inset-0 flex items-center">
                                    <div class="px-10 md:px-14 lg:px-20 ml-8 md:ml-12 lg:ml-20">
                                        <h2 class="text-[2.4rem] md:text-5xl font-extrabold mb-10" style="color: var(--accent-fuchsia); line-height: 1.2;">
                                            Your prompt are spells.<br/>
                                            This is your grimore!
                                        </h2>
                                        <p class="text-[0.9rem] md:text-base text-white max-w-[40ch] md:max-w-[44ch]">
                                            PromptMana, the all-in-on platform to craft, version, test and deploy production-ready prompts. With seamless LLM and Git integration, PromptMana brings structure, security, and magic to your AI workflow.
                                        </p>
                                    </div>
                                </div>
                            </div>
                            <!-- Right: Form glass -->
                            <div class="auth-right relative flex items-center justify-center p-6">
                                <!-- Mobile-only copy -->
                                <div class="absolute top-0 left-0 right-0 p-6 pl-10 md:hidden">
                                    <h2 class="text-2xl font-extrabold mb-6" style="color: var(--accent-fuchsia); line-height: 1.2;">
                                        Your prompt are spells.<br/>
                                        This is your grimore!
                                    </h2>
                                    <p class="text-[0.7rem] text-white mb-0 max-w-[28ch]">
                                        PromptMana, the all-in-on platform to craft, version, test and deploy production-ready prompts. With seamless LLM and Git integration, PromptMana brings structure, security, and magic to your AI workflow.
                                    </p>
                                </div>
                                <div class="auth-form relative w-full max-w-md p-6 rounded-xl mx-auto">
                                    <div class="flex items-center justify-between mb-3">
                                        <h2 id="login-modal-title" class="text-lg font-semibold">Sign in</h2>
                                    </div>
                                    <p id="login-modal-desc" class="text-xs text-[--text-muted-dark] mb-3">Enter your email and password to sign in.</p>
                                    <div class="space-y-2">
                                        <input id="login-email-input" type="email" autocomplete="email" placeholder="you@email.com" class="form-control w-full rounded-md py-2 px-3"/>
                                        <input id="login-password-input" type="password" autocomplete="current-password" placeholder="Password" class="form-control w-full rounded-md py-2 px-3"/>
                                        <input id="login-password-confirm" type="password" autocomplete="new-password" placeholder="Confirm password" class="form-control w-full rounded-md py-2 px-3 hidden"/>
                                        <button id="login-submit-btn" class="action-button primary w-full">Start crafting your magic.</button>
                                        <div class="flex items-center justify-between text-xs text-[--text-muted-dark]">
                                            <button id="login-toggle-mode" class="underline hover:text-white" type="button">Create account</button>
                                            <button id="login-forgot" class="underline hover:text-white" type="button">Forgot password?</button>
                                        </div>
                                        <p id="login-status" class="text-xs text-[--text-muted-dark] mt-1"></p>
                                    </div>
                                </div>
                                <!-- Right-column footer logo (reuse header logo) -->
                                <div class="absolute bottom-2 left-0 right-0 flex items-center justify-center pt-2 pb-2 select-none">
                                    <div class="flex items-center gap-2 opacity-85">
                                        <!-- Header logo SVG replicated at smaller size -->
                                        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: rotate(15deg);">
                                            <path d="M9 21C9 21.5523 8.55228 22 8 22H7C6.44772 22 6 21.5523 6 21V20H9V21Z" fill="#5A5A5A"/>
                                            <path d="M10 4H14C14.5523 4 15 3.55228 15 3V2C15 1.44772 14.5523 1 14 1H10C9.44772 1 9 1.44772 9 2V3C9 3.55228 9.44772 4 10 4Z" fill="#A8763E"/>
                                            <path d="M17 9V8C17 6.34315 15.6569 5 14 5H10C8.34315 5 7 6.34315 7 8V9C4.23858 9 2 11.2386 2 14V17C2 19.2091 3.79086 21 6 21H9V20H6C4.34315 20 3 18.6569 3 17V14C3 11.7909 4.79086 10 7 10H17C19.2091 10 21 11.7909 21 14V17C21 18.6569 19.6569 20 18 20H15V21H18C20.2091 21 22 19.2091 22 17V14C22 11.2386 19.7614 9 17 9Z" fill="#5A5A5A"/>
                                            <path d="M18 11H6C5.44772 11 5 11.4477 5 12V17C5 18.1046 5.89543 19 7 19H17C18.1046 19 19 18.1046 19 17V12C19 11.4477 18.5523 11 18 11Z" fill="url(#potion-gradient-footer)"/>
                                            <defs>
                                                <linearGradient id="potion-gradient-footer" x1="12" y1="11" x2="12" y2="19" gradientUnits="userSpaceOnUse">
                                                    <stop stop-color="#9b30ed"/>
                                                    <stop offset="1" stop-color="#F871B1"/>
                                                </linearGradient>
                                            </defs>
                                        </svg>
                                        <span class="text-sm font-bold font-mono" style="color: var(--accent-fuchsia);">PromptMana</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Noise overlay -->
                        <div class="auth-noise pointer-events-none"></div>
                    </div>
                </div>

                <!-- Account Modal (Profile + Billing placeholders) -->
                <div id="account-modal" class="modal-overlay fixed inset-0 bg-black/75 hidden z-50 flex items-center justify-center p-6">
                    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
                        <div class="p-3 border-b border-[--border-dark] flex items-center justify-between">
                            <h2 class="text-xl font-bold">Account</h2>
                            <div class="flex items-center gap-2">
                                <button id="account-logout-btn" class="action-button text-xs">Logout</button>
                                <button id="account-close-btn" class="p-2 rounded hover:bg-[#333]" title="Close">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                                </button>
                            </div>
                        </div>
                        <div class="flex-1 overflow-auto p-4 grid gap-4" style="grid-template-columns: repeat(2, minmax(0, 1fr));">
                            <!-- Profile -->
                            <div class="panel-soft p-3 rounded-md space-y-3">
                                <h3 class="font-semibold text-sm">Profile</h3>
                                <div class="grid gap-2 text-sm">
                                    <label class="text-[--text-muted-dark]">Full name</label>
                                    <div class="flex gap-2">
                                        <input id="account-fullname" class="form-control rounded-md py-1.5 px-3 flex-1" placeholder="Your name"/>
                                        <button id="account-save-name" class="action-button text-xs">Save</button>
                                    </div>
                                    <span id="account-name-status" class="text-[10px] font-mono text-[--text-muted-dark]"></span>
                                </div>
                                <div class="grid gap-2 text-sm">
                                    <label class="text-[--text-muted-dark]">Email</label>
                                    <input id="account-email" class="form-control rounded-md py-1.5 px-3" placeholder="user@example.com" disabled />
                                </div>
                                <div class="grid gap-2 text-sm">
                                    <label class="text-[--text-muted-dark]">Change password</label>
                                    <input id="account-new-pass" type="password" class="form-control rounded-md py-1.5 px-3" placeholder="New password"/>
                                    <input id="account-new-pass2" type="password" class="form-control rounded-md py-1.5 px-3" placeholder="Confirm new password"/>
                                    <div class="flex items-center gap-2">
                                        <button id="account-update-pass" class="action-button text-xs">Update</button>
                                        <span id="account-pass-status" class="text-[10px] font-mono text-[--text-muted-dark]"></span>
                                    </div>
                                </div>
                            </div>
                            <!-- Billing (placeholders only; no local storage) -->
                            <div class="panel-soft p-3 rounded-md space-y-3">
                                <h3 class="font-semibold text-sm">Billing</h3>
                                <div class="grid gap-2 text-sm">
                                    <label class="text-[--text-muted-dark]">Payment method</label>
                                    <div class="flex items-center gap-2">
                                        <input id="account-card-mask" class="form-control rounded-md py-1.5 px-3 flex-1" placeholder="•••• •••• •••• ••••" disabled>
                                        <button id="account-add-card" class="action-button text-xs" disabled>Connect (soon)</button>
                                    </div>
                                    <span class="text-[10px] font-mono text-[--text-muted-dark]">We’ll integrate a PCI-compliant provider. Nothing is stored in the browser.</span>
                                </div>
                                <div class="grid gap-2 text-sm">
                                    <label class="text-[--text-muted-dark]">Billing history</label>
                                    <div id="account-billing-history" class="border border-[--border-dark] rounded-md p-2 text-xs text-[--text-muted-dark]">
                                        <div class="opacity-80">No records yet. This will show your invoices once billing is enabled.</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Security: Cloud-only data (disable localStorage for app data, but keep Supabase auth tokens) -->
                <script>
                    (function() {
                        try {
                            const ORIG = {
                                getItem: localStorage.getItem.bind(localStorage),
                                setItem: localStorage.setItem.bind(localStorage),
                                removeItem: localStorage.removeItem.bind(localStorage),
                                clear: localStorage.clear.bind(localStorage)
                            };
                            const isSupabaseKey = (k) => typeof k === 'string' && (/^(sb-)/.test(k) || k.includes('supabase'));
                            const noop = function(){};
                            localStorage.getItem = function(k){ return isSupabaseKey(k) ? ORIG.getItem(k) : null; };
                            localStorage.setItem = function(k,v){ if (isSupabaseKey(k)) { try { ORIG.setItem(k,v); } catch {} } };
                            localStorage.removeItem = function(k){ if (isSupabaseKey(k)) { try { ORIG.removeItem(k); } catch {} } };
                            localStorage.clear = noop;
                            window.clearAppLocalData = noop;
                        } catch {}
                    })();
                </script>
                <!-- No extra wiring needed: left column CTA removed per request -->

        <div id="main-content" class="flex flex-grow overflow-hidden transition-filter duration-300">
            <div id="auth-gate-overlay" class="absolute inset-0 hidden items-center justify-center z-40 bg-black/50">
                <div class="text-[--text-muted-dark] text-sm font-mono">Faça login para continuar…</div>
            </div>
            <!-- PAINEL ESQUERDO -->
          <aside class="sidebar p-4 flex flex-col">
              <button id="add-prompt-btn" class="action-button nav-button primary w-full text-center font-medium">Add Prompt</button>
              <hr class="border-[--border-dark] my-4">
                  <div class="space-y-2">
                            <button id="templates-btn" class="action-button nav-button w-full text-left font-medium">Templates</button>
                     <button id="projects-btn" class="action-button nav-button w-full text-left font-medium">Projects</button>
                     <button id="gallery-btn" class="action-button nav-button w-full text-left font-medium">Prompt Gallery</button>
                     <button id="input-gallery-btn" class="action-button nav-button w-full text-left font-medium">Input Gallery</button>
                     <button id="response-log-btn" class="action-button nav-button w-full text-left font-medium">Response Log</button>
                     <button id="list-manager-btn" class="action-button nav-button w-full text-left font-medium">List Manager</button>
                 </div>
                 <hr class="border-[--border-dark] section-sep">
                 <div class="space-y-2">
                     <button id="node-flow-btn" class="action-button nav-button w-full text-left font-medium">Node Flow</button>
                     <button id="graph-view-btn" class="action-button nav-button w-full text-left font-medium">Graph View</button>
                 </div>
                 <hr class="border-[--border-dark] section-sep">

           <!-- Save actions moved to left panel -->
                                <div class="space-y-2">
                            <button id="import-btn" class="action-button nav-button w-full text-left font-medium">Import</button>
                           <button id="import-from-git-btn" class="action-button nav-button w-full text-left font-medium">Import from Git</button>
                        </div>
                        <hr class="border-[--border-dark] section-sep">
                        <div class="space-y-2">
                            <button id="add-major-version-btn" class="action-button nav-button w-full text-left font-medium">Save Major Version</button>
               <button id="add-minor-version-btn" class="action-button nav-button w-full text-left font-medium">Save New Version</button>
               <button id="save-changes-btn" class="action-button nav-button w-full text-left font-medium">Save Changes</button>
               <button id="save-as-template-btn" class="action-button nav-button w-full text-left font-medium">Save as Template</button>
               <button id="fork-version-btn" class="action-button nav-button w-full text-left font-medium">Fork Version</button>
               <button id="delete-version-btn" class="action-button nav-button w-full text-left font-medium text-red-500 hover:bg-red-900/20 hover:border-red-800">Delete Version</button>
           </div>
            </aside>

            <!-- Config Dock (Photoshop-style) -->
            <div id="config-dock" class="relative border-r border-[--border-dark] flex flex-col items-center py-2" style="width: 48px; background-color: var(--panel-bg);">
                <!-- Icon buttons -->
                <div class="dock-item">
                <button id="dock-project-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="Project">
                    <!-- Folder icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12.75V8.25A2.25 2.25 0 014.5 6h3.879a2.25 2.25 0 001.59-.659l1.06-1.06A2.25 2.25 0 0112.62 3h6.88A2.25 2.25 0 0121.75 5.25V7.5m0 0v9A2.25 2.25 0 0119.5 18.75H4.5A2.25 2.25 0 012.25 16.5v-9A2.25 2.25 0 014.5 5.25H9"/></svg>
                </button>
                <span class="dock-tooltip">Project</span>
                </div>
                <div class="dock-item">
                <button id="dock-github-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="GitHub Repo">
                    <!-- GitHub icon -->
                    <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.477 2 2 6.486 2 12.019c0 4.425 2.865 8.178 6.839 9.504.5.092.682-.217.682-.483 0-.237-.009-.866-.013-1.7-2.782.604-3.369-1.342-3.369-1.342-.455-1.157-1.11-1.466-1.11-1.466-.907-.62.069-.607.069-.607 1.003.07 1.53 1.03 1.53 1.03.892 1.53 2.341 1.088 2.91.833.091-.647.35-1.088.636-1.339-2.22-.253-4.555-1.113-4.555-4.952 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.27.098-2.646 0 0 .84-.27 2.75 1.027A9.564 9.564 0 0 1 12 6.844c.851.004 1.707.115 2.506.338 1.909-1.297 2.748-1.027 2.748-1.027.546 1.376.203 2.393.1 2.646.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.696-4.566 4.944.359.31.678.92.678 1.854 0 1.338-.012 2.417-.012 2.746 0 .268.18.58.688.481C19.138 20.193 22 16.442 22 12.019 22 6.486 17.523 2 12 2Z"/>
                    </svg>
                </button>
                <span class="dock-tooltip">GitHub Repo</span>
                </div>
                <div class="dock-item">
                <button id="dock-tags-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="Tags">
                    <!-- Hashtag icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8 4v16M16 4v16M4 9h16M4 15h16"/>
                    </svg>
                </button>
                <span class="dock-tooltip">Tags</span>
                </div>
                <!-- Separator -->
                <div class="my-2 w-6 border-t border-[--border-dark] opacity-60"></div>
                <div class="dock-item">
                <button id="dock-llm-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="LLM Model">
                    <!-- Sparkles icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904l-1.06 3.181a.75.75 0 01-1.406 0l-1.06-3.181a4.5 4.5 0 00-2.847-2.847l-3.181-1.06a.75.75 0 010-1.406l3.181-1.06a4.5 4.5 0 002.847-2.847l1.06-3.181a.75.75 0 011.406 0l1.06 3.181a4.5 4.5 0 002.847 2.847l3.181 1.06a.75.75 0 010 1.406l-3.181 1.06a4.5 4.5 0 00-2.847 2.847zM16.5 4.5l.75-2.25.75 2.25L20.25 6l-2.25.75-.75 2.25-.75-2.25L15 6l1.5-1.5zm0 12l.75-2.25.75 2.25L20.25 18l-2.25.75-.75 2.25-.75-2.25L15 18l1.5-1.5z"/></svg>
                </button>
                <span class="dock-tooltip">LLM Model</span>
                </div>
                <div class="dock-item">
                <button id="dock-settings-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="LLM Parameters">
                    <!-- Sliders icon (clean and legible) -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 7h16M10 5v4M4 12h16M14 10v4M4 17h16M8 15v4"/>
                    </svg>
                </button>
                <span class="dock-tooltip">LLM Parameters</span>
                </div>
                <div class="dock-item">
                <button id="dock-input-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="Add Input">
                    <!-- Plus circle icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                </button>
                <span class="dock-tooltip">Add Input</span>
                </div>
                <div class="dock-item">
                <button id="dock-xml-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="XML Tags">
                    <!-- Code bracket icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 6.75L3 12l5.25 5.25m7.5-10.5L21 12l-5.25 5.25"/></svg>
                </button>
                <span class="dock-tooltip">XML Tags</span>
                </div>
                <div class="dock-item">
                <button id="dock-var-btn" class="p-2 rounded-md hover:bg-[#333]" aria-label="Variables">
                    <!-- Stack icon -->
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3l8.485 4.243L12 11.485 3.515 7.243 12 3zm0 8.485l8.485 4.243L12 20 3.515 15.728 12 11.485z"/></svg>
                </button>
                <span class="dock-tooltip">Variables</span>
                </div>

                <!-- Expanding drawer that opens to the left (right: full) -->
                <div id="config-drawer" class="absolute right-full top-0 h-full w-[320px] bg-[--card-bg-dark] border border-[--border-dark] rounded-md shadow-xl p-3 opacity-0 pointer-events-none transition-all duration-200 z-40">
                    <div class="flex items-center justify-between mb-2 gap-2">
                        <h3 id="config-drawer-title" class="text-sm font-semibold">LLM Parameters</h3>
                        <div class="flex items-center gap-1 ml-auto">
                            <!-- Header-scoped Add buttons (toggled per panel) -->
                            <button id="add-xml-tag-btn" class="hidden p-1 rounded hover:bg-[#333]" title="Add XML Tag">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6"/></svg>
                            </button>
                            <button id="add-var-library-btn" class="hidden p-1 rounded hover:bg-[#333]" title="Add Variable">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6"/></svg>
                            </button>
                            <button id="config-drawer-close" class="p-1 rounded hover:bg-[#333]" title="Close">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>
                            </button>
                        </div>
                    </div>
                    <hr class="border-[--border-dark] mb-2">
                    <div class="space-y-3 overflow-y-auto pr-1" style="max-height: calc(100% - 48px);">
                        <!-- Panel: Project (list only) -->
                        <div id="panel-project" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="project-search-input" placeholder="Search projects..." class="form-control compact-field rounded-md text-sm flex-1">
                                <button id="project-add-btn" class="p-1 rounded hover:bg-[#333]" title="Add Project">
                                    <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6"/></svg>
                                </button>
                            </div>
                            <div id="project-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                            <!-- keep hidden datalist for other UI parts that reference it -->
                            <datalist id="project-list-aside" class="hidden"></datalist>
                            <!-- hidden input kept for internal logic compatibility -->
                            <input id="project-name-input-aside" aria-label="Project" class="hidden">
                        </div>
                        <!-- Panel: LLM (list only) -->
                        <div id="panel-llm" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="llm-search-input" placeholder="Search models/groups..." class="form-control compact-field rounded-md text-sm flex-1">
                            </div>
                            <div id="llm-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                            <!-- hidden select kept for internal logic compatibility -->
                            <select id="llm-select" aria-label="LLM Model" class="hidden">
                                <option value="">Unspecified</option>
                            </select>
                        </div>
                        <!-- Panel: GitHub (repos assign) -->
                        <div id="panel-github" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="github-search-input" placeholder="Search repositories..." class="form-control compact-field rounded-md text-sm flex-1">
                            </div>
                            <div class="mt-1">
                                <div class="flex items-center justify-between mb-1">
                                    <button id="dock-github-repos-toggle" class="text-left text-xs font-semibold text-[--text-muted-dark] flex items-center gap-2">
                                        <span id="dock-github-repos-caret">▶</span> Repositories
                                    </button>
                                    <button id="dock-github-load-repos-btn" class="action-button text-xs">Load repos</button>
                                </div>
                                <div id="dock-github-available-repos" class="space-y-1 text-xs hidden"></div>
                            </div>
                            <div id="github-list-drawer" class="space-y-1 overflow-y-auto pr-1 mt-2"></div>
                            <p id="github-assign-hint" class="mt-2 text-[10px] text-[--text-muted-dark]"></p>
                        </div>
                        <!-- Panel: Tags (list only) -->
                        <div id="panel-tags" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="tags-search-input" placeholder="Search tags..." class="form-control compact-field rounded-md text-sm flex-1">
                                <button id="tags-add-btn" class="p-1 rounded hover:bg-[#333]" title="Add Tag">
                                    <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6"/></svg>
                                </button>
                            </div>
                            <div id="tags-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                            <!-- keep hidden chips container for internal logic; the list reflects its state -->
                            <div id="tags-container-aside" class="hidden"></div>
                            <!-- hidden input/dropdown kept for compatibility -->
                            <input id="tags-input-aside" class="hidden">
                            <div id="tags-dropdown-aside" class="hidden"></div>
                        </div>
                        <!-- Panel: XML Tags (list only) -->
                        <div id="panel-xml" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="xml-search-input" placeholder="Search XML tags..." class="form-control compact-field rounded-md text-sm flex-1">
                            </div>
                            <div id="xml-tags-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                        </div>
                        <!-- Panel: Var Library (list only) -->
                        <div id="panel-var" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="var-search-input" placeholder="Search variables..." class="form-control compact-field rounded-md text-sm flex-1">
                            </div>
                            <div id="var-library-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                        </div>
                        <!-- Panel: Add Input (list only) -->
                        <div id="panel-input" class="hidden">
                            <div class="flex items-center gap-2 pb-2 mb-2 border-b border-[--border-dark]">
                                <input id="input-search-input" placeholder="Search inputs..." class="form-control compact-field rounded-md text-sm flex-1">
                            </div>
                            <div id="add-input-list-drawer" class="space-y-1 overflow-y-auto pr-1"></div>
                        </div>

                        <!-- Panel: Settings (dynamic per model) -->
                        <div id="panel-settings" class="hidden">
                            <div id="dynamic-settings-container" class="space-y-2"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Área Principal de Edição -->
            <main class="flex-grow p-6 flex flex-col main-editor-area">
                
                
                <!-- Mapa de Navegação -->
                <div id="navigation-map" class="mb-4 p-2 bg-[--card-bg-dark] border border-[--border-dark] rounded-lg hidden"></div>

                <div class="editor-window flex-grow flex flex-col">
                    <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                        <div class="flex items-center flex-grow gap-1">
                            <input id="prompt-title-input" placeholder="Your prompt title..." class="form-input font-mono w-full px-2 py-2 text-xl font-medium">
                            <button id="toggle-syntax-highlighting" class="inline-flex items-center justify-center w-8 h-8 p-2 rounded-md text-[--text-muted-dark] hover:text-white hover:bg-[#333]" aria-label="Toggle syntax highlighting" role="switch" aria-checked="false" title="Syntax highlighting">
                                <span id="syntax-switch-label" class="font-mono text-xs tracking-tight leading-none select-none">&lt;/&gt;</span>
                            </button>
                            <button id="copy-prompt-btn" title="Copy prompt content" class="p-2 rounded-md text-[--text-muted-dark] hover:text-white hover:bg-[#333]">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                            </button>
                        </div>
                        <button id="find-btn" title="Find and Replace (Ctrl+F)" class="p-2 rounded-md text-[--text-muted-dark] hover:text-white hover:bg-[#333]">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                              <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" />
                            </svg>
                        </button>
                        <button id="toggle-comments-btn" title="Comments" class="p-2 rounded-md text-[--text-muted-dark] hover:text-white hover:bg-[#333]">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12c0 4.556-4.03 8.25-9 8.25a9.764 9.764 0 01-2.555-.337A5.972 5.972 0 015.41 20.97a5.969 5.969 0 01-.474-.065 4.48 4.48 0 00.978-2.025c.09-.457-.133-.901-.467-1.226C3.93 16.178 3 14.189 3 12c0-4.556 4.03-8.25 9-8.25s9 3.694 9 8.25z" />
                            </svg>
                        </button>
                    </div>
                    
                    <!-- Find and Replace Bar -->
                    <div id="find-replace-bar">
                        <div class="grid grid-cols-2 gap-2">
                            <input id="find-input" type="text" placeholder="Find..." class="form-control text-xs rounded-md py-1 px-2">
                            <input id="replace-input" type="text" placeholder="Replace with..." class="form-control text-xs rounded-md py-1 px-2">
                        </div>
                        <div class="flex items-center gap-2 mt-2">
                            <span id="find-counter" class="text-xs font-mono text-[--text-muted-dark]">0/0</span>
                            <button id="prev-btn" class="action-button text-xs p-1" disabled>Previous</button>
                            <button id="next-btn" class="action-button text-xs p-1" disabled>Next</button>
                            <button id="replace-btn" class="action-button text-xs" disabled>Replace</button>
                            <button id="replace-all-btn" class="action-button text-xs" disabled>Replace All</button>
                            <button id="close-find-btn" class="action-button text-xs p-1 ml-auto">&times;</button>
                        </div>
                    </div>
                    <div class="flex-grow p-1 relative" id="editor-container">
                        <textarea id="main-editor" placeholder="Have a new big idea to change the world with your prompt? 
Write, right here, right now. Show me your mana!" class="form-input font-mono w-full h-full p-4 text-base leading-relaxed resize-none"></textarea>
                        <div id="syntax-overlay" class="absolute top-0 left-0 w-full h-full p-4 pointer-events-none"></div>
                        <div id="snippet-buttons-overlay" class="absolute top-0 left-0 w-full h-full p-4 pointer-events-none"></div>
                    </div>
                    <!-- Chat Assistant (above Dependency) -->
                    <div id="chat-assistant-bar" class="p-2 border-t border-[--border-dark]">
                        <div class="flex items-center justify-between gap-3 mb-2">
                            <div class="flex items-center gap-2 flex-wrap">
                                <span class="text-xs font-bold text-[--text-muted-dark]">Chat Assistant</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <button id="clear-chat-btn" class="action-button text-xs">Clear</button>
                            </div>
                        </div>
                        <div id="chat-messages" class="max-h-56 overflow-y-auto rounded-md border border-[--border-dark] p-2 space-y-2 bg-[--card-bg-dark]"></div>
                        <div class="mt-2 flex items-center gap-2">
                            <textarea id="chat-input" rows="1" placeholder="Ask something to help craft your prompt..." class="form-input font-sans w-full p-2 text-sm leading-relaxed resize-none rounded-md" style="background-color: var(--input-bg);"></textarea>
                            <button id="send-chat-btn" class="action-button primary text-xs whitespace-nowrap h-fit self-end">Send</button>
                        </div>
                    </div>
                    <!-- Dependency Bar -->
                    <div id="dependency-bar" class="p-2 border-t border-[--border-dark] relative">
                        <div class="flex items-center justify-between gap-3">
                            <!-- Left half: Dependency tags and Manage -->
                            <div class="flex items-center gap-2 flex-wrap">
                                <span class="text-xs font-bold text-[--text-muted-dark]">Dependency</span>
                                <div id="dependency-tag-container" class="flex items-center gap-2 flex-wrap"></div>
                                <div id="dependencies-popover">
                                    <button id="edit-dependencies-btn" class="action-button text-xs">Manage</button>
                                    <!-- Larger popover for dependencies management (opens upwards) -->
                                    <div id="dependencies-dropdown" class="hidden absolute bg-[--card-bg-dark] border border-[--border-dark] rounded-md shadow-xl w-[640px] max-w-[90vw] z-50">
                                        <div class="p-2 border-b border-[--border-dark]">
                                            <input id="dependencies-search" type="text" placeholder="Search prompt..." class="form-control w-full rounded-md py-1.5 px-3 text-sm">
                                        </div>
                                        <div id="dependencies-list" class="max-h-96 overflow-y-auto"></div>
                                        <div class="p-2 border-t border-[--border-dark] flex justify-end gap-2">
                                            <button id="deps-cancel-btn" class="action-button text-xs">Cancel</button>
                                            <button id="deps-apply-btn" class="action-button primary text-xs">Apply</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!-- Right half: Chat Assistant model selector -->
                            <div class="flex items-center gap-2 flex-wrap">
                                <span class="text-xs font-bold text-[--text-muted-dark]">Assistant Model</span>
                                <select id="chat-model-select" class="form-control text-xs rounded-md py-1 px-2 min-w-[220px]"></select>
                            </div>
                        </div>
                    </div>
                    <!-- Variables Section -->
                     <div id="variables-section" class="p-4 border-t border-[--border-dark] hidden">
                         <h3 class="text-sm font-bold text-[--text-muted-dark] mb-2">Prompt Variables</h3>
                         <div id="variables-container" class="space-y-2"></div>
                     </div>
                    <!-- Comments Section -->
                    <div id="comments-section" class="p-4 border-t border-[--border-dark] hidden">
                        <h3 class="text-sm font-bold text-[--text-muted-dark] mb-2">Version Comments</h3>
                        <textarea id="comments-textarea" placeholder="Note the purpose of the version, tests, results..." class="form-input font-sans w-full h-24 p-2 text-sm leading-relaxed resize-none rounded-md" style="background-color: var(--input-bg);"></textarea>
                    </div>
                     <div class="flex items-center justify-between p-2 border-t border-[--border-dark]">
                                                 <div id="status-selector-container" class="flex items-center justify-center gap-2">
                                                        <button id="kanban-btn" class="action-button text-xs px-2 py-1 font-medium" title="Open Kanban" aria-label="Open Kanban">
                                                                <!-- simple kanban icon -->
                                                                <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                                                                    <rect x="3" y="4" width="6" height="16" rx="1"/>
                                                                    <rect x="10" y="4" width="4" height="10" rx="1"/>
                                                                    <rect x="15" y="4" width="6" height="6" rx="1"/>
                                                                </svg>
                                                        </button>
                                                        <div class="status-selector flex rounded-lg overflow-hidden">
                                <button class="status-option px-4" data-status="idea">Idea</button>
                                <button class="status-option px-4" data-status="write">Write</button>
                                <button class="status-option px-4" data-status="test">Test</button>
                                <button class="status-option px-4" data-status="ready">Ready</button>
                                <button class="status-option px-4" data-status="archive">Archive</button>
                            </div>
                        </div>
                         <div id="editor-stats" class="text-xs font-mono pr-4">0 tokens / 0 words / 0 characters</div>
                     </div>
                </div>
            </main>

            <!-- Painel de Ações (Direita) -->
            <aside class="action-panel p-4 flex flex-col">
                <div class="flex flex-col flex-grow overflow-hidden">
                    <div class="flex justify-between items-center mb-3">
                        <h2 class="text-sm font-semibold">Versions</h2>
                        <button id="compare-versions-btn" class="action-button text-xs" disabled>Compare</button>
                    </div>

                    <div id="filters-container" class="space-y-3 mb-3 flex-shrink-0">
                        <div class="relative">
                            <input id="search-versions-input" placeholder="Search by title, project or tag..." class="form-control w-full rounded-md py-1.5 px-3 text-sm focus:ring-2">
                        </div>
                        <div id="status-filter-container" class="flex flex-col gap-1">
                            <label for="status-filter-select" class="text-xs font-medium text-[--text-muted-dark]">Filter by Status</label>
                            <select id="status-filter-select" class="form-control text-xs rounded-md py-1 px-2 w-full">
                                <option value="all">All</option>
                                <option value="idea">Idea</option>
                                <option value="write">Write</option>
                                <option value="test">Test</option>
                                <option value="ready">Ready</option>
                                <option value="archive">Archive</option>
                            </select>
                        </div>
                        <div id="project-filter-container" class="flex flex-col gap-1">
                            <label for="project-filter-select" class="text-xs font-medium text-[--text-muted-dark]">Filter by Project</label>
                            <select id="project-filter-select" class="form-control text-xs rounded-md py-1 px-2 w-full"></select>
                        </div>
                    </div>

                    <hr class="border-[--border-dark] mb-3">

                    <div id="versions-history-list" class="flex-grow overflow-y-auto space-y-1 pr-2">
                        <!-- Lista hierárquica de versões será inserida aqui -->
                    </div>
                </div>
                <div class="mt-auto space-y-2">
                    <hr class="border-[--border-dark] my-2">
                    <button id="commit-changes-btn" class="action-button nav-button primary w-full text-left font-medium">Commit Changes</button>
                    <button id="download-json-btn" class="action-button nav-button primary w-full text-left font-medium">Json Download</button>
                    <button id="download-md-btn" class="action-button nav-button primary w-full text-left font-medium">Markdown Download</button>
                    <button id="download-txt-btn" class="action-button nav-button primary w-full text-left font-medium">Text Download</button>
                </div>
            </aside>
        </div>
        <!-- API Console + Kanban + DB status (bottom-left corner) -->
    <div class="fixed bottom-3 left-4 z-30 flex flex-col items-start gap-2">
            <button id="api-console-btn" class="action-button nav-button text-xs px-2 py-1 font-medium hover:bg-[#333]">API Console</button>
            <div class="flex flex-col items-start gap-1">
                <span id="db-status-pill" class="text-xs font-mono px-2 py-0.5 border border-[--border-dark] rounded-md text-[--text-muted-dark]"></span>
                <button id="api-status-pill" class="text-xs font-mono px-2 py-0.5 border border-[--border-dark] rounded-md text-[--text-muted-dark] hover:bg-[#333]">API STATUS</button>
            </div>
            <input id="import-file-input" type="file" accept=".txt,.md,.pdf,.docx,.doc" class="hidden" />
        </div>
    </div>

    <!-- Modal: Kanban Board -->
    <div id="kanban-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex items-center gap-3">
                <h2 class="text-xl font-bold">Kanban</h2>
                <div class="ml-auto flex items-center gap-2 text-xs text-[--text-muted-dark]">
                    <label class="flex items-center gap-1">
                        <span>Scope</span>
                        <select id="kanban-scope-select" class="form-control py-1 px-2 text-xs rounded-md">
                            <option value="project">By Project</option>
                            <option value="prompt">By Prompt</option>
                        </select>
                    </label>
                    <select id="kanban-entity-select" class="form-control py-1 px-2 text-xs rounded-md"></select>
                    <button id="close-kanban-modal" class="p-2 rounded-full hover:bg-[#333]" title="Close">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <div class="p-4 flex-1 overflow-hidden">
                <div id="kanban-board" class="grid grid-cols-5 gap-3 h-full">
                    <!-- Columns will be rendered here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Modal: API Status -->
    <div id="api-status-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[80vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center gap-3">
                <h2 class="text-xl font-bold">API STATUS</h2>
                <div class="ml-auto flex items-center gap-2 text-xs text-[--text-muted-dark]">
                    <button id="close-api-status-modal" class="p-2 rounded-full hover:bg-[#333]" title="Close">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <div class="p-4 flex-1 overflow-auto">
                <div id="api-status-summary" class="text-sm font-mono mb-3"></div>
                <div id="api-status-errors" class="text-xs text-red-500 mb-3 hidden"></div>
                <div class="grid grid-cols-2 gap-4">
                    <div class="panel-soft p-3 rounded-md">
                        <h3 class="font-semibold text-sm mb-2">Online</h3>
                        <ul id="api-list-online" class="text-xs space-y-1"></ul>
                    </div>
                    <div class="panel-soft p-3 rounded-md">
                        <h3 class="font-semibold text-sm mb-2">Offline</h3>
                        <ul id="api-list-offline" class="text-xs space-y-1"></ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal: Run Prompt -->
    <div id="run-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center gap-3">
                <h2 class="text-xl font-bold">Run Prompt</h2>
                <div class="ml-auto flex items-center gap-2 text-xs text-[--text-muted-dark]">
                    <span id="run-active-llm" class="font-mono"></span>
                    <button id="close-run-modal" class="p-2 rounded-full hover:bg-[#333]" title="Close">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <div class="flex-1 grid grid-cols-2 gap-4 p-4 overflow-hidden">
                <div class="panel-soft p-3 rounded-md h-full flex flex-col overflow-hidden">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="font-semibold text-sm">Request</h3>
                        <div class="flex items-center gap-2">
                            <div class="flex items-center gap-1 text-[10px] text-[--text-muted-dark]">
                                <span>Preview:</span>
                                <button id="req-toggle-full" class="px-2 py-0.5 border border-[--border-dark] rounded-md bg-[--panel-bg] req-preview active">Full Request</button>
                                <button id="req-toggle-only" class="px-2 py-0.5 border border-[--border-dark] rounded-md req-preview">Only Prompt</button>
                            </div>
                            <button id="copy-run-request-btn" class="action-button text-xs">Copy</button>
                        </div>
                    </div>
                    <pre id="run-request-view" class="font-mono text-xs whitespace-pre-wrap flex-1 overflow-auto"></pre>
                </div>
                <div class="panel-soft p-3 rounded-md h-full flex flex-col overflow-hidden">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="font-semibold text-sm">Response</h3>
                        <div class="flex items-center gap-2">
                            <button id="save-run-response-btn" class="action-button text-xs">Save</button>
                            <button id="open-response-log-btn" class="action-button text-xs">Response Log</button>
                            <button id="copy-run-response-btn" class="action-button text-xs">Copy</button>
                        </div>
                    </div>
                    <div id="run-loading" class="text-xs text-[--text-muted-dark] hidden">Running…</div>
                    <pre id="run-response-view" class="font-mono text-xs whitespace-pre-wrap flex-1 overflow-auto"></pre>
                </div>
            </div>
            <div class="p-3 border-t border-[--border-dark] flex items-center gap-3">
                <button id="run-cancel-btn" class="action-button">Close</button>
                <button id="run-execute-btn" class="action-button primary">Run</button>
                <span id="run-error" class="text-xs text-red-500 font-mono"></span>
            </div>
        </div>
    </div>

    <!-- Modal: Response Log -->
    <div id="response-log-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[80vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center gap-3">
                <h2 class="text-xl font-bold">Response Log</h2>
                <div class="ml-auto flex items-center gap-2 text-xs text-[--text-muted-dark]">
                    <button id="close-response-log-modal" class="p-2 rounded-full hover:bg-[#333]" title="Close">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <div class="p-3 flex items-center gap-2 border-b border-[--border-dark] text-xs">
                <input id="resp-log-search" placeholder="Search..." class="form-control rounded-md py-1 px-2 text-xs w-56">
                <button id="resp-log-refresh" class="action-button text-xs">Refresh</button>
            </div>
            <div class="flex-1 overflow-auto">
                <table class="w-full text-xs">
                    <thead class="text-[--text-muted-dark] border-b border-[--border-dark]">
                        <tr>
                            <th class="text-left p-2">Prompt</th>
                            <th class="text-left p-2">Version</th>
                            <th class="text-left p-2">Model</th>
                            <th class="text-left p-2">Date</th>
                            <th class="text-left p-2">Rating</th>
                            <th class="text-left p-2">Comment</th>
                            <th class="text-left p-2">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="response-log-tbody"></tbody>
                </table>
            </div>
            <div class="p-3 border-t border-[--border-dark] text-xs flex items-center justify-between">
                <div>
                    <button id="resp-log-prev" class="action-button text-xs">Prev</button>
                    <button id="resp-log-next" class="action-button text-xs">Next</button>
                </div>
                <span id="resp-log-status" class="text-[--text-muted-dark]"></span>
            </div>
        </div>
    </div>

    <!-- Modal: Import from Git -->
    <div id="import-git-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center gap-3">
                <h2 class="text-xl font-bold">Import from GitHub</h2>
                <div class="ml-auto flex items-center gap-2">
                    <button id="refresh-git-browser-btn" class="action-button text-xs">Refresh</button>
                    <button id="close-import-git-modal" class="p-2 rounded-full hover:bg-[#333]" title="Close">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <div class="flex-1 grid grid-cols-2 gap-0 min-h-[360px] max-h-full">
                <div class="border-r border-[--border-dark] p-3 overflow-y-auto">
                    <div class="flex items-center justify-between mb-2">
                        <div class="text-xs font-semibold text-[--text-muted-dark]">Repositories</div>
                        <button id="git-browser-load-repos-btn" class="action-button text-xs">Load</button>
                    </div>
                    <div id="git-browser-repos" class="space-y-1 text-sm"></div>
                </div>
                <div class="p-3 overflow-y-auto">
                    <div class="flex items-center justify-between mb-2">
                        <div class="text-xs font-semibold text-[--text-muted-dark]">Markdown files</div>
                        <input id="git-files-filter" placeholder="Filter (*.md)" class="form-control compact-field rounded-md text-xs w-40">
                    </div>
                    <div id="git-browser-files" class="space-y-1 text-sm"></div>
                </div>
            </div>
            <div class="p-3 border-t border-[--border-dark] flex items-center gap-3">
                <div class="flex-1 flex items-center gap-2">
                    <input id="git-import-title" type="text" placeholder="Prompt title (optional)" class="form-control rounded-md py-1 px-2 text-sm flex-1">
                    <input id="git-import-project" list="project-list-aside" placeholder="Project (optional)" class="form-control rounded-md py-1 px-2 text-sm w-48">
                </div>
                <button id="git-import-cancel" class="action-button">Cancel</button>
                <button id="git-import-confirm" class="action-button primary" disabled>Load into editor</button>
            </div>
        </div>
    </div>

    <!-- Modal de Confirmação -->
    <div id="confirm-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-[--card-bg-dark] p-6 rounded-lg shadow-xl max-w-sm w-full border border-[--border-dark]">
            <h3 id="confirm-modal-title" class="text-lg font-bold mb-4"></h3>
            <p id="confirm-modal-text" class="text-[--text-muted-dark] mb-6"></p>
            <div id="confirm-modal-input-container" class="mb-4 hidden">
                <input id="confirm-modal-input" type="text" class="form-control w-full rounded-md py-1.5 px-3 text-sm">
            </div>
            <div id="confirm-modal-buttons" class="flex justify-end gap-4">
                <!-- Botões do modal serão inseridos aqui -->
            </div>
        </div>
    </div>

    <!-- Modal de Importação -->
    <div id="import-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-full max-w-lg rounded-lg shadow-xl border border-[--border-dark]">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">Import Document</h2>
                <button id="close-import-modal" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="p-4 space-y-3">
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Prompt name</label>
                    <input id="import-prompt-name" type="text" placeholder="Name..." class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Project</label>
                    <input id="import-project" list="project-list-aside" placeholder="Select or create..." class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">LLM Model</label>
                    <select id="import-llm" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                        <option value="">Unspecified</option>
                    </select>
                </div>
            </div>
            <div class="p-4 border-t border-[--border-dark] flex justify-end gap-3">
                <button id="cancel-import" class="action-button">Cancel</button>
                <button id="confirm-import" class="action-button primary">Import</button>
            </div>
        </div>
    </div>

    <!-- Modal: Commit Changes -->
    <div id="commit-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-full max-w-md rounded-lg shadow-xl border border-[--border-dark]">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">Commit Changes</h2>
                <button id="close-commit-modal" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="p-4 space-y-3">
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Repository</label>
                    <div id="commit-repo-label" class="text-sm text-[--text-muted-dark] font-mono"></div>
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Branch</label>
                    <select id="commit-branch" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm"></select>
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">File path</label>
                    <input id="commit-file-path" type="text" placeholder="e.g. docs/prompt.md" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm">
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Commit message</label>
                    <input id="commit-message" type="text" placeholder="Describe your change" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm">
                </div>
                <div>
                    <label class="text-xs font-medium text-[--text-muted-dark]">Latest commit</label>
                    <div id="commit-latest-info" class="mt-1 text-xs text-[--text-muted-dark] font-mono break-words"></div>
                </div>
            </div>
            <div class="p-4 border-t border-[--border-dark] flex justify-end gap-3">
                <button id="cancel-commit" class="action-button">Cancel</button>
                <button id="confirm-commit" class="action-button primary">Commit</button>
            </div>
        </div>
    </div>

    <!-- Modal: API Console -->
    <div id="api-console-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">API Console</h2>
                <button id="close-api-console-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="flex flex-col md:flex-row flex-1 overflow-hidden">
                <!-- Left: Nav -->
                <div class="w-full md:w-56 border-r border-[--border-dark] p-4 space-y-2 flex-shrink-0">
                    <button data-api-tab="llm" class="action-button nav-button w-full text-left text-sm font-medium api-tab-btn">LLM</button>
                    <button data-api-tab="git" class="action-button nav-button w-full text-left text-sm font-medium api-tab-btn">GitHub</button>
                </div>
                <!-- Right: Content -->
                <div class="flex-1 p-4 overflow-y-auto">
                    
                    <!-- LLM -->
                    <div id="api-panel-llm" class="space-y-4 hidden">
                        <p class="text-white text-base md:text-lg font-medium">Set your LLM API to use in the app.</p>
                        <div class="space-y-3">
                            <div class="md:w-1/2">
                                <label class="text-xs font-medium text-[--text-muted-dark]">LLM SERVER</label>
                                <select id="llm-api-server-select" class="form-control bg-[#111] w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2"></select>
                            </div>
                            <div class="md:w-1/2">
                                <label class="text-xs font-medium text-[--text-muted-dark]">LLM API KEY</label>
                                <input id="llm-api-key-input" type="password" placeholder="sk-..." class="form-control bg-[#111] w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                            </div>
                            <div class="md:w-1/2">
                                <label class="text-xs font-medium text-[--text-muted-dark]">ADD LLM by CURL</label>
                                <textarea id="llm-curl-input" rows="3" placeholder="Paste a curl command (optional)" class="form-control bg-[#111] w-full mt-1 rounded-md px-2 py-1 text-xs"></textarea>
                            </div>
                            <div class="md:w-1/2">
                                <div class="flex items-center gap-2">
                                    <button id="llm-add-api-btn" class="action-button primary w-full md:w-auto">ADD LLM</button>
                                    <span id="llm-add-status" class="text-xs font-mono text-[--text-muted-dark]"></span>
                                </div>
                            </div>
                        </div>
                        <hr class="border-[--border-dark]">
                        <div class="flex items-center justify-between">
                            <h3 class="text-sm font-semibold">LLM Connections</h3>
                        </div>
                        <div id="llm-api-list" class="space-y-2"></div>
                        <div class="mt-3">
                            <div class="flex items-center justify-between mb-1">
                                <button id="llm-provider-openai-toggle" class="text-left text-xs font-semibold text-[--text-muted-dark] flex items-center gap-2">
                                    <span id="llm-provider-openai-caret">▶</span> LLM Models
                                </button>
                                <!-- Per-connection 'Load models' buttons are rendered below; global button removed -->
                            </div>
                            <div id="llm-available-models" class="space-y-1 text-xs pl-4 hidden"></div>
                        </div>
                    </div>
                    <!-- Git -->
                    <div id="api-panel-git" class="space-y-4 hidden">
                        <p class="text-white text-base md:text-lg font-medium">Integrate your GitHub account to publish prompts to repositories.</p>
                        <div class="space-y-3">
                            <div class="md:w-1/2">
                                <label class="text-xs font-medium text-[--text-muted-dark]">GitHub Token</label>
                                <input id="github-token-input" type="password" placeholder="ghp_..." class="form-control bg-[#111] w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                            </div>
                            <div class="md:w-1/2">
                                <label class="text-xs font-medium text-[--text-muted-dark]">Default Repo (owner/repo)</label>
                                <input id="github-repo-input" type="text" placeholder="owner/repo" class="form-control bg-[#111] w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                            </div>
                            <div class="md:w-1/2 flex items-center gap-2">
                                <button id="github-test-btn" class="action-button">Test</button>
                                <span id="github-test-status" class="text-xs font-mono"></span>
                            </div>
                            <div class="md:w-1/2">
                                <button id="github-add-repo-btn" class="action-button primary w-full md:w-auto">Add repository</button>
                            </div>
                        </div>
                        <hr class="border-[--border-dark]">
                        <div class="flex items-center justify-between">
                            <h3 class="text-sm font-semibold">Repositories</h3>
                        </div>
                        <div id="github-repo-list" class="space-y-2"></div>
                        <div class="mt-3">
                            <div class="flex items-center justify-between mb-1">
                                <button id="github-repos-toggle" class="text-left text-xs font-semibold text-[--text-muted-dark] flex items-center gap-2">
                                    <span id="github-repos-caret">▶</span> Repositories
                                </button>
                                <button id="github-load-repos-btn" class="action-button text-xs">Load repos</button>
                            </div>
                            <div id="github-available-repos" class="space-y-1 text-xs hidden"></div>
                        </div>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal da Galeria -->
    <div id="gallery-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">Gallery</h2>
                <button id="close-gallery-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div id="gallery-grid" class="p-6 grid gap-3 overflow-y-auto justify-start" style="grid-template-columns: repeat(auto-fill, minmax(280px, 280px));">
                <!-- Cards da galeria serão inseridos aqui -->
            </div>
        </div>
    </div>

    <!-- Projects Modal -->
    <div id="projects-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">Projects</h2>
                <div class="flex items-center gap-4">
                    <button id="add-project-btn" class="action-button primary text-sm">Add Project</button>
                    <button id="close-projects-btn" class="p-2 rounded-full hover:bg-[#333]">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div id="projects-list-container" class="p-6 overflow-y-auto">
                <!-- Project list will be inserted here -->
            </div>
            <div id="add-project-popup" class="modal-overlay hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
                <div class="bg-[--card-bg-dark] p-6 rounded-lg shadow-xl max-w-sm w-full border border-[--border-dark]">
                    <h3 class="text-lg font-bold mb-4">Add New Project</h3>
                    <p class="text-[--text-muted-dark] mb-6">Enter the name of the new project:</p>
                    <input id="new-project-name-input" type="text" placeholder="Project name..." class="form-control w-full rounded-md py-1.5 px-3 text-sm mb-4">
                    <div class="flex justify-end gap-4">
                        <button id="cancel-add-project-btn" class="action-button">Cancel</button>
                        <button id="confirm-add-project-btn" class="action-button primary">Add</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Templates -->
    <div id="templates-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <div class="flex items-center gap-4">
                    <h2 class="text-xl font-bold">Templates</h2>
                    <div class="hidden sm:block">
                        <label for="templates-project-filter" class="text-xs font-medium text-[--text-muted-dark]">Filter by Project:</label>
                        <select id="templates-project-filter" class="form-control w-auto mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2"></select>
                    </div>
                </div>
                <button id="close-templates-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div id="templates-grid-container" class="p-6 grid gap-3 overflow-y-auto justify-start" style="grid-template-columns: repeat(auto-fill, minmax(280px, 280px));">
                <!-- Cards de templates serão inseridos aqui -->
            </div>
        </div>
    </div>

    <!-- Modal Visualizador de Dependência -->
    <div id="dependency-viewer-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 id="dependency-viewer-title" class="text-xl font-bold">Dependency Viewer</h2>
                <button id="close-dependency-viewer-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="p-6 overflow-y-auto">
                <div class="panel-soft p-4">
                    <pre id="dependency-viewer-content" class="text-sm font-mono whitespace-pre-wrap"></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Visualizador de Comentários -->
    <div id="comments-viewer-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
        <div class="bg-[--card-bg-dark] max-w-md w-full max-h-[70vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-3 border-b border-[--border-dark] flex justify-between items-center">
                <h2 id="comments-viewer-title" class="text-lg font-bold">Comments</h2>
                <button id="close-comments-viewer-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="p-4 overflow-y-auto">
                <div class="panel-soft p-3">
                    <pre id="comments-viewer-content" class="text-sm font-sans whitespace-pre-wrap leading-relaxed"></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Read Mode -->
    <div id="read-mode-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center hidden z-50 p-8 cursor-pointer">
        <div class="w-full max-w-4xl h-full max-h-[90vh] text-[--text-dark] p-8 overflow-hidden flex flex-col cursor-default">
            <div class="mb-3 flex items-start justify-between gap-4">
                <div>
                    <h2 id="read-mode-title" class="text-xl font-bold"></h2>
                    <div id="read-mode-meta" class="text-sm text-[--text-muted-dark] mt-1"></div>
                    <div id="read-mode-comments" class="text-sm text-[--text-muted-dark] mt-2 whitespace-pre-wrap"></div>
                </div>
                <div id="read-mode-stats" class="text-xs font-mono mt-1 text-right"></div>
            </div>
            <hr class="border-[--border-dark] my-2">
            <pre id="read-mode-content" class="flex-grow overflow-y-auto font-mono text-lg leading-relaxed whitespace-pre-wrap"></pre>
        </div>
    </div>

    <!-- Modal Dashboard -->
    <div id="dashboard-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-4">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-3 border-b border-[--border-dark] flex justify-between items-center flex-shrink-0">
                <div class="flex items-end gap-4">
                    <h2 class="text-xl font-bold">Dashboard</h2>
                    <div>
                        <label for="dashboard-period-select" class="text-xs font-medium text-[--text-muted-dark]">Group by:</label>
                        <select id="dashboard-period-select" class="form-control rounded-md py-1 px-2 text-xs focus:ring-2">
                            <option value="day">Day</option>
                            <option value="week">Week</option>
                            <option value="month" selected>Month</option>
                        </select>
                    </div>
                </div>
                <button id="close-dashboard-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="flex-grow p-3 overflow-auto">
                <div class="grid gap-3" style="grid-template-columns: repeat(3, minmax(0, 1fr));">
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Tokens / Words / Characters</h3>
                        <div class="chart-box"><canvas id="tokensChart"></canvas></div>
                    </div>
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Versions Created</h3>
                        <div class="chart-box"><canvas id="promptsChart"></canvas></div>
                    </div>
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Most Used Models</h3>
                        <div class="chart-box"><canvas id="modelsChart"></canvas></div>
                    </div>
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Prompts per Project</h3>
                        <div class="chart-box"><canvas id="projectsChart"></canvas></div>
                    </div>
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Status Distribution</h3>
                        <div class="chart-box"><canvas id="statusChart"></canvas></div>
                    </div>
                    <div class="panel-soft p-2 rounded-md">
                        <h3 class="font-semibold text-sm mb-1">Top Tags</h3>
                        <div class="chart-box"><canvas id="tagsChart"></canvas></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Comparador de Versões -->
    <div id="diff-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 id="diff-modal-title" class="text-xl font-bold">Comparing Versions</h2>
                <button id="close-diff-modal-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="flex-grow grid grid-cols-2 gap-4 p-4 overflow-hidden w-full">
                <div class="diff-view p-4 rounded-md font-mono text-sm whitespace-pre-wrap h-full flex flex-col">
                    <h3 id="diff-title-a" class="font-bold text-lg mb-2"></h3>
                    <div id="diff-meta-a" class="text-xs font-sans text-[--text-muted-dark] mb-2"></div>
                    <div id="diff-comments-a" class="text-xs font-sans text-[--text-muted-dark] mb-2 whitespace-pre-wrap"></div>
                    <hr class="border-[--border-dark] my-2">
                    <div id="diff-panel-a" class="flex-grow overflow-auto"></div>
                </div>
                <div class="diff-view p-4 rounded-md font-mono text-sm whitespace-pre-wrap h-full flex flex-col">
                    <h3 id="diff-title-b" class="font-bold text-lg mb-2"></h3>
                    <div id="diff-meta-b" class="text-xs font-sans text-[--text-muted-dark] mb-2"></div>
                    <div id="diff-comments-b" class="text-xs font-sans text-[--text-muted-dark] mb-2 whitespace-pre-wrap"></div>
                    <hr class="border-[--border-dark] my-2">
                    <div id="diff-panel-b" class="flex-grow overflow-auto"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal Gráfico de Dependências -->
    <div id="dependency-graph-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">Graph View</h2>
                <button id="close-dependency-graph-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <!-- Seção de Filtros do Gráfico -->
            <div id="graph-filters" class="p-4 border-b border-[--border-dark] flex items-end gap-4 flex-shrink-0">
                <div>
                    <label for="graph-project-filter" class="text-xs font-medium text-[--text-muted-dark]">Filter by Project:</label>
                    <select id="graph-project-filter" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                        <!-- Opções populadas via JS -->
                    </select>
                </div>
                <button id="create-connection-btn" class="action-button text-sm">Create Connection</button>
                <button id="delete-connection-btn" class="action-button text-sm" disabled>Delete Connection</button>
            </div>
            <div class="flex-grow p-4 overflow-hidden relative">
                <svg id="dependency-graph-svg"></svg>
                <div id="graph-tooltip"></div>
            </div>
        </div>
    </div>

    <!-- Modal Gerenciador de Listas -->
    <div id="list-manager-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center">
                <h2 class="text-xl font-bold">List Manager</h2>
                <button id="close-list-manager-btn" class="p-2 rounded-full hover:bg-[#333]">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="flex-grow grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 p-4 overflow-hidden w-full">
                <!-- Column XML Tags -->
                <div class="flex flex-col gap-3 p-3 rounded-md overflow-hidden" style="background-color: var(--panel-bg);">
                    <h3 class="font-semibold flex-shrink-0">XML Tags</h3>
                    <div class="flex gap-2 flex-shrink-0">
                        <input id="add-xml-tag-manager-input" type="text" placeholder="New XML tag..." class="form-control w-full rounded-md py-1 px-2 text-sm">
                        <button id="add-xml-tag-manager-btn" class="action-button primary px-3">+</button>
                    </div>
                    <div id="xml-tags-manager-container" class="flex-grow overflow-y-auto space-y-2 pr-2"></div>
                </div>
                <!-- Column Var Library -->
                <div class="flex flex-col gap-3 p-3 rounded-md overflow-hidden" style="background-color: var(--panel-bg);">
                    <h3 class="font-semibold flex-shrink-0">Variables</h3>
                    <div class="flex gap-2 flex-shrink-0">
                        <input id="add-var-library-manager-input" type="text" placeholder="New variable..." class="form-control w-full rounded-md py-1 px-2 text-sm">
                        <button id="add-var-library-manager-btn" class="action-button primary px-3">+</button>
                    </div>
                    <div id="var-library-manager-container" class="flex-grow overflow-y-auto space-y-2 pr-2"></div>
                </div>
                <!-- Column General Tags -->
                <div class="flex flex-col gap-3 p-3 rounded-md overflow-hidden" style="background-color: var(--panel-bg);">
                    <h3 class="font-semibold flex-shrink-0">General Tags (#)</h3>
                    <p class="text-xs text-[--text-muted-dark] flex-shrink-0">Deleting a tag here will remove it from all prompts.</p>
                    <div class="flex gap-2 flex-shrink-0">
                        <input id="add-general-tag-manager-input" type="text" placeholder="New general tag..." class="form-control w-full rounded-md py-1 px-2 text-sm">
                        <button id="add-general-tag-manager-btn" class="action-button primary px-3">+</button>
                    </div>
                    <div id="general-tags-manager-container" class="flex-grow overflow-y-auto space-y-2 pr-2"></div>
                </div>
                <!-- Column Target LLM -->
                <div class="flex flex-col gap-3 p-3 rounded-md overflow-hidden" style="background-color: var(--panel-bg);">
                    <div class="flex-shrink-0">
                        <h3 class="font-semibold">LLM Model</h3>
                        <p class="text-xs text-[--text-muted-dark] mt-2">Models are loaded from the provider API. You can organize them by category. Manual model addition is disabled.</p>
                        <div class="flex gap-2 mt-3">
                            <input id="add-llm-category-manager-input" type="text" placeholder="Search a Model" class="form-control w-full rounded-md py-1 px-2 text-sm">
                            <button id="add-llm-category-manager-btn" class="action-button primary px-3">+</button>
                        </div>
                    </div>
                    <div id="llm-manager-container" class="flex-grow overflow-y-auto space-y-2 pr-2 mt-2"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Input Gallery -->
    <div id="input-gallery-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
    <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center flex-shrink-0">
                <h2 class="text-xl font-bold">Input Gallery</h2>
                <div class="flex items-center gap-4">
                    <button id="save-input-gallery-btn" class="action-button primary">Save Input</button>
                    <button id="close-input-gallery-btn" class="p-2 rounded-full hover:bg-[#333]">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <div class="flex-grow flex overflow-hidden">
                <aside id="input-gallery-list-container" class="sidebar p-4 border-r border-[--border-dark] flex flex-col">
                    <div class="mb-3 flex-shrink-0">
                        <label for="input-gallery-project-filter" class="text-xs font-medium text-[--text-muted-dark]">Filter by Project:</label>
                        <select id="input-gallery-project-filter" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2"></select>
                    </div>
                    <button id="add-new-input-btn" class="action-button w-full mb-4">New Input</button>
                    <div id="input-gallery-list" class="flex-grow overflow-y-auto pr-2 space-y-2">
                        <!-- Lista de inputs será inserida aqui -->
                    </div>
                </aside>
                <main class="flex-grow p-4 flex flex-col">
                    <input type="hidden" id="input-gallery-id">
                    <div class="mb-3 flex-shrink-0 max-w-[50%]">
                        <label for="input-gallery-project-assign" class="text-xs font-medium text-[--text-muted-dark]">Project:</label>
                        <select id="input-gallery-project-assign" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2"></select>
                    </div>
                    <input id="input-gallery-name" placeholder="Input name..." class="form-input font-sans w-full p-2 text-lg font-medium mb-4 rounded-md" style="background-color: var(--input-bg);">
                    <textarea id="input-gallery-editor" placeholder="Input content..." class="form-input font-mono w-full h-full p-4 text-base leading-relaxed resize-none rounded-md flex-grow" style="background-color: var(--input-bg);"></textarea>
                </main>
            </div>
        </div>
    </div>

    <!-- Modal Node Flow -->
    <div id="node-flow-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-8">
        <div class="bg-[--card-bg-dark] w-[90vw] h-[90vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-4 border-b border-[--border-dark] flex justify-between items-center flex-shrink-0">
                <div class="flex items-center gap-4">
                    <h2 class="text-xl font-bold">Node Flow</h2>
                    <select id="saved-flows-dropdown" class="form-control rounded-md py-1.5 px-3 text-sm focus:ring-2">
                         <option value="">Load a saved flow...</option>
                    </select>
                </div>
                <div class="flex items-center gap-3">
                    <div class="flex items-center gap-2 text-xs">
                        <span class="text-[--text-muted-dark]">Mode:</span>
                        <button id="flow-mode-bypass" class="action-button text-xs px-2 py-1">By Pass</button>
                        <button id="flow-mode-runall" class="action-button text-xs px-2 py-1">Run All</button>
                        <label class="ml-2 flex items-center gap-1 text-[--text-muted-dark]"><input id="flow-continue-on-error" type="checkbox" class="rounded"> <span class="text-xs">Continue on error</span></label>
                    </div>
                    <button id="run-flow-btn" class="action-button primary">Run Flow</button>
                    <button id="delete-flow-btn" class="action-button text-sm text-red-500 hover:bg-red-900/20 hover:border-red-800" disabled>Delete Flow</button>
                    <button id="save-flow-btn" class="action-button primary">Save Flow</button>
                    <button id="close-node-flow-btn" class="p-2 rounded-full hover:bg-[#333]">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <div class="flex-grow flex overflow-hidden">
                <aside id="node-flow-sidebar" class="sidebar p-4 border-r border-[--border-dark] flex flex-col">
                     <div class="mb-3 flex-shrink-0">
                        <label for="node-flow-project-filter" class="text-xs font-medium text-[--text-muted-dark]">Filter by Project:</label>
                        <select id="node-flow-project-filter" class="form-control w-full mt-1 rounded-md py-1.5 px-3 text-sm focus:ring-2">
                             <!-- Opções populadas via JS -->
                        </select>
                     </div>
                    <div id="node-flow-prompt-list" class="flex-grow overflow-y-auto pr-2 space-y-1">
                        <!-- Lista de prompts arrastáveis será inserida aqui -->
                    </div>
                </aside>
                <main id="node-flow-canvas" class="flex-grow relative">
                    <div id="node-flow-content">
                        <!-- Nós do fluxo serão inseridos aqui -->
                    </div>
                    <svg id="node-flow-connections" class="w-full h-full absolute top-0 left-0 pointer-events-none">
                        <g id="connections-group"></g>
                    </svg>
                </main>
            </div>
        </div>
    </div>

    <!-- Modal: Node Response Viewer -->
    <div id="node-response-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-[80vw] h-[70vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-3 border-b border-[--border-dark] flex items-center justify-between">
                <h3 id="node-response-title" class="text-lg font-bold">Response</h3>
                <div class="flex items-center gap-2">
                    <button id="node-save-response-btn" class="action-button text-xs">Save Response</button>
                    <button id="node-pin-response-btn" class="action-button text-xs">Pin Response</button>
                    <button id="close-node-response-btn" class="p-2 rounded hover:bg-[#333]" title="Close">&times;</button>
                </div>
            </div>
            <pre id="node-response-content" class="flex-1 overflow-auto p-3 font-mono text-sm"></pre>
        </div>
    </div>

    <!-- Modal: Node Prompt Viewer -->
    <div id="node-prompt-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-6">
        <div class="bg-[--card-bg-dark] w-[80vw] h-[70vh] rounded-lg shadow-xl border border-[--border-dark] flex flex-col">
            <div class="p-3 border-b border-[--border-dark] flex items-center justify-between">
                <h3 id="node-prompt-title" class="text-lg font-bold">Prompt</h3>
                <div class="flex items-center gap-2">
                    <button id="close-node-prompt-btn" class="p-2 rounded hover:bg-[#333]" title="Close">&times;</button>
                </div>
            </div>
            <pre id="node-prompt-content" class="flex-1 overflow-auto p-3 font-mono text-sm whitespace-pre-wrap"></pre>
        </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', async () => {
            // Feature flags / runtime toggles
            const SHOW_AUTH_PANEL = false; // Disable minimal Auth overlay by default
            const hasChartJS = typeof Chart !== 'undefined';
            // --- Minimal Auth UI (Magic Link) ---
            // After session is ready, auto-load models for all connections
            // Wait for Supabase client and session
            let sessionReady = false;
            try {
                if (typeof supabaseClient !== 'undefined' && supabaseClient) {
                    const { data } = await supabaseClient.auth.getSession();
                    if (data?.session) sessionReady = true;
                }
            } catch {}
            if (sessionReady) {
                setTimeout(autoLoadAllModels, 0);
            } else {
                // If not logged in, try again after login
                try {
                    supabaseClient?.auth?.onAuthStateChange?.((event, session) => {
                        if (session) setTimeout(autoLoadAllModels, 0);
                    });
                } catch {}
            }
            (() => {
              try {
                // Do not render the small auth panel unless explicitly enabled
                if (!SHOW_AUTH_PANEL) return;
                // Avoid running before client exists
                if (typeof supabaseClient === 'undefined' || !supabaseClient || !window.document) return;

                // Create or reuse a small auth panel in the top-right corner
                let panel = document.getElementById('supabase-auth-panel');
                if (!panel) {
                  panel = document.createElement('div');
                  panel.id = 'supabase-auth-panel';
                  panel.style.position = 'fixed';
                  panel.style.top = '8px';
                  panel.style.right = '8px';
                  panel.style.zIndex = '9999';
                  panel.style.background = 'var(--panel-bg-dark, #0f1115)';
                  panel.style.border = '1px solid var(--border-dark, #2a2f3a)';
                  panel.style.padding = '8px';
                  panel.style.borderRadius = '6px';
                  panel.style.fontSize = '12px';
                  panel.style.color = 'var(--text-muted-dark, #c8d1e0)';
                  panel.style.display = 'flex';
                  panel.style.alignItems = 'center';
                  panel.style.gap = '6px';
                  panel.style.boxShadow = '0 2px 8px rgba(0,0,0,0.25)';

                  const email = document.createElement('input');
                  email.type = 'email';
                  email.placeholder = 'Seu e-mail';
                  email.id = 'auth-email-input';
                  email.style.padding = '4px 6px';
                  email.style.border = '1px solid var(--border-dark, #2a2f3a)';
                  email.style.background = 'transparent';
                  email.style.color = 'inherit';
                  email.style.borderRadius = '4px';
                  email.style.minWidth = '180px';

                  const sendBtn = document.createElement('button');
                  sendBtn.textContent = 'Enviar link';
                  sendBtn.id = 'auth-send-btn';
                  sendBtn.className = 'action-button text-xs';

                  const signOutBtn = document.createElement('button');
                  signOutBtn.textContent = 'Sair';
                  signOutBtn.id = 'auth-signout-btn';
                  signOutBtn.className = 'action-button text-xs';

                  const status = document.createElement('span');
                  status.id = 'auth-status-label';
                  status.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
                  status.style.fontSize = '11px';
                  status.style.opacity = '0.8';

                  panel.appendChild(email);
                  panel.appendChild(sendBtn);
                  panel.appendChild(signOutBtn);
                  panel.appendChild(status);
                  document.body.appendChild(panel);
                }

                const emailInput = panel.querySelector('#auth-email-input');
                const sendBtn = panel.querySelector('#auth-send-btn');
                const signOutBtn = panel.querySelector('#auth-signout-btn');
                const status = panel.querySelector('#auth-status-label');

                async function refreshAuthUI() {
                                    try {
                                        const { data } = await supabaseClient.auth.getUser();
                                        const user = data?.user;
                                        if (user) {
                                            // Logged in: show status + Sign out; hide email + send
                                            if (emailInput) emailInput.style.display = 'none';
                                            if (sendBtn) sendBtn.style.display = 'none';
                                            if (signOutBtn) signOutBtn.style.display = '';
                                            if (status) status.textContent = user.email ? `Logado: ${user.email}` : 'Logado';
                                            // Carrega prompts do Supabase ao logar
                                            loadDataFromSupabase();
                                        } else {
                                            // Logged out: show email + send; hide Sign out
                                            if (emailInput) emailInput.style.display = '';
                                            if (sendBtn) sendBtn.style.display = '';
                                            if (signOutBtn) signOutBtn.style.display = 'none';
                                            if (status) status.textContent = '';
                                        }
                                    } catch (e) {
                                        if (status) status.textContent = '';
                                    }
                }

                if (sendBtn) {
                  sendBtn.addEventListener('click', async () => {
                    try {
                      const email = (emailInput?.value || '').trim();
                      if (!email) { if (status) status.textContent = 'Informe seu e-mail.'; return; }
                      const redirect = window.location.origin + window.location.pathname;
                      const { error } = await supabaseClient.auth.signInWithOtp({
                        email,
                        options: { emailRedirectTo: redirect }
                      });
                      if (error) { if (status) status.textContent = 'Erro ao enviar link.'; return; }
                      if (status) status.textContent = 'Link enviado. Verifique seu e-mail.';
                    } catch (e) {
                      if (status) status.textContent = 'Falha no envio.';
                    }
                  });
                }

                                if (signOutBtn) {
                                    signOutBtn.addEventListener('click', async () => {
                                        try {
                                            await supabaseClient.auth.signOut();
                                            await refreshAuthUI();
                                            try { window.openLoginModal && window.openLoginModal(); window.setMode && window.setMode('signin'); } catch {}
                                        } catch {}
                                    });
                                }

                try {
                  // Keep UI in sync with auth changes
                  supabaseClient.auth.onAuthStateChange(() => { refreshAuthUI(); });
                } catch {}

                refreshAuthUI();
              } catch {}
            })();
            // --- End Minimal Auth UI ---

                        // --- Inline Auth UI (header, beside theme toggle) ---
                        (() => {
                            try {
                                const SHOW_AUTH_INLINE = false; // prefer the Login Modal UX
                                const host = document.getElementById('auth-inline');
                                if (!SHOW_AUTH_INLINE || !host) return;

                                // If Supabase not configured, keep hidden
                                if (!supabaseClient) { host.classList.add('hidden'); return; }

                                // Build UI once
                                host.innerHTML = '';
                                host.classList.remove('hidden');
                                host.classList.add('flex');

                                const email = document.createElement('input');
                                email.type = 'email';
                                email.placeholder = 'email';
                                email.id = 'auth-email-inline';
                                email.className = 'form-control compact-field rounded-md text-xs w-44';

                                const sendBtn = document.createElement('button');
                                sendBtn.id = 'auth-send-inline';
                                sendBtn.textContent = 'Magic Link';
                                sendBtn.className = 'action-button text-xs';

                                const signOutBtn = document.createElement('button');
                                signOutBtn.id = 'auth-signout-inline';
                                signOutBtn.textContent = 'Sign out';
                                signOutBtn.className = 'action-button text-xs hidden';

                                const status = document.createElement('span');
                                status.id = 'auth-status-inline';
                                status.className = 'text-[10px] font-mono text-[--text-muted-dark]';

                                host.appendChild(email);
                                host.appendChild(sendBtn);
                                host.appendChild(signOutBtn);
                                host.appendChild(status);

                                async function refresh() {
                                    try {
                                        const { data } = await supabaseClient.auth.getUser();
                                        const user = data?.user;
                                        if (user) {
                                            email.classList.add('hidden');
                                            sendBtn.classList.add('hidden');
                                            signOutBtn.classList.remove('hidden');
                                            status.textContent = user.email || 'Logged in';
                                        } else {
                                            email.classList.remove('hidden');
                                            sendBtn.classList.remove('hidden');
                                            signOutBtn.classList.add('hidden');
                                            status.textContent = '';
                                        }
                                    } catch { status.textContent = ''; }
                                }

                                sendBtn.addEventListener('click', async () => {
                                    try {
                                        const value = (email.value || '').trim();
                                        if (!value) { status.textContent = 'Informe o e-mail'; return; }
                                        const redirect = window.location.origin + window.location.pathname;
                                        const { error } = await supabaseClient.auth.signInWithOtp({ email: value, options: { emailRedirectTo: redirect } });
                                        if (error) { status.textContent = 'Erro ao enviar link'; return; }
                                        status.textContent = 'Link enviado';
                                    } catch { status.textContent = 'Falha no envio'; }
                                });

                                signOutBtn.addEventListener('click', async () => {
                                    try { await supabaseClient.auth.signOut(); await refresh(); } catch {}
                                });

                                try { supabaseClient.auth.onAuthStateChange(() => { refresh(); }); } catch {}
                                refresh();
                            } catch {}
                        })();
                        // --- End Inline Auth UI ---
            // Helper: UUID that works offline/older browsers
            const getUUID = () => (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function')
                ? crypto.randomUUID()
                : `id-${Math.random().toString(36).slice(2)}${Date.now().toString(36)}`;

            // --- CONFIG DOCK LOGIC ---
            const dock = document.getElementById('config-dock');
            const drawer = document.getElementById('config-drawer');
            const drawerTitle = document.getElementById('config-drawer-title');
            const drawerClose = document.getElementById('config-drawer-close');
            let currentDrawerKey = null; // track open panel for toggle behavior
            const panels = {
                project: document.getElementById('panel-project'),
                github: document.getElementById('panel-github'),
                llm: document.getElementById('panel-llm'),
                tags: document.getElementById('panel-tags'),
                xml: document.getElementById('panel-xml'),
                var: document.getElementById('panel-var'),
                input: document.getElementById('panel-input'),
                settings: document.getElementById('panel-settings'),
            };
            const openDrawer = (which, title) => {
                if (!drawer) return;
                // Hide all panels
                Object.values(panels).forEach(p => p && p.classList.add('hidden'));
                // Show selected
                const panel = panels[which];
                if (panel) panel.classList.remove('hidden');
                if (drawerTitle) drawerTitle.textContent = title || 'LLM Parameters';
                currentDrawerKey = which;
                // Toggle header add buttons per panel
                try {
                    const headerAddXml = document.getElementById('add-xml-tag-btn');
                // Ensure Target LLM reflects only current connections
                syncLlmListWithConnections();
                    const headerAddVar = document.getElementById('add-var-library-btn');
                    if (headerAddXml) headerAddXml.classList.toggle('hidden', which !== 'xml');
                    if (headerAddVar) headerAddVar.classList.toggle('hidden', which !== 'var');
                } catch {}
                // Render the corresponding list
                try {
                    if (which === 'project') renderProjectListDrawer();
                    if (which === 'github') {
                        renderGithubListDrawer();
                        // Auto-open and load provider repos section in Dock > GitHub
                        const box = document.getElementById('dock-github-available-repos');
                        const caret = document.getElementById('dock-github-repos-caret');
                        if (box) box.classList.remove('hidden');
                        if (caret) caret.textContent = '▼';
                        try { loadAccessibleRepos(document.getElementById('dock-github-available-repos')); } catch {}
                    }
                    if (which === 'llm') renderLlmListDrawer();
                    if (which === 'tags') renderTagsListDrawer();
                    if (which === 'xml') renderXmlTagsListDrawer();
                    if (which === 'var') renderVarLibraryListDrawer();
                    if (which === 'input') renderAddInputListDrawer();
                } catch {}
                drawer.classList.remove('pointer-events-none');
                drawer.style.opacity = '1';
                drawer.style.transform = 'translateX(0)';
                // No focus needed; lists are visible
            };
            const closeDrawer = () => {
                if (!drawer) return;
                drawer.style.opacity = '0';
                drawer.style.transform = 'translateX(8px)';
                // Delay pointer-events to allow transition
                setTimeout(() => drawer.classList.add('pointer-events-none'), 180);
                currentDrawerKey = null;
            };
            if (drawerClose) drawerClose.addEventListener('click', closeDrawer);
            const bind = (btnId, key, title) => {
                const btn = document.getElementById(btnId);
                if (!btn) return;
                btn.addEventListener('click', () => {
                    const isOpen = !drawer.classList.contains('pointer-events-none') && currentDrawerKey === key;
                    if (isOpen) {
                        closeDrawer();
                    } else {
                        openDrawer(key, title);
                    }
                });
            };
            bind('dock-project-btn', 'project', 'Project');
            bind('dock-github-btn', 'github', 'GitHub Repo');
            bind('dock-llm-btn', 'llm', 'LLM Model');
            bind('dock-tags-btn', 'tags', 'Tags');
            bind('dock-xml-btn', 'xml', 'XML Tags');
            bind('dock-var-btn', 'var', 'Variables');
            bind('dock-input-btn', 'input', 'Add Input');
            bind('dock-settings-btn', 'settings', 'LLM Parameters');

            // Initialize closed state
            if (drawer) {
                drawer.style.opacity = '0';
                drawer.style.transform = 'translateX(8px)';
                drawer.classList.add('pointer-events-none');
            }

            // Header add buttons will be bound after elements are declared below

            // Close drawer on outside click
            document.addEventListener('click', (e) => {
                if (!drawer) return;
                const withinDock = dock && dock.contains(e.target);
                const withinDrawer = drawer.contains(e.target);
                if (!withinDock && !withinDrawer) closeDrawer();
            });

            // --- CONFIGURAÇÃO DO SUPABASE ---
    // Active project (Studio > Project Settings > API)
        const SUPABASE_URL = 'https://bwhalclycvkiifgyvuup.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJ3aGFsY2x5Y3ZraWlmZ3l2dXVwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU5MjE4MDYsImV4cCI6MjA3MTQ5NzgwNn0.Kr3zSH2WLwR2XsKyAEA27gZS_CtgNPeZ53IxjpQi1Ts';

        // Valores finais: permitem override seguro via querystring (?supabase_url=...&supabase_key=...)
        // ou via globals (window.__SUPABASE_URL / window.__SUPABASE_ANON_KEY) sem persistir em localStorage.
        const __qs = (() => { try { return new URLSearchParams(location.search); } catch { return new URLSearchParams(); } })();
        const __ALLOW_OVERRIDE = (() => {
            try {
                const host = (typeof location !== 'undefined' ? location.hostname : '');
                return host === 'localhost' || host === '127.0.0.1' || (typeof window !== 'undefined' && window.__ALLOW_SUPABASE_OVERRIDE === true);
            } catch { return false; }
        })();
        const __urlOverride = (() => {
            if (!__ALLOW_OVERRIDE) return '';
            try { return __qs.get('supabase_url') || (typeof window !== 'undefined' ? (window.__SUPABASE_URL || '') : ''); } catch { return ''; }
        })();
        const __keyOverride = (() => {
            if (!__ALLOW_OVERRIDE) return '';
            try { return __qs.get('supabase_key') || (typeof window !== 'undefined' ? (window.__SUPABASE_ANON_KEY || '') : ''); } catch { return ''; }
        })();
    const FINAL_SUPABASE_URL = (__urlOverride && __urlOverride.trim()) || SUPABASE_URL;
    const FINAL_SUPABASE_KEY = (__keyOverride && __keyOverride.trim()) || SUPABASE_ANON_KEY;

                        let supabaseClient = null;
            let dbOnline = false;
            try {
                if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) {
                    console.warn('Supabase não configurado: defina SUPABASE_URL e SUPABASE_ANON_KEY no código antes de usar recursos protegidos.');
                } else if (window.supabase && typeof window.supabase.createClient === 'function') {
                    const { createClient } = window.supabase;
                    supabaseClient = createClient(FINAL_SUPABASE_URL, FINAL_SUPABASE_KEY);
                    // expose globally for unified access across modules/handlers
                    try { window.supabaseClient = supabaseClient; } catch {}
                    dbOnline = true;
                    // Initialize DB status as loading; will switch to Online after data is loaded
                    setDbStatusLoading(0);
                } else {
                    console.warn('Supabase SDK not available. Running in offline mode.');
                    try { window.supabaseClient = null; } catch {}
                }
            } catch (e) {
                console.warn('Supabase init failed, switching to offline mode:', e);
                supabaseClient = null;
                try { window.supabaseClient = null; } catch {}
                dbOnline = false;
                setDbStatusOffline();
            }

            // --- DB STATUS LOADING HELPERS ---
            function setDbStatusLoading(pct) {
                try {
                    const el = document.getElementById('db-status-pill');
                    if (!el) return;
                    el.classList.remove('online', 'offline');
                    el.classList.add('loading');
                    const clamped = Math.max(0, Math.min(100, Math.round(pct || 0)));
                    el.textContent = `DB: Loading ${clamped}%`;
                } catch {}
            }
            function setDbStatusOnline() {
                try {
                    const el = document.getElementById('db-status-pill');
                    if (!el) return;
                    el.classList.remove('loading', 'offline');
                    el.classList.add('online');
                    el.textContent = 'DB: Online';
                } catch {}
            }
            function setDbStatusOffline() {
                try {
                    const el = document.getElementById('db-status-pill');
                    if (!el) return;
                    el.classList.remove('loading', 'online');
                    el.classList.add('offline');
                    el.textContent = 'DB: Offline';
                } catch {}
            }

                        // Handle password recovery tokens from URL fragment
                        (function() {
                            try {
                                if (!supabaseClient) return;
                                const hash = window.location.hash || '';
                                if (!hash || hash.indexOf('access_token=') === -1) return;
                                const params = new URLSearchParams(hash.replace(/^#/, ''));
                                const access_token = params.get('access_token');
                                const refresh_token = params.get('refresh_token');
                                const type = params.get('type');
                                if (access_token && refresh_token) {
                                    supabaseClient.auth.setSession({ access_token, refresh_token }).then(() => {
                                        try { history.replaceState(null, '', window.location.pathname + window.location.search); } catch {}
                                        if (type === 'recovery' && typeof window.openLoginModal === 'function') {
                                            window.openLoginModal();
                                            try { window.setMode && window.setMode('newpass'); } catch {}
                                        }
                                    }).catch(() => {});
                                }
                            } catch {}
                        })();

                                    // --- Login Modal Wiring (Email + Password) ---
                        (function() {
                            try {
                                const modal = document.getElementById('login-modal');
                                const emailInput = document.getElementById('login-email-input');
                                            const pwdInput = document.getElementById('login-password-input');
                                            const pwdConfirm = document.getElementById('login-password-confirm');
                                            const submitBtn = document.getElementById('login-submit-btn');
                                const statusEl = document.getElementById('login-status');
                                const closeBtn = document.getElementById('login-modal-close');
                                            const toggleModeBtn = document.getElementById('login-toggle-mode');
                                            const forgotBtn = document.getElementById('login-forgot');
                                            const titleEl = document.getElementById('login-modal-title');
                                            const descEl = document.getElementById('login-modal-desc');

                                                            // mode: 'signin' | 'signup' | 'reset' | 'newpass'
                                                            let loginMode = 'signin';
                                            function setMode(mode) {
                                                loginMode = mode;
                                                if (mode === 'signin') {
                                                    titleEl.textContent = 'Sign in';
                                                    descEl.textContent = 'Enter your email and password to sign in.';
                                                    submitBtn.textContent = 'Sign in';
                                                pwdInput.classList.remove('hidden');
                                                    pwdConfirm.classList.add('hidden');
                                                    toggleModeBtn.textContent = 'Create account';
                                                } else if (mode === 'signup') {
                                                    titleEl.textContent = 'Create account';
                                                    descEl.textContent = 'Enter your email and a new password to create an account.';
                                                    submitBtn.textContent = 'Create account';
                                                pwdInput.classList.remove('hidden');
                                                    pwdConfirm.classList.remove('hidden');
                                                    toggleModeBtn.textContent = 'Have an account? Sign in';
                                                                } else if (mode === 'reset') {
                                                    titleEl.textContent = 'Reset password';
                                                    descEl.textContent = 'Enter your email to receive a reset link.';
                                                    submitBtn.textContent = 'Send reset link';
                                                pwdInput.classList.add('hidden');
                                                    pwdConfirm.classList.add('hidden');
                                                                } else if (mode === 'newpass') {
                                                                    titleEl.textContent = 'Set new password';
                                                                    descEl.textContent = 'Enter and confirm your new password.';
                                                                    submitBtn.textContent = 'Update password';
                                                pwdInput.classList.remove('hidden');
                                                                    pwdConfirm.classList.remove('hidden');
                                                }
                                                statusEl.textContent = '';
                                            }

                                function openLoginModal() {
                                    if (!modal) return;
                                    modal.classList.remove('hidden');
                                    // focus input shortly after open
                                                setTimeout(() => { try { emailInput && emailInput.focus(); } catch {} }, 50);
                                }
                                function closeLoginModal() {
                                    if (!modal) return;
                                    modal.classList.add('hidden');
                                    if (statusEl) statusEl.textContent = '';
                                }
                                // expose globally for other handlers
                                window.openLoginModal = openLoginModal;
                                window.closeLoginModal = closeLoginModal;

                                // Close interactions
                                if (closeBtn) {
                                    // No "X" button anymore; keep guard if future UI adds one
                                    closeBtn.remove();
                                }
                                if (modal) {
                                    modal.addEventListener('click', async (e) => {
                                        if (e.target === modal) {
                                            try {
                                                const { data } = await supabaseClient.auth.getSession();
                                                if (data?.session) closeLoginModal();
                                            } catch {}
                                        }
                                    });
                                }
                                document.addEventListener('keydown', async (e) => {
                                    if (e.key === 'Escape' && modal && !modal.classList.contains('hidden')) {
                                        try {
                                            const { data } = await supabaseClient.auth.getSession();
                                            if (data?.session) closeLoginModal();
                                        } catch {}
                                    }
                                });

                                                // Toggle modes
                                                if (toggleModeBtn) {
                                                    toggleModeBtn.addEventListener('click', () => {
                                                        if (loginMode === 'signin') setMode('signup');
                                                        else setMode('signin');
                                                    });
                                                }
                                                if (forgotBtn) {
                                                    forgotBtn.addEventListener('click', () => setMode('reset'));
                                                }

                                                                // Helper: safe redirect only on http(s)
                                                                function getSafeRedirect() {
                                                                    try {
                                                                        if (location.protocol === 'http:' || location.protocol === 'https:') {
                                                                            const qs = location.search || '';
                                                                            return window.location.origin + window.location.pathname + qs;
                                                                        }
                                                                    } catch {}
                                                                    return null;
                                                                }

                                                                // Submit
                                                if (submitBtn) {
                                                    submitBtn.addEventListener('click', async () => {
                                                        try {
                                                            if (!supabaseClient) { statusEl.textContent = 'Supabase indisponível'; return; }
                                                            const email = (emailInput?.value || '').trim();
                                                            if (!email) { statusEl.textContent = 'Informe seu e-mail'; return; }
                                                            submitBtn.disabled = true;

                                                            if (loginMode === 'signin') {
                                                                const password = (pwdInput?.value || '').trim();
                                                                if (!password) { statusEl.textContent = 'Informe sua senha'; submitBtn.disabled = false; return; }
                                                                                const { error } = await supabaseClient.auth.signInWithPassword({ email, password });
                                                                                if (error) { statusEl.textContent = 'Login inválido: ' + (error.message || ''); submitBtn.disabled = false; return; }
                                                                statusEl.textContent = 'Signed in';
                                                            } else if (loginMode === 'signup') {
                                                                const password = (pwdInput?.value || '').trim();
                                                                const confirm = (pwdConfirm?.value || '').trim();
                                                                if (!password || password.length < 6) { statusEl.textContent = 'Senha deve ter 6+ caracteres'; submitBtn.disabled = false; return; }
                                                                if (password !== confirm) { statusEl.textContent = 'Senhas não coincidem'; submitBtn.disabled = false; return; }
                                                                                const redirect = getSafeRedirect();
                                                                                const { error } = await supabaseClient.auth.signUp(redirect ? { email, password, options: { emailRedirectTo: redirect } } : { email, password });
                                                                                if (error) { statusEl.textContent = 'Falha ao criar conta: ' + (error.message || ''); submitBtn.disabled = false; return; }
                                                                statusEl.textContent = 'Conta criada. Verifique seu e-mail para confirmar.';
                                                                // switch back to sign-in
                                                                setMode('signin');
                                                                            } else if (loginMode === 'reset') {
                                                                                const redirect = getSafeRedirect();
                                                                                const { error } = await supabaseClient.auth.resetPasswordForEmail(email, redirect ? { redirectTo: redirect } : undefined);
                                                                                if (error) { statusEl.textContent = 'Falha ao enviar reset: ' + (error.message || ''); submitBtn.disabled = false; return; }
                                                                statusEl.textContent = 'Link de reset enviado.';
                                                                setMode('signin');
                                                                                    } else if (loginMode === 'newpass') {
                                                                                        const password = (pwdInput?.value || '').trim();
                                                                                        const confirm = (pwdConfirm?.value || '').trim();
                                                                                        if (!password || password.length < 6) { statusEl.textContent = 'Senha deve ter 6+ caracteres'; submitBtn.disabled = false; return; }
                                                                                        if (password !== confirm) { statusEl.textContent = 'Senhas não coincidem'; submitBtn.disabled = false; return; }
                                                                                const { data, error } = await supabaseClient.auth.updateUser({ password });
                                                                                if (error) { statusEl.textContent = 'Falha ao atualizar senha: ' + (error.message || ''); submitBtn.disabled = false; return; }
                                                                                        statusEl.textContent = 'Senha atualizada. Entre novamente.';
                                                                                        setMode('signin');
                                                            }
                                                        } catch {
                                                            statusEl.textContent = 'Erro inesperado';
                                                        } finally {
                                                            setTimeout(() => { try { submitBtn.disabled = false; } catch {} }, 1200);
                                                        }
                                                    });
                                                }

                                // If already logged in, ensure modal stays closed
                                if (supabaseClient) {
                                    try {
                                        supabaseClient.auth.onAuthStateChange((evt) => {
                                            if (evt === 'PASSWORD_RECOVERY') {
                                                openLoginModal();
                                                setMode('newpass');
                                                try { pwdInput?.focus(); } catch {}
                                            } else if (evt === 'SIGNED_IN') {
                                                // Keep auth tokens; do not clear localStorage here.
                                                closeLoginModal();
                                                try { document.getElementById('auth-gate-overlay')?.classList.add('hidden'); } catch {}
                                            }
                                        });
                                        // Gate on load if no active session
                                        supabaseClient.auth.getSession().then(({ data }) => {
                                            const gate = document.getElementById('auth-gate-overlay');
                                            if (data?.session) { closeLoginModal(); gate && gate.classList.add('hidden'); }
                                            else { openLoginModal(); setMode('signin'); gate && gate.classList.remove('hidden'); }
                                        }).catch(() => {});
                                    } catch {}
                                }
                                                    // expose mode setter globally for URL-based handlers
                                                    window.setMode = setMode;
                                                    // default mode
                                                    setMode('signin');
                            } catch {}
                        })();
                                            // --- End Login Modal Wiring ---

                                    // (Removed) Compact header Sign in/Sign out toggle — replaced by a single static Account button

                                                // --- Profiles inline UI (email + editable full_name) ---
                                                (function() {
                                                    try {
                                                        const host = document.getElementById('profile-inline');
                                                        const fullnameInput = document.getElementById('profile-fullname');
                                                        // email display and inline Edit removed
                                                        const saveBtn = document.getElementById('profile-save-btn');

                                                        async function refresh() {
                                                            if (!supabaseClient) { host.classList.add('hidden'); return; }
                                                            const { data } = await supabaseClient.auth.getUser();
                                                            const user = data?.user;
                                                            if (!user) { host.classList.add('hidden'); return; }
                                                            host.classList.remove('hidden');
                                                            // Load profile.full_name
                                                            try {
                                                                const { data: prof } = await supabaseClient.from('profiles').select('full_name').single();
                                                                const fullname = prof?.full_name || '';
                                                                fullnameInput.value = fullname;
                                                                fullnameInput.classList.add('hidden');
                                                                saveBtn.classList.add('hidden');
                                                            } catch {
                                                                // If RLS blocks or row missing, attempt create on save
                                                                // keep inputs hidden until user clicks save
                                                            }
                                                        }

                                                        // Inline Edit button removed

                                                        if (saveBtn) saveBtn.addEventListener('click', async () => {
                                                            try {
                                                                const name = (fullnameInput.value || '').trim();
                                                                const { data: userData } = await supabaseClient.auth.getUser();
                                                                const id = userData?.user?.id;
                                                                if (!id) return;
                                                                const { error } = await supabaseClient.from('profiles').upsert({ id, full_name: name }).select().single();
                                                                if (!error) {
                                                                    fullnameInput.classList.add('hidden');
                                                                    saveBtn.classList.add('hidden');
                                                                    editBtn.classList.remove('hidden');
                                                                }
                                                            } catch {}
                                                        });

                                                        if (supabaseClient) {
                                                            try { supabaseClient.auth.onAuthStateChange(() => { refresh(); }); } catch {}
                                                            refresh();
                                                        }
                                                    } catch {}
                                                })();
                                                // --- End profiles inline UI ---

                                                // --- Account modal (Profile edit + Change password) ---
                                                (function() {
                                                    try {
                                                        const accountBtn = document.getElementById('account-btn');
                                                        const modal = document.getElementById('account-modal');
                                                        const closeBtn = document.getElementById('account-close-btn');
                                                        const fullnameInput = document.getElementById('account-fullname');
                                                        const emailInput = document.getElementById('account-email');
                                                        const saveNameBtn = document.getElementById('account-save-name');
                                                        const nameStatus = document.getElementById('account-name-status');
                                                        const newPass = document.getElementById('account-new-pass');
                                                        const newPass2 = document.getElementById('account-new-pass2');
                                                        const updatePassBtn = document.getElementById('account-update-pass');
                                                        const passStatus = document.getElementById('account-pass-status');

                                                        function toggleAccountBtn(_logged) {
                                                            if (!accountBtn) return;
                                                            // Always show Account; when signed out, clicking it opens login
                                                            accountBtn.classList.remove('hidden');
                                                        }

                                                        async function populate() {
                                                            if (!supabaseClient) return;
                                                            try {
                                                                const { data: userData } = await supabaseClient.auth.getUser();
                                                                const user = userData?.user;
                                                                const logged = !!user;
                                                                toggleAccountBtn(logged);
                                                                if (!logged) return;
                                                                try { if (emailInput) emailInput.value = user?.email || ''; } catch {}
                                                                try {
                                                                    const { data: prof } = await supabaseClient.from('profiles').select('full_name').single();
                                                                    const fullname = prof?.full_name || '';
                                                                    if (fullnameInput) fullnameInput.value = fullname;
                                                                } catch {}
                                                            } catch {}
                                                        }

                                                        function openModal() {
                                                            if (!modal) return;
                                                            modal.classList.remove('hidden');
                                                        }
                                                        function closeModal() {
                                                            if (!modal) return;
                                                            modal.classList.add('hidden');
                                                            if (nameStatus) nameStatus.textContent = '';
                                                            if (passStatus) passStatus.textContent = '';
                                                            try { newPass.value = ''; newPass2.value = ''; } catch {}
                                                        }

                                                        if (accountBtn) accountBtn.addEventListener('click', async () => {
                                                            await populate();
                                                            try {
                                                                const { data } = await supabaseClient.auth.getUser();
                                                                if (!data?.user) { window.openLoginModal && window.openLoginModal(); return; }
                                                                // User exists -> open account modal
                                                                openModal();
                                                                return;
                                                            } catch {}
                                                            // Fallback: if anything fails, show login instead of looping
                                                            window.openLoginModal && window.openLoginModal();
                                                        });
                                                        if (closeBtn) closeBtn.addEventListener('click', closeModal);
                                                        if (modal) modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
                                                        document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && modal && !modal.classList.contains('hidden')) closeModal(); });

                                                        if (saveNameBtn) saveNameBtn.addEventListener('click', async () => {
                                                            if (!supabaseClient) return;
                                                            try {
                                                                nameStatus.textContent = 'Saving…';
                                                                const name = (fullnameInput?.value || '').trim();
                                                                const { data: userData } = await supabaseClient.auth.getUser();
                                                                const id = userData?.user?.id;
                                                                if (!id) { nameStatus.textContent = 'Not signed in.'; return; }
                                                                const { error } = await supabaseClient.from('profiles').upsert({ id, full_name: name }).select().single();
                                                                if (error) nameStatus.textContent = 'Error: ' + (error.message || '');
                                                                else nameStatus.textContent = 'Saved';
                                                                setTimeout(() => { try { nameStatus.textContent = ''; } catch {} }, 1500);
                                                            } catch { nameStatus.textContent = 'Failed'; }
                                                        });

                                                        if (updatePassBtn) updatePassBtn.addEventListener('click', async () => {
                                                            if (!supabaseClient) return;
                                                            try {
                                                                passStatus.textContent = 'Updating…';
                                                                const p1 = (newPass?.value || '').trim();
                                                                const p2 = (newPass2?.value || '').trim();
                                                                if (!p1 || p1.length < 6) { passStatus.textContent = '6+ chars required'; return; }
                                                                if (p1 !== p2) { passStatus.textContent = 'Passwords do not match'; return; }
                                                                const { error } = await supabaseClient.auth.updateUser({ password: p1 });
                                                                if (error) passStatus.textContent = 'Error: ' + (error.message || '');
                                                                else {
                                                                    passStatus.textContent = 'Password updated';
                                                                    try { newPass.value = ''; newPass2.value = ''; } catch {}
                                                                }
                                                                setTimeout(() => { try { passStatus.textContent = ''; } catch {} }, 1800);
                                                            } catch { passStatus.textContent = 'Failed'; }
                                                        });

                                                        if (supabaseClient) {
                                                            try { supabaseClient.auth.onAuthStateChange(() => { populate(); }); } catch {}
                                                            // Ensure visible
                                                            toggleAccountBtn(true);
                                                            populate();
                                                        }
                                                    } catch {}
                                                })();
                                                // --- End Account modal ---

            // Auth/session overlay and Logout wiring
                (function() {
                    try {
                        const gate = document.getElementById('auth-gate-overlay');
                        const logoutBtn = document.getElementById('account-logout-btn');
                        async function showGate() { try { gate && gate.classList.remove('hidden'); } catch {} }
                        async function hideGate() { try { gate && gate.classList.add('hidden'); } catch {} }
                        async function refreshAuthUI() {
                            if (!window.supabaseClient) { await showGate(); return; }
                            try {
                                const { data } = await window.supabaseClient.auth.getSession();
                                if (data?.session) { await hideGate(); }
                                else { await showGate(); }
                            } catch { await showGate(); }
                        }
                        if (window.supabaseClient) {
                            try {
                                window.supabaseClient.auth.onAuthStateChange(async (_evt, session) => {
                                    if (session) await hideGate(); else await showGate();
                                });
                            } catch {}
                            refreshAuthUI();
                        } else {
                            showGate();
                        }
                        if (logoutBtn) {
                            logoutBtn.addEventListener('click', async () => {
                                try {
                                    if (!window.supabaseClient) return;
                                    await window.supabaseClient.auth.signOut();
                                    await showGate();
                                    // Close account modal if open
                                    try { document.getElementById('account-modal')?.classList.add('hidden'); } catch {}
                                    // Bring back login UI explicitly
                                    try { window.openLoginModal && window.openLoginModal(); window.setMode && window.setMode('signin'); } catch {}
                                } catch {}
                            });
                        }
                    } catch {}
                })();

            // Telemetry + DataService (front)
                (function(){
                    // Minimal telemetry to mirror backend logEvent
                    function cid() { try { return (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Date.now()); } catch { return String(Date.now()); } }
                    const CORR = cid();
                    function log(level, message, meta) {
                        try {
                            const entry = { ts: new Date().toISOString(), level, message, correlation_id: CORR, ...(meta||{}) };
                            console.log('[pm]', JSON.stringify(entry));
                        } catch {}
                    }
                    window.pmLog = {
                        debug: (m,meta)=>log('debug',m,meta),
                        info:  (m,meta)=>log('info', m,meta),
                        warn:  (m,meta)=>log('warn', m,meta),
                        error: (m,meta)=>log('error',m,meta),
                        correlationId: CORR
                    };

                    // Central data service
                    const svc = {
                        async getSessionUserId() {
                            if (!window.supabaseClient) return null;
                            try { const { data } = await window.supabaseClient.auth.getSession(); return data?.session?.user?.id || null; } catch { return null; }
                        },
                        async loadAllData(opts) {
                            const supa = window.supabaseClient; if (!supa) throw new Error('No Supabase client');
                            const uid = await svc.getSessionUserId(); if (!uid) throw new Error('No session');
                            pmLog.info('loadAllData:start',{ uid });
                            const onP = (typeof opts === 'function') ? opts : (opts && typeof opts.onProgress === 'function' ? opts.onProgress : null);
                            const fetchT = async (table) => {
                                // Prefer filtering by user_id; fallback to unfiltered if column is missing
                                let res = await supa.from(table).select('*').eq('user_id', uid);
                                if (res.error && /column .*user_id/i.test(res.error.message)) {
                                    pmLog.warn('loadAllData:fallback_no_user_id',{ table });
                                    res = await supa.from(table).select('*');
                                }
                                // If filter returned empty for legacy-only tables, try unfiltered to catch null user_id rows
                                if (!res.error && Array.isArray(res.data) && res.data.length === 0 && (table === 'templates' || table === 'input_gallery')) {
                                    try {
                                        const alt = await supa.from(table).select('*');
                                        if (!alt.error && Array.isArray(alt.data) && alt.data.length > 0) res = alt;
                                    } catch {}
                                }
                                return res;
                            };
                            // Wrap each fetch to report progress as they resolve
                            const total = 5; let done = 0;
                            const wrap = (promise, label) => promise.then((res) => { try { done += 1; onP && onP(done, total, label); } catch {} return res; });
                            const [p, t, i, n, g] = await Promise.all([
                                wrap(fetchT('prompts'), 'prompts'),
                                wrap(fetchT('templates'), 'templates'),
                                wrap(fetchT('input_gallery'), 'input_gallery'),
                                wrap(fetchT('node_flows'), 'node_flows'),
                                wrap(fetchT('global_lists'), 'global_lists')
                            ]);
                            if (p.error) throw p.error; if (t.error) throw t.error; if (i.error) throw i.error; if (n.error) throw n.error; if (g.error) throw g.error;
                            pmLog.info('loadAllData:ok',{ counts: { prompts:(p.data||[]).length, templates:(t.data||[]).length, inputs:(i.data||[]).length, flows:(n.data||[]).length, lists:(g.data||[]).length } });
                            // If user_id is present, filter client-side just in case fallback was used.
                            // Include rows missing user_id or with null (legacy) so previously-saved items still appear.
                            const onlyMine = (rows) => Array.isArray(rows) ? rows.filter(r => !('user_id' in (r||{})) || r.user_id === uid || r.user_id == null) : [];
                            return { prompts: p.data||[], templates: onlyMine(t.data)||[], inputGallery: onlyMine(i.data)||[], nodeFlows: onlyMine(n.data)||[], lists: onlyMine(g.data)||[] };
                        },
                        async upsert(table, data) {
                            const supa = window.supabaseClient; if (!supa) throw new Error('No Supabase client');
                            const uid = await svc.getSessionUserId(); if (!uid) throw new Error('No session');
                            const payload = Array.isArray(data) ? data.map(d=>({ ...d, user_id: d.user_id||uid })) : ({ ...data, user_id: data.user_id||uid });
                            pmLog.debug('upsert:req',{ table, count: Array.isArray(payload)?payload.length:1 });
                            const opts = (table === 'node_flows') ? { onConflict: 'user_id,name' } : undefined;
                            const qb = supa.from(table);
                            let res = opts ? await qb.upsert(payload, opts).select() : await qb.upsert(payload).select();
                            if (res.error) {
                                pmLog.warn('upsert:err:first',{ table, error: res.error.message });
                                // Legacy compatibility fallbacks for missing columns, including PostgREST schema-cache messages
                                const errMsg = String(res.error.message || '');
                                const colMissing = (name) => {
                                    const a = new RegExp(`(column|attribute)[^\n]*${name}[^\n]*(does not exist|unknown|not found)`, 'i');
                                    const b = new RegExp(`(ould not find|not found)[^\n]*"?${name}"?[^\n]*(column|schema cache)?`, 'i');
                                    const c = new RegExp(`${name}[^\n]*(schema cache)`, 'i');
                                    return a.test(errMsg) || b.test(errMsg) || c.test(errMsg);
                                };
                                const stripUserId = colMissing('user_id');
                                const missingTopP = colMissing('top_p') || colMissing('topP');
                                const missingParentId = colMissing('parent_id') || colMissing('parentId');
                                const missingDeps = colMissing('dependencies') || /dependenc/i.test(errMsg);
                                const needsLegacyTpl = (table === 'templates') && (stripUserId || missingTopP || missingParentId || missingDeps);
                                const needsLegacyInput = (table === 'input_gallery') && stripUserId;
                                const needsLegacyPrompts = (table === 'prompts') && (stripUserId || missingParentId);
                                if (needsLegacyTpl || needsLegacyInput || needsLegacyPrompts) {
                    const toLegacy = (row) => {
                                        const r = { ...row };
                                        if (stripUserId) delete r.user_id;
                                        if (table === 'templates') {
                                            if (missingTopP) { if (typeof r.top_p !== 'undefined') { r.topP = r.top_p; delete r.top_p; } }
                                            if (missingParentId) { if (typeof r.parent_id !== 'undefined') { r.parentId = r.parent_id; delete r.parent_id; } }
                        if (missingDeps) delete r.dependencies;
                                        }
                                        if (table === 'prompts') {
                                            if (missingParentId) { if (typeof r.parent_id !== 'undefined') { r.parentId = r.parent_id; delete r.parent_id; } }
                                        }
                                        return r;
                                    };
                                    const legacyPayload = Array.isArray(payload) ? payload.map(toLegacy) : toLegacy(payload);
                                    pmLog.warn('upsert:retry_legacy',{ table });
                                    res = opts ? await qb.upsert(legacyPayload, opts).select() : await qb.upsert(legacyPayload).select();
                                }
                            }
                            if (res.error) { pmLog.error('upsert:err',{ table, error: res.error.message }); throw res.error; }
                            pmLog.info('upsert:ok',{ table, count: (res.data||[]).length });
                            return res.data||[];
                        },
                        async del(table, where) {
                            const supa = window.supabaseClient; if (!supa) throw new Error('No Supabase client');
                            const uid = await svc.getSessionUserId(); if (!uid) throw new Error('No session');
                            let q = supa.from(table).delete();
                            Object.entries(where||{}).forEach(([k,v])=>{ q = q.eq(k, v); });
                            q = q.eq('user_id', uid);
                            const { error } = await q;
                            if (error) { pmLog.error('delete:err',{ table, where, error: error.message }); throw error; }
                            pmLog.info('delete:ok',{ table, where });
                            return true;
                        },
                        async updateGlobalList(name, data) { return svc.upsert('global_lists', { name, data }); }
                    };
                    window.dataService = svc;
                })();

            const PROMPTS_STORAGE_KEY = 'promptManagerApp_prompts';
            const XML_TAGS_STORAGE_KEY = 'promptManagerApp_xmlTags';
            const TEMPLATES_STORAGE_KEY = 'promptManagerApp_templates';
            const VAR_LIBRARY_STORAGE_KEY = 'promptManagerApp_varLibrary';
            const LLM_LIST_STORAGE_KEY = 'promptManagerApp_llmList';
            const PROJECT_REPO_MAP_STORAGE_KEY = 'promptManagerApp_projectRepoMap';
            const INPUT_GALLERY_STORAGE_KEY = 'promptManagerApp_inputGallery';
            const NODE_FLOWS_STORAGE_KEY = 'promptManagerApp_nodeFlows';
            const PROJECTS_STORAGE_KEY = 'promptManagerApp_projects';
            // Provider/docs helpers
            const DOC_LINKS = {
                openai: 'https://platform.openai.com/docs/api-reference/introduction',
                xai: 'https://docs.x.ai/docs/overview/',
                
            };
            
            
            // --- ESTADO DA APLICAÇÃO ---
            let prompts = [];
            const STATUS_ORDER = ['idea','write','test','ready','archive'];
            const normalizeStatus = (s) => {
                const val = String(s || '').toLowerCase();
                if (['idea','write','test','ready','archive'].includes(val)) return val;
                // legacy mapping: edit->write, use->ready
                if (val === 'edit') return 'write';
                if (val === 'use') return 'ready';
                return 'idea';
            };
            // Temporary bridge: DB still enforces old set ('write','test','edit','use').
            // Map UI status to a DB-safe value to avoid check constraint failures until migration lands.
            const toDbStatus = (s) => {
                const n = normalizeStatus(s);
                if (n === 'idea') return 'write';
                if (n === 'ready') return 'use';
                if (n === 'archive') return 'write';
                return n; // 'write' or 'test'
            };
            let xmlTags = [];
            let templates = [];
            let varLibrary = [];
            let llmList = {};
            let inputGallery = [];
            let savedFlows = [];
            let projectNames = [];
            let projectRepoMap = {};
            let selectedVersionId = null;
            let selectedInputId = null; // Para o modal Input Gallery
            let expandedPromptGroups = new Set();
            let itemToDelete = { type: null, id: null };
            let activeStatusFilter = 'all';
            let activeProjectFilter = 'all';
            const effortLevels = ['Low', 'Medium', 'High'];
            let versionsToCompare = new Set();
            let activeComparisonPromptId = null;
            let findState = {
                matches: [],
                currentIndex: -1,
                query: ''
            };
            let snippets = []; // Para a função de copiar/salvar snippet
            let snippetMeasureEl = null; // medidor oculto para calcular Y com precisão

            function getSnippetMeasure() {
                if (!snippetMeasureEl) {
                    const cont = document.getElementById('editor-container');
                    snippetMeasureEl = document.createElement('div');
                    snippetMeasureEl.id = 'snippet-measure';
                    snippetMeasureEl.style.position = 'absolute';
                    snippetMeasureEl.style.left = '0';
                    snippetMeasureEl.style.top = '0';
                    snippetMeasureEl.style.visibility = 'hidden';
                    snippetMeasureEl.style.pointerEvents = 'none';
                    snippetMeasureEl.style.whiteSpace = 'pre-wrap';
                    snippetMeasureEl.style.overflowWrap = 'anywhere';
                    snippetMeasureEl.style.zIndex = '0';
                    if (cont) cont.appendChild(snippetMeasureEl);
                }
                const cs = getComputedStyle(mainEditor);
                snippetMeasureEl.style.font = cs.font;
                snippetMeasureEl.style.fontFamily = cs.fontFamily;
                snippetMeasureEl.style.fontSize = cs.fontSize;
                snippetMeasureEl.style.lineHeight = cs.lineHeight;
                snippetMeasureEl.style.letterSpacing = cs.letterSpacing;
                snippetMeasureEl.style.tabSize = cs.tabSize;
                snippetMeasureEl.style.boxSizing = 'border-box';
                snippetMeasureEl.style.paddingTop = cs.paddingTop;
                snippetMeasureEl.style.paddingRight = cs.paddingRight;
                snippetMeasureEl.style.paddingBottom = cs.paddingBottom;
                snippetMeasureEl.style.paddingLeft = cs.paddingLeft;
                snippetMeasureEl.style.width = mainEditor.clientWidth + 'px';
                return snippetMeasureEl;
            }

            function measureTopForIndex(text, index) {
                const m = getSnippetMeasure();
                m.textContent = text.substring(0, index);
                const marker = document.createElement('span');
                marker.textContent = ' ';
                m.appendChild(marker);
                const top = marker.offsetTop;
                m.removeChild(marker);
                return top;
            }
            // Prompt-level GitHub repo selection for current editor
            let currentGithubRepo = null; // { id, full }
            // Estado do Gráfico
            let isCreatingConnection = false;
            let firstNodeForConnection = null;
            let selectedLinkForDeletion = null;
            // Estado do Node Flow
            let flowNodes = [];
            let flowConnections = [];
            let isDraggingNode = false;
            let isDrawingConnection = false;
            let connectionStartNodeId = null;
            let tempLine = null;
            const hasD3 = typeof window.d3 !== 'undefined';
            const hasDiff = typeof window.diff_match_patch === 'function';
            let currentTransform = hasD3 ? d3.zoomIdentity : { x: 0, y: 0, k: 1, apply: ([x, y]) => [x, y] };

            // --- THEME SETUP ---
            const rootEl = document.documentElement;
            const themeToggleBtn = document.getElementById('theme-toggle');
            const iconSun = document.getElementById('icon-sun');
            const iconMoon = document.getElementById('icon-moon');
            // Cloud-only: don't persist theme locally
            const savedTheme = (typeof window.__PM_THEME !== 'undefined' ? window.__PM_THEME : 'dark');
            const applyTheme = (theme) => {
                if (theme === 'light') {
                    rootEl.setAttribute('data-theme', 'light');
                    themeToggleBtn.setAttribute('aria-label', 'Switch to dark mode');
                } else {
                    rootEl.removeAttribute('data-theme');
                    themeToggleBtn.setAttribute('aria-label', 'Switch to light mode');
                }
                // Update switch visuals: thumb position and aria-checked
                try {
                    const thumb = document.getElementById('theme-switch-thumb');
                    if (thumb) {
                        thumb.classList.remove('translate-x-0','translate-x-6');
                        thumb.classList.add(theme === 'light' ? 'translate-x-6' : 'translate-x-0');
                    }
                    // Emphasize active side instead of hiding icons
                    if (iconSun) iconSun.classList.toggle('opacity-40', theme !== 'light');
                    if (iconMoon) iconMoon.classList.toggle('opacity-40', theme === 'light');
                    if (themeToggleBtn) themeToggleBtn.setAttribute('aria-checked', theme === 'light' ? 'true' : 'false');
                } catch {}
                // Update DB status pill colors on theme change
                const dbStatus = document.getElementById('db-status-pill');
                if (dbStatus) {
                    // Preserve 'loading' if present; otherwise reflect online/offline
                    const isLoading = dbStatus.classList.contains('loading');
                    dbStatus.classList.remove('online', 'offline');
                    if (!isLoading) dbStatus.classList.add(dbOnline ? 'online' : 'offline');
                }
                // Re-render dashboard charts with theme-aware colors if modal is open
                setTimeout(() => {
                    const dashboardModalEl = document.getElementById('dashboard-modal');
                    if (dashboardModalEl && !dashboardModalEl.classList.contains('hidden') && typeof Chart !== 'undefined') {
                        const sel = document.getElementById('dashboard-period-select');
                        const period = sel ? sel.value : 'month';
                        if (typeof renderDashboardCharts === 'function') {
                            renderDashboardCharts(period);
                        }
                    }
                    // Update API STATUS colors on theme change
                    if (typeof refreshApiStatus === 'function') { try { refreshApiStatus(); } catch {} }
                }, 0);
            };
            applyTheme(savedTheme);
            themeToggleBtn.addEventListener('click', () => {
                const next = rootEl.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
                window.__PM_THEME = next;
                applyTheme(next);
            });


            // --- CHAT ASSISTANT ---
            function populateChatModelSelect() {
                const sel = document.getElementById('chat-model-select');
                if (!sel) return;
                const currentVal = sel.value;
                sel.innerHTML = '';
                // Placeholder
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = 'Unspecified';
                sel.appendChild(placeholder);
                try {
                    const groups = Object.keys(llmList || {}).sort();
                    groups.forEach(groupName => {
                        const og = document.createElement('optgroup');
                        og.label = groupName;
                        (llmList[groupName] || []).slice().sort().forEach(id => {
                            const opt = document.createElement('option');
                            opt.value = id;
                            opt.textContent = id;
                            og.appendChild(opt);
                        });
                        sel.appendChild(og);
                    });
                    const all = Object.values(llmList || {}).flat();
                    if (all.includes(currentVal)) sel.value = currentVal; else sel.value = '';
                } catch { sel.value = ''; }
            }

            function addMessage(role, content) {
                const box = document.getElementById('chat-messages');
                if (!box) return null;
                const wrap = document.createElement('div');
                wrap.className = `flex ${role === 'user' ? 'justify-end' : 'justify-start'}`;
                const bubble = document.createElement('div');
                bubble.className = `max-w-xs lg:max-w-md px-3 py-2 my-1 rounded-lg text-sm ${role === 'user' ? 'bg-[--accent-fuchsia] text-white' : 'bg-[#2a2a2a] text-white'}`;
                const text = document.createElement('div');
                text.textContent = content;
                bubble.appendChild(text);
                if (role === 'assistant' && content !== 'Thinking...') {
                    const btn = document.createElement('button');
                    btn.className = 'mt-2 px-2 py-1 text-xs bg-[--accent-mint] text-black rounded hover:opacity-90 transition-opacity';
                    btn.textContent = 'to edit';
                    btn.addEventListener('click', () => {
                        const editor = document.getElementById('main-editor');
                        if (!editor) return;
                        const cur = editor.selectionStart || editor.value.length;
                        const before = editor.value.slice(0, cur);
                        const after = editor.value.slice(cur);
                        editor.value = `${before}${content}${after}`;
                        const newPos = before.length + content.length;
                        editor.setSelectionRange(newPos, newPos);
                        editor.dispatchEvent(new Event('input', { bubbles: true }));
                        editor.focus();
                    });
                    bubble.appendChild(btn);
                }
                wrap.appendChild(bubble);
                box.appendChild(wrap);
                box.scrollTop = box.scrollHeight;
                return wrap;
            }

            async function sendChat() {
                const input = document.getElementById('chat-input');
                const sel = document.getElementById('chat-model-select');
                const listEl = document.getElementById('chat-messages');
                if (!input || !sel || !listEl) return;
                const msg = (input.value || '').trim();
                const modelId = sel.value || '';
                if (!msg) return;
                if (!modelId) { alert('Select a model first.'); return; }
                addMessage('user', msg);
                input.value = '';
                const thinking = addMessage('assistant', 'Thinking...');
                try {
                    // Build payload using existing helpers to match provider
                    const conn = resolveConnForModel ? resolveConnForModel(modelId) : null;
                    const provider = (typeof detectProvider === 'function' && conn?.base) ? detectProvider(conn.base) : 'openai';
                    let path = 'chat/completions';
                    let body = { model: modelId };
                    // Align with buildRunPayload style for providers
                    if (provider === 'openai') {
                        body.messages = [{ role: 'user', content: msg }];
                        path = 'chat/completions';
                    } else if (provider === 'anthropic' || /claude/i.test(modelId)) {
                        path = 'messages';
                        body.messages = [{ role: 'user', content: msg }];
                        body.max_tokens = 2048;
                    } else if (provider === 'cohere' || /command|embed|rerank/i.test(modelId)) {
                        path = 'generate';
                        body.messages = [{ role: 'user', content: msg }];
                        body.max_tokens = 2048;
                    } else if (provider === 'deepseek') {
                        path = 'chat/completions';
                        body.messages = [{ role: 'user', content: msg }];
                        body.max_tokens = 2048;
                    } else if (provider === 'mistral') {
                        // Mistral is OpenAI-compatible chat/completions with extras
                        path = 'chat/completions';
                        body.messages = [{ role: 'user', content: msg }];
                        body.max_tokens = 2048;
                    } else if (provider === 'google') {
                        // Gemini generateContent requires model-qualified path and API key in query string via proxy
                        const gcBodyInfo = sanitizeRequestForModel({ body: { model: modelId, messages: [{ role: 'user', content: msg }], max_tokens: 2048 }, provider: 'google', model: modelId });
                        const gcBody = gcBodyInfo.body;
                        const p = `models/${modelId}:generateContent`;
                        const res = await llmRequest(p, { method: 'POST', body: gcBody, headers: { 'x-pm-auth': 'google-query-key' } });
                        if (!res.ok) throw new Error(`HTTP ${res.status}`);
                        const data = await res.json();
                        let text = '';
                        try {
                            const candidates = data?.candidates || [];
                            const first = candidates[0];
                            const parts = first?.content?.parts || [];
                            text = parts.map(p => p?.text || '').filter(Boolean).join('\n');
                        } catch {}
                        if (thinking && thinking.parentNode) thinking.parentNode.removeChild(thinking);
                        addMessage('assistant', text || '(no content)');
                        return;
                    } else if (provider === 'perplexity') {
                        // Perplexity chat/completions with search extensions
                        path = 'chat/completions';
                        body.messages = [{ role: 'user', content: msg }];
                        body.max_tokens = 2048;
                    } else {
                        path = 'completions';
                        body.prompt = msg;
                    }
                    let res = await llmRequest(path, { method: 'POST', body });
                    if (!res.ok) {
                        // Try fallback endpoints similar to run flow
                        if (provider === 'openai' && res.status === 404) {
                            const compBody = { model: modelId, prompt: msg };
                            res = await llmRequest('completions', { method: 'POST', body: compBody });
                        }
                    }
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const data = await res.json();
                    let text = '';
                    // Parse like run flow
                    if (data?.choices?.length) {
                        const c = data.choices[0];
                        if (Array.isArray(c.message?.content)) {
                            text = c.message.content.map(p => typeof p === 'string' ? p : (p?.text || '')).filter(Boolean).join('\n');
                        } else {
                            text = c.message?.content || c.text || '';
                        }
                    } else if (Array.isArray(data?.output_text) && data.output_text.length) {
                        text = data.output_text.join('\n');
                    } else if (data?.message?.content) {
                        const mc = data.message.content;
                        text = Array.isArray(mc) ? mc.map(p => p?.text || '').filter(Boolean).join('\n') : mc;
                    } else if (Array.isArray(data?.content) && data.content.length && data.content[0]?.text) {
                        try { text = data.content.map(p => p.text).filter(Boolean).join('\n\n'); } catch { text = data.content[0]?.text || ''; }
                    } else {
                        text = data?.text || '';
                    }
                    if (thinking && thinking.parentNode) thinking.parentNode.removeChild(thinking);
                    addMessage('assistant', text || '(no content)');
                } catch (e) {
                    if (thinking && thinking.parentNode) thinking.parentNode.removeChild(thinking);
                    addMessage('assistant', `Error: ${e?.message || String(e)}`);
                }
            }

            function bindChatEvents() {
                const sendBtn = document.getElementById('send-chat-btn');
                const clrBtn = document.getElementById('clear-chat-btn');
                const input = document.getElementById('chat-input');
                const modelSel = document.getElementById('chat-model-select');
                if (sendBtn) sendBtn.addEventListener('click', sendChat);
                if (clrBtn) clrBtn.addEventListener('click', () => { const box = document.getElementById('chat-messages'); if (box) box.innerHTML = ''; });
                if (input) {
                    // Auto-resize up to 100px, then scroll
                    const MAX_H = 100;
                    const syncHeight = () => {
                        try {
                            input.style.height = 'auto';
                            const h = Math.min(input.scrollHeight, MAX_H);
                            input.style.height = h + 'px';
                            input.style.overflowY = (input.scrollHeight > MAX_H) ? 'auto' : 'hidden';
                            // Base height equals send button height
                            const sb = document.getElementById('send-chat-btn');
                            if (sb) input.style.minHeight = getComputedStyle(sb).height;
                        } catch {}
                    };
                    ['input','change'].forEach(ev => input.addEventListener(ev, syncHeight));
                    setTimeout(syncHeight, 0);
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChat(); return; }
                        // Schedule resize after key handling
                        setTimeout(syncHeight, 0);
                    });
                }
                if (modelSel) modelSel.addEventListener('change', () => {});
            }

            // --- ELEMENTOS DO DOM ---
            const mainHeader = document.getElementById('main-header');
            const mainContent = document.getElementById('main-content');
            const mainEditor = document.getElementById('main-editor');
            const syntaxOverlay = document.getElementById('syntax-overlay');
            const snippetButtonsOverlay = document.getElementById('snippet-buttons-overlay');
            const titleInput = document.getElementById('prompt-title-input');
            const projectInput = document.getElementById('project-name-input-aside');
            const versionsHistoryList = document.getElementById('versions-history-list');
            const statusContainer = document.getElementById('status-selector-container');
            const searchInput = document.getElementById('search-versions-input');
            const editorStats = document.getElementById('editor-stats');
            const copyPromptBtn = document.getElementById('copy-prompt-btn');
            const llmSelect = document.getElementById('llm-select');
            const statusFilterContainer = document.getElementById('status-filter-container');
            const variablesSection = document.getElementById('variables-section');
            const variablesContainer = document.getElementById('variables-container');
            const toggleSyntax = document.getElementById('toggle-syntax-highlighting');
            const syntaxLabel = document.getElementById('syntax-switch-label');
            // Dependencies UI (moved to bottom bar)
            const editDependenciesBtn = document.getElementById('edit-dependencies-btn');
            const dependenciesDropdown = document.getElementById('dependencies-dropdown');
            const dependenciesSearch = document.getElementById('dependencies-search');
            const dependenciesList = document.getElementById('dependencies-list');
            const depsCancelBtn = document.getElementById('deps-cancel-btn');
            const depsApplyBtn = document.getElementById('deps-apply-btn');
            // Drawer lists (new)
            const projectListDrawer = document.getElementById('project-list-drawer');
            const llmListDrawer = document.getElementById('llm-list-drawer');
            const tagsListDrawer = document.getElementById('tags-list-drawer');
            const xmlTagsListDrawer = document.getElementById('xml-tags-list-drawer');
            const varLibraryListDrawer = document.getElementById('var-library-list-drawer');
            const addInputListDrawer = document.getElementById('add-input-list-drawer');

            // Legacy hidden inputs kept for compatibility
            const xmlTagInput = document.getElementById('xml-tag-input');
            const addXmlTagBtn = document.getElementById('add-xml-tag-btn');
            const xmlTagDropdown = document.getElementById('xml-tag-dropdown');
            const dependencyBar = document.getElementById('dependency-bar');
            const dependencyTagContainer = document.getElementById('dependency-tag-container');
            const compareVersionsBtn = document.getElementById('compare-versions-btn');
            const toggleCommentsBtn = document.getElementById('toggle-comments-btn');
            const commentsSection = document.getElementById('comments-section');
            const commentsTextarea = document.getElementById('comments-textarea');
            const navigationMap = document.getElementById('navigation-map');
            
            const addPromptBtn = document.getElementById('add-prompt-btn');
            const addMajorVersionBtn = document.getElementById('add-major-version-btn');
            const addMinorVersionBtn = document.getElementById('add-minor-version-btn');
            const saveAsTemplateBtn = document.getElementById('save-as-template-btn');
            const forkVersionBtn = document.getElementById('fork-version-btn');
            const deleteVersionBtn = document.getElementById('delete-version-btn');
            const downloadJsonBtn = document.getElementById('download-json-btn');
            const downloadMdBtn = document.getElementById('download-md-btn');
            const downloadTxtBtn = document.getElementById('download-txt-btn');
            
            // --- Syntax highlighting overlay logic ---
            function escapeHtml(str) {
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            function highlightEditorTokens(text) {
                try {
                    // Match {{variables}} or XML-ish tags like <tag ...>, </tag>, <tag/>
                    const pattern = /(\{\{[^}]+\}\}|<\/?[A-Za-z][^>\n]*\/?\>)/g;
                    let out = '';
                    let last = 0;
                    for (const m of text.matchAll(pattern)) {
                        const idx = m.index ?? 0;
                        const tok = m[0];
                        // preceding plain text
                        if (idx > last) out += escapeHtml(text.slice(last, idx));
                        if (tok.startsWith('{{')) {
                            out += `<span class="hl-var">${escapeHtml(tok)}</span>`;
                        } else {
                            out += `<span class="hl-xml">${escapeHtml(tok)}</span>`;
                        }
                        last = idx + tok.length;
                    }
                    // tail
                    if (last < text.length) out += escapeHtml(text.slice(last));
                    return out;
                } catch {
                    // Fallback: just escape
                    return escapeHtml(text);
                }
            }

            function syncSyntaxOverlayStyles() {
                if (!mainEditor || !syntaxOverlay) return;
                const cs = getComputedStyle(mainEditor);
                // Mirror key text metrics for perfect alignment
                syntaxOverlay.style.font = cs.font;
                syntaxOverlay.style.fontFamily = cs.fontFamily;
                syntaxOverlay.style.fontSize = cs.fontSize;
                syntaxOverlay.style.lineHeight = cs.lineHeight;
                syntaxOverlay.style.letterSpacing = cs.letterSpacing;
                syntaxOverlay.style.tabSize = cs.tabSize;
                syntaxOverlay.style.textAlign = cs.textAlign;
                syntaxOverlay.style.textIndent = cs.textIndent;
                syntaxOverlay.style.textTransform = cs.textTransform;
                syntaxOverlay.style.fontVariantLigatures = cs.fontVariantLigatures;
                syntaxOverlay.style.fontFeatureSettings = cs.fontFeatureSettings;
                syntaxOverlay.style.fontVariationSettings = cs.fontVariationSettings;
                syntaxOverlay.style.direction = cs.direction;
                syntaxOverlay.style.whiteSpace = cs.whiteSpace;
                syntaxOverlay.style.wordBreak = cs.wordBreak;
                syntaxOverlay.style.overflowWrap = cs.overflowWrap;
                syntaxOverlay.style.boxSizing = 'border-box';
                // Mirror padding + border widths so overlay content aligns with textarea content box
                const pt = parseFloat(cs.paddingTop || '0');
                const pr = parseFloat(cs.paddingRight || '0');
                const pb = parseFloat(cs.paddingBottom || '0');
                const pl = parseFloat(cs.paddingLeft || '0');
                const bl = parseFloat(cs.borderLeftWidth || '0');
                const br = parseFloat(cs.borderRightWidth || '0');
                const bt = parseFloat(cs.borderTopWidth || '0');
                const bb = parseFloat(cs.borderBottomWidth || '0');
                // Compensate for scrollbar gutter when present so overlay text start/end matches
                let extraRight = 0;
                try {
                    const hasVScroll = mainEditor.scrollHeight > mainEditor.clientHeight + 1;
                    const scrollbarW = mainEditor.offsetWidth - mainEditor.clientWidth; // includes vertical scrollbar width when shown
                    extraRight = hasVScroll ? Math.max(0, scrollbarW) : 0;
                } catch {}
                syntaxOverlay.style.paddingTop = `${pt + bt}px`;
                syntaxOverlay.style.paddingRight = `${pr + br + extraRight}px`;
                syntaxOverlay.style.paddingBottom = `${pb + bb}px`;
                syntaxOverlay.style.paddingLeft = `${pl + bl}px`;
            }

            function renderSyntaxOverlay() {
                if (!mainEditor || !syntaxOverlay) return;
                if (!toggleSyntax || toggleSyntax.getAttribute('aria-checked') !== 'true') return;
                const raw = String(mainEditor.value || '');
                const html = highlightEditorTokens(raw);
                try {
                    // Only allow spans with class; keep everything else as text
                    if (typeof setSafeHTML === 'function') {
                        setSafeHTML(syntaxOverlay, html, { ALLOWED_TAGS: ['span'], ALLOWED_ATTR: ['class'] });
                    } else {
                        syntaxOverlay.innerHTML = html;
                    }
                } catch {
                    syntaxOverlay.textContent = raw;
                }
                // Mirror scroll position using integer top offset to avoid fractional rounding jitter
                try { syntaxOverlay.style.top = `${-Math.round(mainEditor.scrollTop)}px`; } catch {}
            }

            // Ensure overlay updates when editor value is set programmatically
            function refreshSyntaxOverlayIfOn() {
                try {
                    if (toggleSyntax && toggleSyntax.getAttribute('aria-checked') === 'true') {
                        syncSyntaxOverlayStyles();
                        renderSyntaxOverlay();
                    }
                } catch {}
            }

            function initSyntaxOverlayWiring() {
                if (!syntaxOverlay || !mainEditor || !toggleSyntax) return;
                // Ensure styles are synced once
                syncSyntaxOverlayStyles();
                // Toggle visibility and render
                const editorContainer = document.getElementById('editor-container');
                const applyToggle = () => {
                    try {
                        const isOn = toggleSyntax.getAttribute('aria-checked') === 'true';
                        if (isOn) {
                            // Re-sync styles in case layout changed while off
                            syncSyntaxOverlayStyles();
                            renderSyntaxOverlay();
                            if (editorContainer) editorContainer.classList.add('syntax-on');
                        } else {
                            // Clear to avoid stale highlights when re-enabled
                            syntaxOverlay.innerHTML = '';
                            syntaxOverlay.style.transform = 'translateY(0)';
                            syntaxOverlay.style.top = '0';
                            if (editorContainer) editorContainer.classList.remove('syntax-on');
                        }
                        // Update label color based on theme and state
                        if (syntaxLabel) {
                            const isLight = document.documentElement.getAttribute('data-theme') === 'light';
                            if (isOn) {
                                // Light mode = purple; Dark mode = green
                                syntaxLabel.style.color = isLight ? 'var(--accent-fuchsia)' : 'var(--accent-mint)';
                            } else {
                                syntaxLabel.style.color = 'var(--text-muted-dark)';
                            }
                        }
                    } catch {}
                };
                toggleSyntax.addEventListener('click', () => {
                    const cur = toggleSyntax.getAttribute('aria-checked') === 'true';
                    toggleSyntax.setAttribute('aria-checked', cur ? 'false' : 'true');
                    applyToggle();
                });
                // Input updates
                mainEditor.addEventListener('input', () => { if (toggleSyntax.getAttribute('aria-checked') === 'true') renderSyntaxOverlay(); });
                // Scroll sync
                mainEditor.addEventListener('scroll', () => {
                    try { syntaxOverlay.style.top = `${-Math.round(mainEditor.scrollTop)}px`; } catch {}
                });
                // Resize/style changes
                window.addEventListener('resize', () => { syncSyntaxOverlayStyles(); if (toggleSyntax.getAttribute('aria-checked') === 'true') renderSyntaxOverlay(); });
                // Initial
                // Default off
                toggleSyntax.setAttribute('aria-checked', 'false');
                applyToggle();
            }
            // Defer to next tick to ensure DOM is fully measured
            setTimeout(initSyntaxOverlayWiring, 0);

            // Run Prompt UI
            const runPromptBtn = document.getElementById('run-prompt-btn');
            const runModal = document.getElementById('run-modal');
            const closeRunModalBtn = document.getElementById('close-run-modal');
            const runCancelBtn = document.getElementById('run-cancel-btn');
            const runExecuteBtn = document.getElementById('run-execute-btn');
            const runRequestView = document.getElementById('run-request-view');
            const runResponseView = document.getElementById('run-response-view');
            const runLoading = document.getElementById('run-loading');
            const runError = document.getElementById('run-error');
            const runActiveLlm = document.getElementById('run-active-llm');
            const copyRunReqBtn = document.getElementById('copy-run-request-btn');
            const copyRunResBtn = document.getElementById('copy-run-response-btn');
            const reqToggleFullBtn = document.getElementById('req-toggle-full');
            const reqToggleOnlyBtn = document.getElementById('req-toggle-only');
            const saveRunResponseBtn = document.getElementById('save-run-response-btn');
            const openResponseLogBtn = document.getElementById('open-response-log-btn');
            const responseLogModal = document.getElementById('response-log-modal');
            const closeResponseLogModalBtn = document.getElementById('close-response-log-modal');
            const respLogTbody = document.getElementById('response-log-tbody');
            const respLogSearch = document.getElementById('resp-log-search');
            const respLogRefresh = document.getElementById('resp-log-refresh');
            const respLogPrev = document.getElementById('resp-log-prev');
            const respLogNext = document.getElementById('resp-log-next');
            const respLogStatus = document.getElementById('resp-log-status');
            let reqPreviewMode = 'full'; // 'full' | 'only'
            let lastRunResponseText = '';
            let respLogPage = 0;
            const RESP_LOG_PAGE_SIZE = 20;

            // Modais
            const confirmModal = document.getElementById('confirm-modal');
            const confirmModalTitle = document.getElementById('confirm-modal-title');
            const confirmModalText = document.getElementById('confirm-modal-text');
            const confirmModalInputContainer = document.getElementById('confirm-modal-input-container');
            const confirmModalInput = document.getElementById('confirm-modal-input');
            const confirmModalButtons = document.getElementById('confirm-modal-buttons');
            
            const galleryModal = document.getElementById('gallery-modal');
            const galleryBtn = document.getElementById('gallery-btn');
            const closeGalleryBtn = document.getElementById('close-gallery-btn');
            const galleryGrid = document.getElementById('gallery-grid');
            const responseLogMenuBtn = document.getElementById('response-log-btn');
            
            const projectsModal = document.getElementById('projects-modal');
            const projectsBtn = document.getElementById('projects-btn');
            const closeProjectsBtn = document.getElementById('close-projects-btn');
            const addProjectBtn = document.getElementById('add-project-btn');
            addProjectBtn.addEventListener('click', () => {
                const addProjectPopup = document.getElementById('add-project-popup');
                const newProjectNameInput = document.getElementById('new-project-name-input');
                const cancelAddProjectBtn = document.getElementById('cancel-add-project-btn');
                const confirmAddProjectBtn = document.getElementById('confirm-add-project-btn');

                // Show popup
                addProjectPopup.classList.remove('hidden');
                newProjectNameInput.value = '';
                newProjectNameInput.focus();

                // Cancel add
                cancelAddProjectBtn.addEventListener('click', () => {
                    addProjectPopup.classList.add('hidden');
                });

                // Confirm add
                confirmAddProjectBtn.addEventListener('click', async() => {
                    const newProjectName = newProjectNameInput.value.trim();
                    if (newProjectName) {
                        const datalist = document.getElementById('project-list-aside');
                        const exists = [...datalist.options].some(option => option.value === newProjectName);
                        if (!exists) {
                            const option = document.createElement('option');
                            option.value = newProjectName;
                            datalist.appendChild(option);

                            // Track in persistent project list
                            if (!projectNames.includes(newProjectName)) {
                                projectNames.push(newProjectName);
                                saveProjectNamesToStorage();
                                // Persist to Supabase global_lists
                                updateGlobalList('projects', projectNames);
                            }

                            // Update modal list immediately
                            renderProjectsView();

                            // Show stylized modal
                            showModal(
                                'Success',
                                `Project "${newProjectName}" added successfully.`,
                                [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]
                            );
                        } else {
                            showModal(
                                'Error',
                                'This project already exists.',
                                [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]
                            );
                        }
                    }
                    addProjectPopup.classList.add('hidden');
                });
            });
            // ===== Run Prompt feature =====
            function setReqPreviewMode(mode) {
                reqPreviewMode = mode === 'only' ? 'only' : 'full';
                if (reqToggleFullBtn && reqToggleOnlyBtn) {
                    reqToggleFullBtn.classList.toggle('active', reqPreviewMode === 'full');
                    reqToggleOnlyBtn.classList.toggle('active', reqPreviewMode === 'only');
                }
            }
            if (reqToggleFullBtn) reqToggleFullBtn.addEventListener('click', () => setReqPreviewMode('full'));
            if (reqToggleOnlyBtn) reqToggleOnlyBtn.addEventListener('click', () => setReqPreviewMode('only'));
            // Initialize state
            setReqPreviewMode('full');
            function resolveConnForModel(modelId) {
                try {
                    if (!modelId) return null;
                    const groupName = Object.keys(llmList || {}).find(g => (llmList[g] || []).includes(modelId));
                    if (!groupName) return null;
                    const conns = (typeof getLlmConnections === 'function') ? getLlmConnections() : [];
                    // 1) Exact match via computeConnGroup
                    const exact = conns.find(c => { try { return (typeof computeConnGroup === 'function') && computeConnGroup(c) === groupName; } catch { return false; } });
                    if (exact) return exact;
                    // 2) Fallback: parse provider and label from group and match by label and provider
                    let parsedProv = null, parsedLabel = null;
                    try { const parts = groupName.split(' — '); parsedProv = (parts[0] || '').trim(); parsedLabel = (parts[1] || '').trim(); } catch {}
                    if (parsedLabel) {
                        const byLabel = conns.filter(c => {
                            try { return (c.label || (c.base ? new URL(c.base).hostname : '')) === parsedLabel; } catch { return false; }
                        });
                        if (byLabel.length === 1) return byLabel[0];
                        if (byLabel.length > 1 && parsedProv) {
                            const byLabelProv = byLabel.find(c => { try { return (typeof detectProvider === 'function') && detectProvider(c.base || '') === (parsedProv === 'openai' ? 'openai' : parsedProv); } catch { return false; } });
                            if (byLabelProv) return byLabelProv;
                        }
                    }
                    // 3) Last resort: match any connection by provider from group
                    if (parsedProv) {
                        const anyProv = conns.find(c => { try { return (typeof detectProvider === 'function') && detectProvider(c.base || '') === (parsedProv === 'openai' ? 'openai' : parsedProv); } catch { return false; } });
                        if (anyProv) return anyProv;
                    }
                    return null;
                } catch { return null; }
            }

            async function storeLocalConnOnServer(conn) {
                try {
                    if (!conn || conn.server) return conn;
                    if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return conn;
                    const provider = (typeof detectProvider === 'function') ? detectProvider(conn.base || '') : 'openai';
                    const label = (() => { try { return conn.label || new URL(conn.base).hostname; } catch { return conn.label || 'LLM'; } })();
                    await detectFnVariants();
                    const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                    const headers = await buildFnHeaders();
                    let res;
                    if (FN_VARIANTS.saveConfig === 'new') {
                        res = await fetch(baseFn + '/save-ai-api-config', { method: 'POST', headers, body: JSON.stringify({ name: label, provider, base_url: conn.base, api_key: conn.key }) });
                    } else {
                        res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers, body: JSON.stringify({ type: 'llm', label, base_url: conn.base, api_key: conn.key, provider }) });
                    }
                    if (!res.ok) return conn;
                    const { id: newId } = await res.json();
                    const list = Array.isArray(window.__PM_LLM_MULTI) ? [...window.__PM_LLM_MULTI] : [];
                    // Migrate models cache
                    const cached = getModelsCache(conn.id);
                    if (cached && cached.length) {
                        try { setModelsCache(newId, cached); } catch {}
                        try { setModelsCache(conn.id, []); } catch {}
                    }
                    // Replace the local entry with server entry
                    const idx = list.findIndex(i => i.id === conn.id);
                    const serverEntry = { id: newId, base: conn.base, label, server: true };
                    if (idx >= 0) { list.splice(idx, 1, serverEntry); } else { list.push(serverEntry); }
                    window.__PM_LLM_MULTI = list;
                    window.__PM_LLM_ACTIVE = newId;
                    // Persist caches and rebuild Target LLM from connections
                    try { await persistAllModelCachesToServer(); } catch {}
                    try { if (typeof rebuildLlmListFromConnections === 'function') rebuildLlmListFromConnections(); } catch {}
                    return serverEntry;
                } catch { return conn; }
            }
            function buildRunPayload() {
                const llmId = llmSelect?.value || '';
                const dyn = collectDynamicSettings();
                const content = (mainEditor?.value || '').trim();
                // Detect provider from the connection that owns the selected model (fallback to active/base)
                let provider = 'openai';
                try {
                    const conn = (typeof resolveConnForModel === 'function') ? resolveConnForModel(llmId) : null;
                    const base = conn?.base || (typeof getActiveLlmConn === 'function' ? (getActiveLlmConn()?.base || '') : '') || (window.__PM_LLM_BASE || '');
                    if (typeof detectProvider === 'function') provider = detectProvider(base);
                } catch {}

                let messages = Array.isArray(dyn.messages) && dyn.messages.length
                    ? dyn.messages.filter(m => (m.content||'').trim().length)
                    : [];
                if (!messages.length && content) messages = [{ role: 'user', content }];

                // System messages remain inline; Anthropic also supports top-level system

                const body = { model: llmId ? llmId : undefined, messages };
                // Common knobs
                if (dyn.maxTokens !== '' && typeof dyn.maxTokens !== 'undefined') body.max_tokens = Number(dyn.maxTokens);
                if (dyn.dimensions !== '' && typeof dyn.dimensions !== 'undefined') body.dimensions = Number(dyn.dimensions);
                if (typeof dyn.temperature === 'number') body.temperature = dyn.temperature;
                if (typeof dyn.topP === 'number') body.top_p = dyn.topP;
                if (dyn.stopSequences && String(dyn.stopSequences).trim()) {
                    body.stop = String(dyn.stopSequences).split(/\r?\n/).map(s => s.trim()).filter(Boolean);
                }
                // Anthropic-specific mapping
                if (provider === 'anthropic') {
                    if (dyn.system && String(dyn.system).trim()) body.system = dyn.system;
                    if (dyn.topK !== '' && typeof dyn.topK !== 'undefined') body.top_k = Number(dyn.topK);
                    // Ensure minimal max_tokens for Anthropic
                    if (typeof body.max_tokens !== 'number') body.max_tokens = 1024;
                } else if (provider === 'cohere') {
                    if (dyn.system && String(dyn.system).trim()) body.system = dyn.system;
                    if (dyn.topK !== '' && typeof dyn.topK !== 'undefined') body.top_k = Number(dyn.topK);
                    if (dyn.serviceTier) body.service_tier = dyn.serviceTier;
                    if (typeof dyn.stream !== 'undefined') body.stream = String(dyn.stream) === 'true';
                    if (typeof body.max_tokens !== 'number') body.max_tokens = 512;
                }
                // OpenAI-compatible knobs only
                if (typeof dyn.presencePenalty === 'number') body.presence_penalty = dyn.presencePenalty;
                if (typeof dyn.frequencyPenalty === 'number') body.frequency_penalty = dyn.frequencyPenalty;
                if (dyn.seed !== '' && typeof dyn.seed !== 'undefined') body.seed = Number(dyn.seed);
                if (dyn.responseFormat && dyn.responseFormat !== 'text') body.response_format = { type: dyn.responseFormat };
                // OpenAI Responses extras (only if present)
                if (provider === 'openai') {
                    const isGpt5Family = (() => { try { return /^gpt-5(?:$|[-_])|^gpt-5-chat$/i.test(llmId || ''); } catch { return false; } })();
                    // For Responses models, map UI fields; keep defaults off if unset
                    if (dyn.serviceTier) body.service_tier = dyn.serviceTier;
                    if (dyn.stream) body.stream = String(dyn.stream) === 'true';
                    if (dyn.background) body.background = String(dyn.background) === 'true';
                    if (dyn.reasoningEffort) body.reasoning = { effort: dyn.reasoningEffort };
                    // gpt-5-only
                    if (isGpt5Family) {
                        if (dyn.verbosity) body.verbosity = dyn.verbosity;
                        if (dyn.minimalReasoning) body.minimal_reasoning = String(dyn.minimalReasoning) === 'true';
                        if (dyn.cfg && String(dyn.cfg).trim()) body.cfg = dyn.cfg;
                    }
                    if (dyn.extraArgs && String(dyn.extraArgs).trim()) {
                        try { const obj = JSON.parse(dyn.extraArgs); Object.assign(body, { extra_args: obj }); } catch {}
                    }
                }
                // Pre-sanitize per model/provider to avoid 400s
                const { body: sanitized } = sanitizeRequestForModel({ body, provider, model: llmId });
                return { body: sanitized, messages, provider };
            }

            async function executeRunPrompt() {
                if (!runModal) return;
                runError.textContent = '';
                runResponseView.textContent = '';
                runLoading.classList.remove('hidden');
                try {
                    // Require a model chosen in Dock > LLM Model; transport (proxy/direct) is auto-resolved in llmRequest
                    if (!llmSelect || !llmSelect.value) throw new Error('Select an LLM Model in the Dock first.');
                    // Proxy-only: ensure active connection is server-stored
                    try {
                        const selModel = llmSelect?.value;
                        const selConn = resolveConnForModel(selModel);
                        if (!selConn || !selConn.server) {
                            throw new Error('Active LLM connection must be stored on server. Open API Console > LLM and add the API.');
                        }
                    } catch (e) { throw e; }
                    const { body, provider } = buildRunPayload();
                    const selModel = llmSelect?.value;
                    let selConn = resolveConnForModel(selModel);
                    // Proxy-only pre-check
                    if (!selConn || !selConn.server) {
                        throw new Error('Active LLM connection must be stored on server. Open API Console > LLM and add the API.');
                    }
                    // Check capabilities and choose endpoint upfront
                    const capsInfo = sanitizeRequestForModel({ body, provider, model: selModel });
                    if (capsInfo.unsupportedReason === 'image_generation') {
                        throw new Error('This model is for image generation and is not supported by Run Request.');
                    }
                    if (capsInfo.unsupportedReason === 'specialized_api') {
                        throw new Error('This model requires a specialized API (audio/realtime/transcribe/tts) and is not supported by this Run flow.');
                    }
                    // Convert messages->input for Responses API and prepare embeddings body when needed
                    let initialBody = capsInfo.body || body;
                    let path = 'chat/completions';
                    if (provider === 'anthropic') {
                        path = 'messages';
                        // anthropic-version header is injected inside llmRequest
                        if (typeof initialBody.max_tokens !== 'number') initialBody.max_tokens = 2048;
                    } else if (provider === 'cohere') {
                        // Cohere generate API handles chat via messages
                        path = 'generate';
                        if (typeof initialBody.max_tokens !== 'number') initialBody.max_tokens = 2048;
                    } else if (provider === 'deepseek') {
                        // Deepseek is OpenAI-compatible chat/completions
                        path = 'chat/completions';
                        if (typeof initialBody.max_tokens !== 'number') initialBody.max_tokens = 2048;
                    } else if (provider === 'mistral') {
                        // Mistral is OpenAI-compatible chat/completions
                        path = 'chat/completions';
                        if (typeof initialBody.max_tokens !== 'number') initialBody.max_tokens = 2048;
                    } else if (provider === 'google') {
                        // Gemini generateContent; build body via sanitizer and call directly
                        const modelId = initialBody.model || selModel;
                        const gcBodyInfo = sanitizeRequestForModel({ body: initialBody, provider: 'google', model: modelId });
                        const gcBody = gcBodyInfo.body || {};
                        if (!gcBody.generationConfig) gcBody.generationConfig = {};
                        if (typeof gcBody.generationConfig.maxOutputTokens !== 'number') gcBody.generationConfig.maxOutputTokens = 2048;
                        try {
                            if (reqPreviewMode === 'only') {
                                const promptOnly = Array.isArray(gcBody.contents) ? gcBody.contents.filter(c => c.role === 'user').flatMap(c => c.parts || []).map(p => p.text).filter(Boolean).join('\n\n') : '';
                                runRequestView.textContent = (promptOnly || '').trim();
                            } else {
                                runRequestView.textContent = JSON.stringify(gcBody, null, 2);
                            }
                        } catch { runRequestView.textContent = JSON.stringify(gcBody, null, 2); }
                        const p = `models/${modelId}:generateContent`;
                        let res = await llmRequest(p, { method: 'POST', body: gcBody, headers: { 'x-pm-auth': 'google-query-key' }, connId: selConn?.id });
                        if (!res.ok) {
                            let msg = `HTTP ${res.status}`;
                            try { const t = await res.text(); msg += ` - ${t}`; } catch {}
                            throw new Error(msg);
                        }
                        const data = await res.json();
                        let text = '';
                        try {
                            const candidates = data?.candidates || [];
                            const first = candidates[0];
                            const parts = first?.content?.parts || [];
                            text = parts.map(p => p?.text || '').filter(Boolean).join('\n');
                        } catch {}
                        runResponseView.textContent = text || '(no content)';
                        runLoading.classList.add('hidden');
                        return;
                    }
                    if (provider === 'openai' && capsInfo.preferEndpoint === 'responses') {
                        path = 'responses';
                        const inputText = (Array.isArray(initialBody.messages) ? initialBody.messages.map(m => m.content).join('\n\n') : (initialBody.input || '')) || 'ping';
                        const out = { model: initialBody.model, input: inputText };
                        // Only include max_output_tokens if user explicitly set max_tokens
                        if (typeof body.max_tokens === 'number') out.max_output_tokens = body.max_tokens;
                        // Pass through Responses extras
                        if (typeof initialBody.temperature === 'number') out.temperature = initialBody.temperature;
                        if (typeof initialBody.top_p === 'number') out.top_p = initialBody.top_p;
                        if (typeof initialBody.stream === 'boolean') out.stream = initialBody.stream;
                        if (typeof initialBody.background === 'boolean') out.background = initialBody.background;
                        if (initialBody.service_tier) out.service_tier = initialBody.service_tier;
                        if (initialBody.reasoning) out.reasoning = initialBody.reasoning;
                        if (initialBody.verbosity) out.verbosity = initialBody.verbosity;
                        if (typeof initialBody.minimal_reasoning === 'boolean') out.minimal_reasoning = initialBody.minimal_reasoning;
                        if (initialBody.cfg) out.cfg = initialBody.cfg;
                        if (initialBody.extra_args) out.extra_args = initialBody.extra_args;
                        initialBody = out;
                    }
                    if (provider === 'openai' && capsInfo.preferEndpoint === 'embeddings') {
                        path = 'embeddings';
                        const inputText = (Array.isArray(initialBody.messages) ? initialBody.messages.map(m => m.content).join('\n\n') : (initialBody.input || '')) || 'ping';
                        const out = { model: initialBody.model, input: inputText };
                        if (typeof body.dimensions === 'number') out.dimensions = body.dimensions;
                        initialBody = out;
                    }
                    // Deep research: ensure a minimal tool
                    if (provider === 'openai' && capsInfo.ensureTools) {
                        const tools = Array.isArray(initialBody.tools) ? initialBody.tools.slice(0) : [];
                        const hasTool = tools.some(t => t?.type === capsInfo.ensureTools);
                        if (!hasTool) tools.push({ type: capsInfo.ensureTools });
                        initialBody.tools = tools;
                    }
                    // Render request preview according to current toggle
                    try {
                        if (reqPreviewMode === 'only') {
                            const promptOnly = Array.isArray(initialBody.messages)
                                ? initialBody.messages.filter(m => m.role === 'user').map(m => m.content).join('\n\n')
                                : (initialBody.input || '');
                            runRequestView.textContent = (promptOnly || '').trim();
                        } else {
                            runRequestView.textContent = JSON.stringify(initialBody, null, 2);
                        }
                    } catch { runRequestView.textContent = JSON.stringify(initialBody, null, 2); }
                    // Add provider-specific headers when needed (llmRequest will also handle direct mode)
                    const headers = {};
                    let res = await llmRequest(path, { method: 'POST', body: initialBody, headers, connId: selConn?.id });
                    // If OpenAI/x.ai returns an unsupported parameter, strip it and retry once
                    if (!res.ok && (provider === 'openai' || provider === 'xai') && res.status === 400) {
                        try {
                            const errJson = await res.json();
                            const code = errJson?.error?.code;
                            const param = errJson?.error?.param;
                            if ((code === 'unsupported_value' || code === 'unsupported_parameter') && param) {
                                const retryBody = Object.assign({}, initialBody);
                                delete retryBody[param];
                                res = await llmRequest(path, { method: 'POST', body: retryBody, headers, connId: selConn?.id });
                            } else if (/Unsupported parameter/i.test(errJson?.error?.message || '')) {
                                const retryBody = Object.assign({}, initialBody);
                                ['top_p','temperature','presence_penalty','frequency_penalty','seed','stop','response_format'].forEach(k => { if (k in retryBody) delete retryBody[k]; });
                                res = await llmRequest(path, { method: 'POST', body: retryBody, headers, connId: selConn?.id });
                            }
                        } catch {}
                    }
                    // If OpenAI indicates a different endpoint is required, follow docs and retry accordingly
                    if (!res.ok && provider === 'openai' && (res.status === 404 || res.status === 400)) {
                        let text = '';
                        try { text = await res.clone().text(); } catch {}
                        // responses API
                        if (/only supported in v1\/responses/i.test(text)) {
                            const inputText = (Array.isArray(initialBody.messages) ? initialBody.messages.filter(m=>m.role==='user').map(m=>m.content).join('\n\n') : (initialBody.input || '')) || 'ping';
                            const respBody = { model: initialBody.model, input: inputText };
                            res = await llmRequest('responses', { method: 'POST', body: respBody, connId: selConn?.id });
                        }
                        // legacy completions API
                        else if (/not supported in the v1\/chat\/completions endpoint\..*v1\/completions/i.test(text)) {
                            const prompt = (Array.isArray(initialBody.messages) ? initialBody.messages.map(m => `${m.role}: ${m.content}`).join('\n') : '') || 'ping';
                            const compBody = { model: initialBody.model, prompt };
                            res = await llmRequest('completions', { method: 'POST', body: compBody, connId: selConn?.id });
                        }
                    }
                    if (!res.ok) {
                        let msg = `HTTP ${res.status}`;
                        try { const t = await res.text(); msg += ` - ${t}`; } catch {}
                        throw new Error(msg);
                    }
                    const data = await res.json();
                    let text = '';
                    // OpenAI Chat/Completions style
                    if (data?.choices?.length) {
                        const c = data.choices[0];
                        // If content is array of parts, join text parts
                        if (Array.isArray(c.message?.content)) {
                            text = c.message.content.map(p => typeof p === 'string' ? p : (p?.text || '')).filter(Boolean).join('\n');
                        } else {
                            text = c.message?.content || c.text || '';
                        }
                    }
                    // OpenAI Responses style – prefer output_text (plain) if present
                    else if (Array.isArray(data?.output_text) && data.output_text.length) {
                        text = data.output_text.join('\n');
                    }
                    // Some Responses return message/content arrays
                    else if (data?.message?.content) {
                        const mc = data.message.content;
                        text = Array.isArray(mc) ? mc.map(p => p?.text || '').filter(Boolean).join('\n') : mc;
                    }
                    // Anthropic messages content
                    else if (Array.isArray(data?.content) && data.content.length && data.content[0]?.text) {
                        try { text = data.content.map(p => p.text).filter(Boolean).join('\n\n'); } catch { text = data.content[0]?.text || ''; }
                    }
                    // Fallback: stringify only if explicitly requested JSON response
                    else {
                        // If the request specified response_format: json_object, keep JSON; else keep as empty string
                        const reqPreview = runRequestView.textContent || '';
                        if (/"response_format"\s*:\s*\{\s*"type"\s*:\s*"json_object"/i.test(reqPreview)) {
                            text = JSON.stringify(data, null, 2);
                        } else {
                            // try common fields
                            text = data?.text || '';
                        }
                    }
                    runResponseView.textContent = text;
                    lastRunResponseText = text;
                } catch (e) {
                    const msg = e?.message || String(e);
                    if (/Failed to fetch/i.test(msg)) {
                        let hint = 'Network/CORS blocked. ';
                        try {
                            const conn = (typeof getActiveLlmConn === 'function') ? getActiveLlmConn() : null;
                            const prov = conn && conn.base && typeof detectProvider === 'function' ? detectProvider(conn.base) : 'openai';
                            hint += 'Proxy is ON and this connection is server-stored; please verify your Supabase URL/KEY and function deployments.';
                        } catch {}
                        runError.textContent = `${msg}. ${hint}`;
                    } else {
                        runError.textContent = msg;
                    }
                } finally {
                    runLoading.classList.add('hidden');
                }
            }

            function openRunModal() {
                if (!runModal) return;
                runError.textContent = '';
                runResponseView.textContent = '';
                const { body } = buildRunPayload();
                try {
                    if (reqPreviewMode === 'only') {
                        const promptOnly = Array.isArray(body.messages)
                            ? body.messages.filter(m => m.role === 'user').map(m => m.content).join('\n\n')
                            : (body.input || '');
                        runRequestView.textContent = (promptOnly || '').trim();
                    } else {
                        runRequestView.textContent = JSON.stringify(body, null, 2);
                    }
                } catch { runRequestView.textContent = JSON.stringify(body, null, 2); }
                try {
                    const selModel = llmSelect?.value || '';
                    const conn = resolveConnForModel(selModel) || ((typeof getActiveLlmConn === 'function') ? getActiveLlmConn() : null);
                    const base = conn?.base || (window.__PM_LLM_BASE || '');
                    let host = '';
                    try { host = base ? new URL(base).hostname : ''; } catch {}
                    const model = selModel;
                    const serverBadge = conn && conn.server ? ' • server' : ' • not server';
                    runActiveLlm.textContent = `Model: ${model}${host ? ' • ' + host : ''}${serverBadge}`;
                } catch { runActiveLlm.textContent = ''; }
                // If no model is selected, surface the LLM drawer to help selection
                if (!llmSelect || !llmSelect.value) {
                    try { if (typeof openDrawer === 'function') openDrawer('llm', 'LLM Model'); } catch {}
                }
                runModal.classList.remove('hidden');
            }
            function closeRunModal() { if (runModal) runModal.classList.add('hidden'); }
            if (runPromptBtn) runPromptBtn.addEventListener('click', openRunModal);
            if (runExecuteBtn) runExecuteBtn.addEventListener('click', executeRunPrompt);
            if (runCancelBtn) runCancelBtn.addEventListener('click', closeRunModal);
            if (closeRunModalBtn) closeRunModalBtn.addEventListener('click', closeRunModal);
            if (runModal) runModal.addEventListener('click', (e) => { if (e.target === runModal) closeRunModal(); });
            if (copyRunReqBtn) copyRunReqBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText(runRequestView.textContent || ''); } catch {} });
            if (copyRunResBtn) copyRunResBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText(runResponseView.textContent || ''); } catch {} });
            if (reqToggleFullBtn && reqToggleOnlyBtn) {
                const syncReqToggleUI = () => {
                    if (reqPreviewMode === 'only') {
                        reqToggleOnlyBtn.classList.add('bg-[--panel-bg]');
                        reqToggleFullBtn.classList.remove('bg-[--panel-bg]');
                    } else {
                        reqToggleFullBtn.classList.add('bg-[--panel-bg]');
                        reqToggleOnlyBtn.classList.remove('bg-[--panel-bg]');
                    }
                };
                const rerenderPreview = () => {
                    try {
                        const { body } = buildRunPayload();
                        if (reqPreviewMode === 'only') {
                            const promptOnly = Array.isArray(body.messages)
                                ? body.messages.filter(m => m.role === 'user').map(m => m.content).join('\n\n')
                                : (body.input || '');
                            runRequestView.textContent = (promptOnly || '').trim();
                        } else {
                            runRequestView.textContent = JSON.stringify(body, null, 2);
                        }
                    } catch {}
                };
                reqToggleFullBtn.addEventListener('click', () => { reqPreviewMode = 'full'; syncReqToggleUI(); rerenderPreview(); });
                reqToggleOnlyBtn.addEventListener('click', () => { reqPreviewMode = 'only'; syncReqToggleUI(); rerenderPreview(); });
                syncReqToggleUI();
            }

            // Helpers for safe HTML
            function escapeHtml(s) {
                return String(s || '')
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }
            function escapeAttr(s) { return escapeHtml(s).replace(/\n/g, ' '); }

            // ===== Response persistence and log =====
            async function saveCurrentResponse() {
                if (!supabaseClient) { if (typeof showValidationAlert === 'function') showValidationAlert('Not connected.'); return; }
                const text = (runResponseView?.textContent || lastRunResponseText || '').trim();
                if (!text) { if (typeof showValidationAlert === 'function') showValidationAlert('No response to save.'); return; }
                const { data: userData } = await supabaseClient.auth.getUser();
                const uid = userData?.user?.id;
                if (!uid) { if (typeof showValidationAlert === 'function') showValidationAlert('You must be logged in.'); return; }
                const version = selectedVersionId ? prompts.find(p => String(p.id) === String(selectedVersionId)) : null;
                const row = {
                    user_id: uid,
                    prompt_version_id: version?.id || null,
                    prompt_title: version?.title || (titleInput?.value || ''),
                    prompt_version: version?.version || null,
                    model: (llmSelect?.value || null),
                    response_text: text
                };
                const { error } = await supabaseClient.from('prompt_responses').insert(row);
                if (error) { if (typeof showValidationAlert === 'function') showValidationAlert('Save failed: ' + (error.message || '')); return; }
                // Optional feedback
            }
            if (saveRunResponseBtn) saveRunResponseBtn.addEventListener('click', () => { saveCurrentResponse(); });

            function openResponseLog() { if (responseLogModal) { responseLogModal.classList.remove('hidden'); loadResponseLog(); } }
            function closeResponseLog() { if (responseLogModal) responseLogModal.classList.add('hidden'); }
            if (openResponseLogBtn) openResponseLogBtn.addEventListener('click', openResponseLog);
            if (closeResponseLogModalBtn) closeResponseLogModalBtn.addEventListener('click', closeResponseLog);
            if (responseLogMenuBtn) responseLogMenuBtn.addEventListener('click', () => { openResponseLog(); });
            if (responseLogModal) responseLogModal.addEventListener('click', (e) => { if (e.target === responseLogModal) closeResponseLog(); });

            async function loadResponseLog() {
                if (!supabaseClient) return;
                const { data: userData } = await supabaseClient.auth.getUser();
                const uid = userData?.user?.id;
                if (!uid) { if (respLogStatus) respLogStatus.textContent = 'Please log in.'; return; }
                const q = (respLogSearch?.value || '').trim();
                let query = supabaseClient.from('prompt_responses')
                    .select('*')
                    .eq('user_id', uid)
                    .order('run_at', { ascending: false })
                    .range(respLogPage * RESP_LOG_PAGE_SIZE, (respLogPage + 1) * RESP_LOG_PAGE_SIZE - 1);
                if (q) {
                    query = query.ilike('prompt_title', `%${q}%`);
                }
                const { data, error } = await query;
                if (error) { if (respLogStatus) respLogStatus.textContent = 'Load failed'; return; }
                renderResponseLogRows(data || []);
                if (respLogStatus) respLogStatus.textContent = `Page ${respLogPage + 1}`;
            }
            function renderStars(rating) {
                const r = Number.isFinite(rating) ? Math.max(0, Math.min(5, rating)) : 0;
                let html = '';
                for (let i = 1; i <= 5; i++) {
                    const filled = i <= r;
                    html += `<button data-star="${i}" class="star-btn ${filled ? 'text-yellow-400' : 'text-[--text-muted-dark]'}">★</button>`;
                }
                return html;
            }
            function renderResponseLogRows(rows) {
                if (!respLogTbody) return;
                respLogTbody.innerHTML = '';
                (rows || []).forEach(row => {
                    const tr = document.createElement('tr');
                    tr.className = 'border-b border-[--border-dark]';
                    const dt = new Date(row.run_at);
                    tr.innerHTML = `
                        <td class="p-2 align-top">${escapeHtml(row.prompt_title || '')}</td>
                        <td class="p-2 align-top">${escapeHtml(row.prompt_version || '')}</td>
                        <td class="p-2 align-top">${escapeHtml(row.model || '')}</td>
                        <td class="p-2 align-top whitespace-nowrap">${escapeHtml(dt.toLocaleString())}</td>
                        <td class="p-2 align-top">
                            <div class="flex items-center gap-1" data-id="${escapeAttr(String(row.id))}">
                                ${renderStars(row.rating)}
                            </div>
                        </td>
                        <td class="p-2 align-top w-[30%]">
                            <div class="flex items-center gap-1">
                                <input type="text" class="form-control text-xs py-1 px-2 rounded-md w-full" placeholder="Add a comment" value="${escapeAttr(row.comment || '')}">
                                <button class="action-button text-xs save-comment">Save</button>
                            </div>
                        </td>
                        <td class="p-2 align-top">
                            <button class="action-button text-xs view-text">View</button>
                            <button class="action-button text-xs delete-row">Delete</button>
                        </td>`;
                    // Wire events
                    tr.querySelectorAll('.star-btn').forEach(btn => {
                        btn.addEventListener('click', async () => {
                            const val = Number(btn.getAttribute('data-star')) || 0;
                            const { data: userData } = await supabaseClient.auth.getUser();
                            const uid = userData?.user?.id; if (!uid) return;
                            await supabaseClient.from('prompt_responses').update({ rating: val }).eq('id', row.id).eq('user_id', uid);
                            loadResponseLog();
                        });
                    });
                    const commentInput = tr.querySelector('input');
                    const saveCommentBtn = tr.querySelector('.save-comment');
                    if (saveCommentBtn) saveCommentBtn.addEventListener('click', async () => {
                        const val = commentInput?.value || '';
                        const { data: userData } = await supabaseClient.auth.getUser();
                        const uid = userData?.user?.id; if (!uid) return;
                        await supabaseClient.from('prompt_responses').update({ comment: val }).eq('id', row.id).eq('user_id', uid);
                    });
                    const viewBtn = tr.querySelector('.view-text');
                    if (viewBtn) viewBtn.addEventListener('click', () => {
                        if (typeof readModeContent !== 'undefined' && readModeContent) {
                            readModeContent.textContent = row.response_text || '';
                            if (typeof readModeModal !== 'undefined' && readModeModal) readModeModal.classList.remove('hidden');
                        } else {
                            alert(row.response_text || '');
                        }
                    });
                    const delBtn = tr.querySelector('.delete-row');
                    if (delBtn) delBtn.addEventListener('click', async () => {
                        const ok = confirm('Delete this saved response?');
                        if (!ok) return;
                        const { data: userData } = await supabaseClient.auth.getUser();
                        const uid = userData?.user?.id; if (!uid) return;
                        await supabaseClient.from('prompt_responses').delete().eq('id', row.id).eq('user_id', uid);
                        loadResponseLog();
                    });
                    respLogTbody.appendChild(tr);
                });
            }
            if (respLogRefresh) respLogRefresh.addEventListener('click', () => { respLogPage = 0; loadResponseLog(); });
            if (respLogPrev) respLogPrev.addEventListener('click', () => { respLogPage = Math.max(0, respLogPage - 1); loadResponseLog(); });
            if (respLogNext) respLogNext.addEventListener('click', () => { respLogPage = respLogPage + 1; loadResponseLog(); });
            if (respLogSearch) respLogSearch.addEventListener('keydown', (e) => { if (e.key === 'Enter') { respLogPage = 0; loadResponseLog(); } });

            const projectsListContainer = document.getElementById('projects-list-container');

            const templatesModal = document.getElementById('templates-modal');
            const templatesBtn = document.getElementById('templates-btn');
            const closeTemplatesBtn = document.getElementById('close-templates-btn');
            const templatesGridContainer = document.getElementById('templates-grid-container');
            const templatesProjectFilter = document.getElementById('templates-project-filter');
            
            const dependencyViewerModal = document.getElementById('dependency-viewer-modal');
            const dependencyViewerTitle = document.getElementById('dependency-viewer-title');
            const dependencyViewerContent = document.getElementById('dependency-viewer-content');
            const closeDependencyViewerBtn = document.getElementById('close-dependency-viewer-btn');
            
            const commentsViewerModal = document.getElementById('comments-viewer-modal');
            const commentsViewerTitle = document.getElementById('comments-viewer-title');
            const commentsViewerContent = document.getElementById('comments-viewer-content');
            const closeCommentsViewerBtn = document.getElementById('close-comments-viewer-btn');

            const readModeBtn = document.getElementById('read-mode-btn');
            const readModeIconClosed = document.getElementById('read-mode-icon-closed');
            const readModeIconOpen = document.getElementById('read-mode-icon-open');
            const readModeModal = document.getElementById('read-mode-modal');
            const readModeContent = document.getElementById('read-mode-content');

            // Dashboard
            const dashboardBtn = document.getElementById('dashboard-btn');
            const dashboardModal = document.getElementById('dashboard-modal');
            const closeDashboardBtn = document.getElementById('close-dashboard-btn');
            const dashboardPeriodSelect = document.getElementById('dashboard-period-select');
            let tokensChart, promptsChart, modelsChart, projectsChart, statusChart, tagsChart;

            const diffModal = document.getElementById('diff-modal');
            const diffModalTitle = document.getElementById('diff-modal-title');
            const closeDiffModalBtn = document.getElementById('close-diff-modal-btn');
            const diffPanelA = document.getElementById('diff-panel-a');
            const diffPanelB = document.getElementById('diff-panel-b');
            const diffTitleA = document.getElementById('diff-title-a');
            const diffTitleB = document.getElementById('diff-title-b');

            // Modal Gráfico
            const graphViewBtn = document.getElementById('graph-view-btn');
            const dependencyGraphModal = document.getElementById('dependency-graph-modal');
            const closeDependencyGraphBtn = document.getElementById('close-dependency-graph-btn');
            const dependencyGraphSvg = document.getElementById('dependency-graph-svg');
            const graphProjectFilter = document.getElementById('graph-project-filter');
            const createConnectionBtn = document.getElementById('create-connection-btn');
            const deleteConnectionBtn = document.getElementById('delete-connection-btn');
            const graphTooltip = document.getElementById('graph-tooltip');
            
            // Modal Gerenciador de Listas
            const listManagerBtn = document.getElementById('list-manager-btn');
            const listManagerModal = document.getElementById('list-manager-modal');
            const closeListManagerBtn = document.getElementById('close-list-manager-btn');
            const xmlTagsManagerContainer = document.getElementById('xml-tags-manager-container');
            const varLibraryManagerContainer = document.getElementById('var-library-manager-container');
            const generalTagsManagerContainer = document.getElementById('general-tags-manager-container');
            const addGeneralTagManagerInput = document.getElementById('add-general-tag-manager-input');
            const addGeneralTagManagerBtn = document.getElementById('add-general-tag-manager-btn');
            const addXmlTagManagerInput = document.getElementById('add-xml-tag-manager-input');
            const addXmlTagManagerBtn = document.getElementById('add-xml-tag-manager-btn');
            const addVarLibraryManagerInput = document.getElementById('add-var-library-manager-input');
            const addVarLibraryManagerBtn = document.getElementById('add-var-library-manager-btn');
            const llmManagerContainer = document.getElementById('llm-manager-container');
            const addLlmCategoryManagerInput = document.getElementById('add-llm-category-manager-input');
            const addLlmCategoryManagerBtn = document.getElementById('add-llm-category-manager-btn');

            // Modal Input Gallery
            const inputGalleryBtn = document.getElementById('input-gallery-btn');
            const inputGalleryModal = document.getElementById('input-gallery-modal');
            const closeInputGalleryBtn = document.getElementById('close-input-gallery-btn');
            const inputGalleryList = document.getElementById('input-gallery-list');
            const inputGalleryProjectFilter = document.getElementById('input-gallery-project-filter');
            const inputGalleryProjectAssign = document.getElementById('input-gallery-project-assign');
            const inputGalleryEditor = document.getElementById('input-gallery-editor');
            const saveInputGalleryBtn = document.getElementById('save-input-gallery-btn');
            const inputGalleryName = document.getElementById('input-gallery-name');
            const inputGalleryId = document.getElementById('input-gallery-id');
            const addNewInputBtn = document.getElementById('add-new-input-btn');
            
            // Add Input Dropdown
            const addInputInput = document.getElementById('add-input-input');
            const addInputDropdown = document.getElementById('add-input-dropdown');
            // Import elements
            const importBtn = document.getElementById('import-btn');
            const importFromGitBtn = document.getElementById('import-from-git-btn');
            const importFileInput = document.getElementById('import-file-input');
            const importModal = document.getElementById('import-modal');
            const closeImportModalBtn = document.getElementById('close-import-modal');
            const importPromptNameInput = document.getElementById('import-prompt-name');
            const importProjectInput = document.getElementById('import-project');
            const importLlmSelect = document.getElementById('import-llm');
            const cancelImportBtn = document.getElementById('cancel-import');
            const confirmImportBtn = document.getElementById('confirm-import');
            // Commit modal refs
            const commitModal = document.getElementById('commit-modal');
            const closeCommitModalBtn = document.getElementById('close-commit-modal');
            const commitRepoLabel = document.getElementById('commit-repo-label');
            const commitBranchSelect = document.getElementById('commit-branch');
            const commitFilePathInput = document.getElementById('commit-file-path');
            const commitMessageInput = document.getElementById('commit-message');
            const commitLatestInfo = document.getElementById('commit-latest-info');
            const cancelCommitBtn = document.getElementById('cancel-commit');
            const confirmCommitBtn = document.getElementById('confirm-commit');
            const commitChangesBtn = document.getElementById('commit-changes-btn');
            // Import from Git modal refs
            const importGitModal = document.getElementById('import-git-modal');
            const closeImportGitModalBtn = document.getElementById('close-import-git-modal');
            const refreshGitBrowserBtn = document.getElementById('refresh-git-browser-btn');
            const gitBrowserRepos = document.getElementById('git-browser-repos');
            const gitBrowserFiles = document.getElementById('git-browser-files');
            const gitBrowserLoadReposBtn = document.getElementById('git-browser-load-repos-btn');
            const gitFilesFilterInput = document.getElementById('git-files-filter');
            const gitImportTitleInput = document.getElementById('git-import-title');
            const gitImportProjectInput = document.getElementById('git-import-project');
            const gitImportCancelBtn = document.getElementById('git-import-cancel');
            const gitImportConfirmBtn = document.getElementById('git-import-confirm');
            let pendingImportedText = '';
            let pendingImportFilename = '';
            let lastImportedGitFilePath = '';
            // Formatting toolbar removed

            // Find and Replace
            const findBtn = document.getElementById('find-btn');
            const findReplaceBar = document.getElementById('find-replace-bar');
            const findInput = document.getElementById('find-input');
            const replaceInput = document.getElementById('replace-input');
            const findCounter = document.getElementById('find-counter');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const replaceBtn = document.getElementById('replace-btn');
            const replaceAllBtn = document.getElementById('replace-all-btn');
            const closeFindBtn = document.getElementById('close-find-btn');

            // Dynamic Settings (model-aware)
            const dynamicSettingsContainer = document.getElementById('dynamic-settings-container');

            function getSelectedProviderAndCaps() {
                const llmId = llmSelect?.value || '';
                let provider = 'openai';
                try {
                    const conn = (typeof resolveConnForModel === 'function') ? resolveConnForModel(llmId) : null;
                    const base = conn?.base || (typeof getActiveLlmConn === 'function' ? (getActiveLlmConn()?.base || '') : '') || (window.__PM_LLM_BASE || '');
                    if (typeof detectProvider === 'function') provider = detectProvider(base);
                } catch {}
                const caps = (typeof getModelCaps === 'function') ? getModelCaps(provider, llmId) : { provider };
                return { provider, llmId, caps };
            }

            function getDynamicSettingsSchema() {
                const { provider, llmId, caps } = getSelectedProviderAndCaps();
                const isGpt5Family = (() => { try { return /^gpt-5(?:$|[-_])|^gpt-5-chat$/i.test(llmId || ''); } catch { return false; } })();
                // If unsupported modality, no editable settings
                if (caps && caps.unsupportedReason) return [];
                const fields = [];
                // Endpoint preferences can hide/show knobs
                const preferResp = caps && caps.preferEndpoint === 'responses';
                const preferEmbed = caps && caps.preferEndpoint === 'embeddings';

                // Embeddings: do not show tokens; show dimensions only
                if (preferEmbed) {
                    // Embeddings-specific controls
                    fields.push({ key: 'dimensions', type: 'number', label: 'Dimensions', min: 1, step: 1, default: '' });
                    return fields;
                }

                // For other endpoints, offer a tokens control with label adapted for Responses
                fields.push({ key: 'maxTokens', type: 'number', label: preferResp ? 'Max output tokens' : 'Max tokens', min: 1, step: 1, default: '' });

                // Provider-baseline knobs
                if (provider === 'anthropic') {
                    fields.push({ key: 'system', type: 'textarea', label: 'System (Anthropic)', default: '' });
                    fields.push({ key: 'topK', type: 'number', label: 'Top K (Anthropic)', min: 1, step: 1, default: '' });
                }

                // OpenAI Responses endpoint specific controls
                if (preferResp && provider === 'openai') {
                    fields.push({ key: 'temperature', type: 'range', label: 'Temperature', min: 0, max: 2, step: 0.1, default: 0.7, format: (v) => parseFloat(v).toFixed(1) });
                    fields.push({ key: 'topP', type: 'range', label: 'Top P', min: 0, max: 1, step: 0.01, default: 0.9, format: (v) => parseFloat(v).toFixed(2) });
                    fields.push({ key: 'serviceTier', type: 'select', label: 'Service tier', options: ['auto','default','scale','flex','priority'], default: 'auto' });
                    fields.push({ key: 'stream', type: 'select', label: 'Stream', options: ['false','true'], default: 'false' });
                    fields.push({ key: 'background', type: 'select', label: 'Background', options: ['false','true'], default: 'false' });
                    fields.push({ key: 'reasoningEffort', type: 'select', label: 'Reasoning effort', options: ['low','medium','high'], default: 'medium' });
                    // gpt-5 family exclusive controls
                    if (isGpt5Family) {
                        fields.push({ key: 'verbosity', type: 'select', label: 'Verbosity (gpt-5 family)', options: ['low','medium','high'], default: 'medium' });
                        fields.push({ key: 'minimalReasoning', type: 'select', label: 'Minimal reasoning (gpt-5 family)', options: ['false','true'], default: 'false' });
                        fields.push({ key: 'cfg', type: 'textarea', label: 'CFG grammar (optional)', default: '' });
                    }
                    fields.push({ key: 'extraArgs', type: 'textarea', label: 'Extra args (JSON)', default: '' });
                }

                // For OpenAI/x.ai chat-like endpoints
                if (!preferResp) {
                    // Sampling knobs
                    fields.push({ key: 'temperature', type: 'range', label: 'Temperature', min: 0, max: 2, step: 0.1, default: 0.7, format: (v) => parseFloat(v).toFixed(1) });
                    fields.push({ key: 'topP', type: 'range', label: 'Top P', min: 0, max: 1, step: 0.01, default: 0.9, format: (v) => parseFloat(v).toFixed(2) });
                    fields.push({ key: 'stopSequences', type: 'textarea', label: 'Stop sequences (one per line)', default: '' });
                    if (provider === 'openai') {
                        // Only show OpenAI-specific penalties/seed/response format for OpenAI
                        fields.push({ key: 'presencePenalty', type: 'range', label: 'Presence penalty', min: -2, max: 2, step: 0.1, default: 0, format: (v) => parseFloat(v).toFixed(1) });
                        fields.push({ key: 'frequencyPenalty', type: 'range', label: 'Frequency penalty', min: -2, max: 2, step: 0.1, default: 0, format: (v) => parseFloat(v).toFixed(1) });
                        fields.push({ key: 'seed', type: 'number', label: 'Seed', min: 0, step: 1, default: '' });
                        fields.push({ key: 'responseFormat', type: 'select', label: 'Response format', options: ['text','json_object'], default: 'text' });
                    }
                }

                // Finally, remove any fields that the caps explicitly drop or disallow
                const allowed = caps && Array.isArray(caps.allowed) ? new Set(caps.allowed.map(k =>
                    // map our UI keys to body keys for comparison
                    ({ temperature:'temperature', topP:'top_p', presencePenalty:'presence_penalty', frequencyPenalty:'frequency_penalty', maxTokens:'max_tokens', stopSequences:'stop', seed:'seed', responseFormat:'response_format', dimensions:'dimensions', topK:'top_k', system:'system', serviceTier:'service_tier', stream:'stream' }[k] || k)
                )) : null;
                const drop = caps && Array.isArray(caps.drop) ? new Set(caps.drop) : new Set();
                const keyToBody = (k) => ({ temperature:'temperature', topP:'top_p', presencePenalty:'presence_penalty', frequencyPenalty:'frequency_penalty', maxTokens:'max_tokens', stopSequences:'stop', seed:'seed', responseFormat:'response_format', dimensions:'dimensions', topK:'top_k', system:'system', serviceTier:'service_tier', stream:'stream', reasoningEffort:'reasoning', verbosity:'verbosity', minimalReasoning:'minimal_reasoning', extraArgs:'extra_args' }[k] || k);
                const filtered = fields.filter(f => {
                    const bodyKey = keyToBody(f.key);
                    if (drop.has(bodyKey)) return false;
                    if (allowed && !allowed.has(bodyKey)) return false;
                    return true;
                });
                return filtered;
            }

            function renderDynamicSettings(currentValues = {}) {
                const finalSchema = getDynamicSettingsSchema();

                dynamicSettingsContainer.innerHTML = '';

                finalSchema.forEach(field => {
                    const value = (currentValues && field.key in currentValues)
                        ? currentValues[field.key]
                        : (field.default !== undefined ? field.default : '');
                    const wrapper = document.createElement('div');
                    wrapper.className = 'space-y-1';
                    if (field.type === 'range') {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        const spanVal = document.createElement('span');
                        spanVal.className = 'font-mono';
                        spanVal.id = `setting-${field.key}-value`;
                        spanVal.textContent = field.format ? field.format(value) : String(value);
                        label.innerHTML = `<label>${S(field.label)}</label>`;
                        label.appendChild(spanVal);
                        const input = document.createElement('input');
                        input.id = `setting-${field.key}`;
                        input.type = 'range';
                        input.min = field.min;
                        input.max = field.max;
                        input.step = field.step;
                        input.value = value;
                        input.className = 'w-full';
                        input.addEventListener('input', (e) => {
                            spanVal.textContent = field.format ? field.format(e.target.value) : String(e.target.value);
                        });
                        wrapper.appendChild(label);
                        wrapper.appendChild(input);
                    } else if (field.type === 'select') {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        label.innerHTML = `<label>${S(field.label)}</label>`;
                        const select = document.createElement('select');
                        select.id = `setting-${field.key}`;
                        select.className = 'form-control rounded-md py-1 px-2 text-sm w-full';
                        (field.options || []).forEach(opt => {
                            const o = document.createElement('option');
                            o.value = opt; o.textContent = opt;
                            select.appendChild(o);
                        });
                        select.value = value;
                        // No summary chip; no-op
                        wrapper.appendChild(label);
                        wrapper.appendChild(select);
                    } else if (field.type === 'textarea') {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        label.innerHTML = `<label>${S(field.label)}</label>`;
                        const ta = document.createElement('textarea');
                        ta.id = `setting-${field.key}`;
                        ta.className = 'form-control rounded-md py-1 px-2 text-sm w-full';
                        ta.rows = field.rows || 3;
                        ta.value = value || '';
                        // No summary chip; no-op
                        wrapper.appendChild(label);
                        wrapper.appendChild(ta);
                    } else if (field.type === 'messages') {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        label.innerHTML = `<label>${S(field.label)}</label>`;
                        const container = document.createElement('div');
                        container.id = `setting-${field.key}`;
                        container.dataset.allowedRoles = JSON.stringify(field.allowedRoles || ['system','user','assistant']);
                        container.className = 'space-y-2';
                        const list = document.createElement('div');
                        list.className = 'space-y-2';
                        container.appendChild(list);
                        const rows = Array.isArray(value) ? value : (field.default || []);
                        const renderRow = (row, idx) => {
                            const rowEl = document.createElement('div');
                            rowEl.className = 'flex items-start gap-2';
                            rowEl.dataset.index = String(idx);
                            const roleSel = document.createElement('select');
                            roleSel.className = 'form-control rounded-md py-1 px-2 text-sm w-32';
                            const roles = field.allowedRoles || ['system','user','assistant'];
                            roles.forEach(r => {
                                const o = document.createElement('option');
                                o.value = r; o.textContent = r;
                                roleSel.appendChild(o);
                            });
                            roleSel.value = row.role || roles[0];
                            // No summary chip; no-op
                            const ta = document.createElement('textarea');
                            ta.className = 'form-control rounded-md py-1 px-2 text-sm flex-1';
                            ta.rows = 3;
                            ta.placeholder = 'Enter message content...';
                            ta.value = row.content || '';
                            // No summary chip; no-op
                            const delBtn = document.createElement('button');
                            delBtn.className = 'action-button text-xs';
                            delBtn.textContent = 'Remove';
                            delBtn.addEventListener('click', () => {
                                rowEl.remove();
                                // No summary chip; no-op
                            });
                            rowEl.appendChild(roleSel);
                            rowEl.appendChild(ta);
                            rowEl.appendChild(delBtn);
                            list.appendChild(rowEl);
                        };
                        rows.forEach((r, i) => renderRow(r, i));
                        const addBtn = document.createElement('button');
                        addBtn.className = 'action-button text-xs';
                        addBtn.textContent = 'Add message';
                        addBtn.addEventListener('click', () => {
                            renderRow({ role: (field.allowedRoles || ['system','user','assistant'])[0], content: '' }, list.children.length);
                            // No summary chip; no-op
                        });
                        wrapper.appendChild(label);
                        wrapper.appendChild(container);
                        wrapper.appendChild(addBtn);
                    } else if (field.type === 'number') {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        label.innerHTML = `<label>${S(field.label)}</label>`;
                        const input = document.createElement('input');
                        input.id = `setting-${field.key}`;
                        input.type = 'number';
                        if (typeof field.min !== 'undefined') input.min = field.min;
                        if (typeof field.max !== 'undefined') input.max = field.max;
                        if (typeof field.step !== 'undefined') input.step = field.step;
                        input.value = value ?? '';
                        input.className = 'form-control rounded-md py-1 px-2 text-sm w-full';
                        // No summary chip; no-op
                        wrapper.appendChild(label);
                        wrapper.appendChild(input);
                    } else {
                        const label = document.createElement('div');
                        label.className = 'flex justify-between items-center text-xs font-medium text-[--text-muted-dark]';
                        label.innerHTML = `<label>${S(field.label)}</label>`;
                        const input = document.createElement('input');
                        input.id = `setting-${field.key}`;
                        input.type = 'text';
                        input.value = value || '';
                        input.className = 'form-control rounded-md py-1 px-2 text-sm w-full';
                        // No summary chip; no-op
                        wrapper.appendChild(label);
                        wrapper.appendChild(input);
                    }
                    dynamicSettingsContainer.appendChild(wrapper);
                });

                // Summary chip removed; advanced options always visible
            }

            function collectDynamicSettings() {
                const finalSchema = getDynamicSettingsSchema();
                const out = {};
                finalSchema.forEach(field => {
                    if (field.type === 'messages') {
                        const container = document.getElementById(`setting-${field.key}`);
                        if (!container) return;
                        const rows = [...container.querySelectorAll('[data-index]')];
                        out[field.key] = rows.map(r => {
                            const role = r.querySelector('select')?.value || 'user';
                            const content = r.querySelector('textarea')?.value || '';
                            return { role, content };
                        }).filter(m => m.content && m.content.trim().length > 0);
                        return;
                    }
                    const el = document.getElementById(`setting-${field.key}`);
                    if (!el) return;
                    if (field.type === 'range') {
                        const num = parseFloat(el.value);
                        out[field.key] = isNaN(num) ? el.value : num;
                    } else if (field.type === 'number') {
                        const num = el.value === '' ? '' : Number(el.value);
                        out[field.key] = num;
                    } else if (field.type === 'textarea') {
                        out[field.key] = el.value;
                    } else {
                        out[field.key] = el.value;
                    }
                });
                return out;
            }

            // Summary chip removed; keeping function space minimal

            // Tags
            const tagsInput = document.getElementById('tags-input-aside');
            const tagsContainer = document.getElementById('tags-container-aside');
            const tagsDropdown = document.getElementById('tags-dropdown-aside');
            
            // Var Library
            const varLibraryInput = document.getElementById('var-library-input');
            const addVarLibraryBtn = document.getElementById('add-var-library-btn');
            const varLibraryDropdown = document.getElementById('var-library-dropdown');
            
            // Node Flow
            const nodeFlowBtn = document.getElementById('node-flow-btn');
            const nodeFlowModal = document.getElementById('node-flow-modal');
            const closeNodeFlowBtn = document.getElementById('close-node-flow-btn');
            const nodeFlowPromptList = document.getElementById('node-flow-prompt-list');
            const nodeFlowCanvas = document.getElementById('node-flow-canvas');
            const nodeFlowContent = document.getElementById('node-flow-content');
            const nodeFlowConnections = document.getElementById('node-flow-connections');
            const connectionsGroup = document.getElementById('connections-group');
            const nodeFlowProjectFilter = document.getElementById('node-flow-project-filter');
            const saveFlowBtn = document.getElementById('save-flow-btn');
            const savedFlowsDropdown = document.getElementById('saved-flows-dropdown');
            const runFlowBtn = document.getElementById('run-flow-btn');
            const flowModeBypassBtn = document.getElementById('flow-mode-bypass');
            const flowModeRunAllBtn = document.getElementById('flow-mode-runall');
            const flowContinueOnError = document.getElementById('flow-continue-on-error');
            const nodeResponseModal = document.getElementById('node-response-modal');
            const nodeResponseContent = document.getElementById('node-response-content');
            const nodeResponseTitle = document.getElementById('node-response-title');
            const nodeSaveResponseBtn = document.getElementById('node-save-response-btn');
            const nodePinResponseBtn = document.getElementById('node-pin-response-btn');
            const closeNodeResponseBtn = document.getElementById('close-node-response-btn');
            const nodePromptModal = document.getElementById('node-prompt-modal');
            const nodePromptContent = document.getElementById('node-prompt-content');
            const nodePromptTitle = document.getElementById('node-prompt-title');
            const closeNodePromptBtn = document.getElementById('close-node-prompt-btn');
            const deleteFlowBtn = document.getElementById('delete-flow-btn');

            // If D3 is unavailable (offline), disable features that require it
            if (!hasD3) {
                if (nodeFlowBtn) { nodeFlowBtn.disabled = true; nodeFlowBtn.title = 'Disabled: D3 not loaded (offline)'; }
                if (graphViewBtn) { graphViewBtn.disabled = true; graphViewBtn.title = 'Disabled: D3 not loaded (offline)'; }
            }

            // --- FUNÇÕES DE DADOS (AGORA COM SUPABASE) ---
            const loadFromLocalStorage = () => {
                try {
                    prompts = (JSON.parse(localStorage.getItem(PROMPTS_STORAGE_KEY) || '[]') || []).map(p => ({ ...p, status: normalizeStatus(p.status) }));
                    templates = JSON.parse(localStorage.getItem(TEMPLATES_STORAGE_KEY) || '[]');
                    inputGallery = JSON.parse(localStorage.getItem(INPUT_GALLERY_STORAGE_KEY) || '[]');
                    savedFlows = JSON.parse(localStorage.getItem(NODE_FLOWS_STORAGE_KEY) || '[]');
                    xmlTags = JSON.parse(localStorage.getItem(XML_TAGS_STORAGE_KEY) || '[]');
                    varLibrary = JSON.parse(localStorage.getItem(VAR_LIBRARY_STORAGE_KEY) || '[]');
                    llmList = JSON.parse(localStorage.getItem(LLM_LIST_STORAGE_KEY) || '{}');
                    projectNames = JSON.parse(localStorage.getItem(PROJECTS_STORAGE_KEY) || '[]');
                    projectRepoMap = JSON.parse(localStorage.getItem(PROJECT_REPO_MAP_STORAGE_KEY) || '{}');
                    console.info('Loaded data from localStorage (offline mode).');
                } catch (e) {
                    console.error('Error loading from localStorage:', e);
                }
            };

            const mapPromptRowToUI = (row) => {
                try {
                    const st = normalizeStatus(row.status);
                    return {
                        // keep DB id
                        id: row.id,
                        // unify camelCase used by UI
                        promptId: String(row.prompt_id || row.promptId || row.promptid || row.id || ''),
                        // parent reference normalized to parent_id (preferred); legacy parant_id supported if present
                        parent_id: row.parent_id || row.parant_id || row.parentId || null,
                        title: row.title,
                        content: row.content,
                        tags: Array.isArray(row.tags) ? row.tags : [],
                        project: row.project,
                        llm: row.llm,
                        status: st,
                        // prefer explicit date column, fallback to created_at or now
                        date: row.date || row.created_at || new Date().toISOString(),
                        // keep any extra UI-only fields if present
                        comments: row.comments || '',
                        version: row.version || '1.0',
                        temperature: typeof row.temperature === 'number' ? row.temperature : 0.7,
                        // topP may arrive as top_p from DB; prefer UI camelCase
                        topP: typeof row.topP === 'number' ? row.topP : (typeof row.top_p === 'number' ? row.top_p : 0.9),
                        effort: row.effort || 'Medium',
                        dependencies: Array.isArray(row.dependencies) ? row.dependencies : ((row.parent_id || row.parant_id) ? [row.parent_id || row.parant_id] : [])
                    };
                } catch { return row; }
            };

            // Map templates rows from DB to UI, normalizing parent reference and topP
            const mapTemplateRowToUI = (row) => {
                try {
                    return {
                        ...row,
                        parent_id: row.parent_id || row.parentId || null,
                        topP: typeof row.topP === 'number' ? row.topP : (typeof row.top_p === 'number' ? row.top_p : undefined)
                    };
                } catch { return row; }
            };

            // Project UI prompt object to DB snake_case columns and allowlist fields
    const mapPromptUIToDb = (item) => {
        let userId = null;
        try {
            if (typeof supabaseClient !== 'undefined' && supabaseClient) {
                const user = window.__PM_USER || null;
                if (user && user.id) userId = user.id;
            }
        } catch {}
        // Ensure we always send a valid group identifier; fallback to row id if missing
        const groupId = item.promptId || item.prompt_id || item.promptid || item.id || null;
        // Sanitize parent_id: must reference an existing version id; otherwise drop to null
        let parentRef = item.parent_id || item.parant_id || null;
        if (parentRef && !(Array.isArray(window.prompts) && window.prompts.some(p => String(p.id) === String(parentRef)))) {
            parentRef = null;
        }
        const out = {
            id: item.id,
            prompt_id: groupId,
            parent_id: parentRef,
            title: item.title,
            content: item.content,
            // Ensure version is persisted; DB enforces NOT NULL
            version: (item.version !== undefined && item.version !== null && String(item.version).trim() !== '')
                ? String(item.version)
                : '1.0',
            tags: Array.isArray(item.tags) ? item.tags : [],
            project: item.project || null,
            llm: item.llm || null,
            status: toDbStatus(item.status),
            date: item.date ? new Date(item.date).toISOString() : null,
            comments: (typeof item.comments === 'string') ? item.comments : (item.comments ? String(item.comments) : null),
            top_p: typeof item.topP === 'number' ? item.topP : (typeof item.top_p === 'number' ? item.top_p : undefined),
            temperature: typeof item.temperature === 'number' ? item.temperature : undefined,
            effort: item.effort,
            user_id: item.user_id || userId
        };
        Object.keys(out).forEach(k => { if (typeof out[k] === 'undefined') delete out[k]; });
        return out;
    };

            // Map Template object from UI to DB (snake_case fields only)
            const mapTemplateUIToDb = (tpl) => {
                let userId = null;
                try {
                    if (typeof supabaseClient !== 'undefined' && supabaseClient) {
                        const user = window.__PM_USER || null;
                        if (user && user.id) userId = user.id;
                    }
                } catch {}
                const out = {
                    id: tpl.id,
                    name: tpl.name,
                    title: tpl.title || null,
                    project: tpl.project || null,
                    content: tpl.content || '',
                    llm: tpl.llm || null,
                    temperature: typeof tpl.temperature === 'number' ? tpl.temperature : undefined,
                    top_p: typeof tpl.topP === 'number' ? tpl.topP : (typeof tpl.top_p === 'number' ? tpl.top_p : undefined),
                    effort: tpl.effort || null,
                    parent_id: tpl.parent_id || tpl.parentId || null,
                    dependencies: Array.isArray(tpl.dependencies) ? tpl.dependencies : [],
                    tags: Array.isArray(tpl.tags) ? tpl.tags : [],
                    user_id: tpl.user_id || userId
                };
                Object.keys(out).forEach(k => { if (typeof out[k] === 'undefined') delete out[k]; });
                return out;
            };

        const loadDataFromSupabase = async () => {
                try {
                    // DB status follows loadAllData progress exactly
                    setDbStatusLoading(0);
                    if (!window.dataService) throw new Error('No dataService');
                    const { prompts: P, templates: T, inputGallery: I, nodeFlows: N, lists: G } = await window.dataService.loadAllData((done, total) => {
                        const pct = Math.round((done/total) * 100);
                        setDbStatusLoading(pct);
                    });
                    // Mapping phase is fast; keep final Online after datasets are ready
                    prompts = (P || []).map(mapPromptRowToUI);
                    templates = (T || []).map(mapTemplateRowToUI);
                    inputGallery = I || [];
                    savedFlows = N || [];

                    xmlTags = G.find(l => l.name === 'xml_tags')?.data || [];
                    varLibrary = G.find(l => l.name === 'var_library')?.data || [];
                    llmList = G.find(l => l.name === 'llm_list')?.data || {};
                    projectNames = G.find(l => l.name === 'projects')?.data || [];
                    projectRepoMap = G.find(l => l.name === 'project_repo_map')?.data || {};
                    try {
                        const cacheMap = G.find(l => l.name === 'llm_models_cache')?.data || {};
                        Object.entries(cacheMap).forEach(([connId, ids]) => { try { localStorage.setItem(modelsCacheKey(connId), JSON.stringify(ids || [])); } catch {} });
                    } catch {}
                    // Refresh Versions panel project filter after loading data
                    try {
                        const prev = activeProjectFilter;
                        populateProjectFilter();
                        activeProjectFilter = prev || 'all';
                        updateProjectFilterUI();
                    } catch {}
                    // All done: mark DB as Online
            setDbStatusOnline();
                } catch (error) {
                    console.error('Error loading data from Supabase via dataService:', error);
            setDbStatusOffline();
                }
            };

                        // Funções para salvar/atualizar/deletar dados individuais
        const upsertItem = async (table, data) => {
                try {
                    if (!window.dataService) throw new Error('No dataService');
                    // Respect unique (user_id, name) for node_flows
            const rows = await window.dataService.upsert(table, data);
                    return rows || null;
                } catch (err) {
                    console.error(`Error upserting to ${table}:`, err);
                    showValidationAlert('Error saving to Supabase: ' + (err?.message || ''));
                    return null;
                }
            };

            const deleteItem = async (table, id) => {
                try {
                    if (!window.dataService) throw new Error('No dataService');
                    await window.dataService.del(table, { id });
                } catch (err) { console.error(`Error deleting from ${table}:`, err); }
            };

            // Specific helper to delete a node_flow by its unique name
            const deleteNodeFlowByName = async (name) => {
                try {
                    if (!window.dataService) throw new Error('No dataService');
                    await window.dataService.del('node_flows', { name });
                } catch (err) { console.error('Error deleting from node_flows by name:', err); }
            };

            const deleteItemsByPromptId = async (promptId) => {
                if (!supabaseClient) return;
                let userId = null;
                try {
                    const { data: sess } = await supabaseClient.auth.getSession();
                    userId = sess?.session?.user?.id || null;
                } catch {}
                const q = supabaseClient.from('prompts').delete().eq('prompt_id', promptId);
                const { error } = userId ? await q.eq('user_id', userId) : await q;
                if (error) console.error(`Error deleting prompts by promptId:`, error);
            };

            const updateGlobalList = async (listName, data) => {
                try {
                    if (!window.dataService) throw new Error('No dataService');
                    const res = await window.dataService.updateGlobalList(listName, data);
                    if (!res) console.error(`Error updating global list ${listName}`);
                } catch (err) { console.error(`Error updating global list ${listName}:`, err); }
            }

            // Cloud-only mode: disable all localStorage persistence helpers (no-ops)
            const savePromptsToStorage = () => {};
            const saveXmlTagsToStorage = () => {};
            const saveTemplatesToStorage = () => {};
            const saveVarLibraryToStorage = () => {};
            const saveLlmListToStorage = () => {};
            const saveInputGalleryToStorage = () => {};
            const saveFlowsToStorage = () => {};
            const saveProjectNamesToStorage = () => {};
            const saveProjectRepoMapToStorage = () => {};


            // --- LOGIC FUNCTIONS ---
            const addCurrentXmlTag = () => {
                const source = (typeof confirmModalInput !== 'undefined' && !confirmModal.classList.contains('hidden')) ? confirmModalInput : xmlTagInput;
                const tagName = (source?.value || '').trim();
                if (tagName && !xmlTags.includes(tagName)) {
                    xmlTags.push(tagName);
                    saveXmlTagsToStorage();
                    updateGlobalList('xml_tags', xmlTags);
                    if (source) source.value = '';
                }
            };

            const addCurrentVarToLibrary = () => {
                const source = (typeof confirmModalInput !== 'undefined' && !confirmModal.classList.contains('hidden')) ? confirmModalInput : varLibraryInput;
                let varName = (source?.value || '').trim();
                if (varName) {
                    if (!varName.startsWith('{{') || !varName.endsWith('}}')) {
                        varName = `{{${varName.replace(/{{|}}/g, '')}}}`;
                    }
                    if (!varLibrary.includes(varName)) {
                        varLibrary.push(varName);
                        saveVarLibraryToStorage();
                        updateGlobalList('var_library', varLibrary)
                        if (source) source.value = '';
                    }
                }
            };

            // --- RENDERING FUNCTIONS ---
            const populateLlmSelect = () => {
                const currentVal = llmSelect.value;
                llmSelect.innerHTML = '<option value="">Unspecified</option>';
                
                const sortedGroupNames = Object.keys(llmList).sort();

                sortedGroupNames.forEach(groupName => {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = groupName;
                    llmList[groupName].sort().forEach(llm => {
                        const option = document.createElement('option');
                        option.value = llm;
                        option.textContent = llm;
                        optgroup.appendChild(option);
                    });
                    llmSelect.appendChild(optgroup);
                });
                
                const allLlms = Object.values(llmList).flat();
                if (allLlms.includes(currentVal)) {
                    llmSelect.value = currentVal;
                } else {
                    llmSelect.value = '';
                }
            };

            const formatDate = (dateString) => {
                const date = new Date(dateString);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = String(date.getFullYear()).slice(-2);
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${day}/${month}/${year} ${hours}:${minutes}`;
            };

            // Compose the union of projects across prompts, templates, inputGallery and saved projectNames
            const getAllProjects = () => {
                const fromPrompts = prompts.map(p => p.project).filter(Boolean);
                const fromTemplates = templates.map(t => t.project).filter(Boolean);
                const fromInputs = inputGallery.map(i => i.project).filter(Boolean);
                return [...new Set([...fromPrompts, ...fromTemplates, ...fromInputs, ...projectNames])].sort();
            };

            const populateProjectList = (selectElement) => {
                const projects = getAllProjects();
                selectElement.innerHTML = '<option value="all">All Projects</option>';
                projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project;
                    option.textContent = project;
                    selectElement.appendChild(option);
                });
            };

            // For assignment dropdowns (no "All" option); includes an empty unassigned entry
            const populateProjectAssignList = (selectElement) => {
                const projects = getAllProjects();
                selectElement.innerHTML = '<option value="">Unassigned</option>';
                projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project;
                    option.textContent = project;
                    selectElement.appendChild(option);
                });
            };
            
            const populateProjectDataList = () => {
                 const projectList = document.getElementById('project-list-aside');
                 const existingProjects = [...new Set(prompts.map(p => p.project).filter(Boolean))];
                 projectList.innerHTML = '';
                 existingProjects.forEach(project => {
                     const option = document.createElement('option');
                     option.value = project;
                     projectList.appendChild(option);
                 });
            };

            // --- Dependencies state and helpers ---
            let currentDependencies = [];
            const getSortedPromptsForDeps = () => {
                return [...prompts].sort((a, b) => a.title.localeCompare(b.title) || parseFloat(b.version) - parseFloat(a.version));
            };
            const renderDependenciesDropdown = (filter = '') => {
                const list = dependenciesList;
                list.innerHTML = '';
                const q = (filter || '').toLowerCase();
                getSortedPromptsForDeps().forEach(p => {
                    if (String(p.id) === String(selectedVersionId)) return; // don't depend on self
                    const label = `${p.title} (v${p.version})`;
                    if (q && !label.toLowerCase().includes(q)) return;
                    const row = document.createElement('div');
                    row.className = 'px-3 py-2 hover:bg-[#333] border-b border-[--border-dark] cursor-pointer flex items-start gap-3';
                    const idStr = String(p.id);
                    row.innerHTML = `
                        <input type="checkbox" class="mt-1 h-4 w-4 flex-shrink-0" data-id="${escapeAttr(idStr)}" ${currentDependencies.map(String).includes(idStr) ? 'checked' : ''}>
                        <div class="min-w-0 flex-1">
                            <div class="text-sm font-mono truncate">${label}</div>
                            <div class="text-xs text-[--text-muted-dark] truncate">${p.project || 'No project'} • LLM: ${p.llm || 'N/A'}</div>
                        </div>
                    `;
                    // toggle checkbox on row click for bigger hit area
                    row.addEventListener('click', (e) => {
                        const target = e.target;
                        if (target && target.tagName && target.tagName.toLowerCase() === 'input') return;
                        const cb = row.querySelector('input[type="checkbox"]');
                        if (cb) cb.checked = !cb.checked;
                    });
                    list.appendChild(row);
                });
            };
            const openDependenciesDropdown = () => {
                renderDependenciesDropdown('');
                dependenciesSearch.value = '';
                // Show first to measure
                dependenciesDropdown.classList.remove('hidden');
                // Smart position within viewport
                try {
                    const bar = document.getElementById('dependency-bar');
                    const btn = document.getElementById('edit-dependencies-btn');
                    const dd = dependenciesDropdown;
                    if (bar && btn && dd) {
                        const barRect = bar.getBoundingClientRect();
                        const btnRect = btn.getBoundingClientRect();
                        const ddRect = dd.getBoundingClientRect();
                        const vw = window.innerWidth;
                        const vh = window.innerHeight;

                        // Default: align right edge to bar's right, place above (like a popover up)
                        let top = btnRect.top - barRect.top - ddRect.height - 8; // 8px gap
                        let left = barRect.width - ddRect.width - 8; // 8px from right edge

                        // Flip down if there's not enough space above
                        if (btnRect.top - ddRect.height - 8 < 0) {
                            top = btnRect.bottom - barRect.top + 8;
                        }

                        // Clamp horizontally within bar and viewport
                        left = Math.max(8, Math.min(left, barRect.width - ddRect.width - 8));

                        // Apply
                        dd.style.top = `${top}px`;
                        dd.style.left = `${left}px`;
                    }
                } catch {}
                dependenciesSearch.focus();
            };
            const closeDependenciesDropdown = () => {
                dependenciesDropdown.classList.add('hidden');
            };
            
            const renderDependencyBar = (deps) => {
                const depIds = Array.isArray(deps) ? deps : (deps ? [deps] : []);
                currentDependencies = depIds.map(String);
                const depPrompts = depIds.map(id => prompts.find(p => String(p.id) === String(id))).filter(Boolean);
                dependencyTagContainer.innerHTML = depPrompts.length
                    ? depPrompts.map(dp => `<span class="dependency-tag text-sm font-mono" data-dependency-id="${escapeAttr(String(dp.id))}">${S(dp.title)} (v${S(dp.version)})</span>`).join(' ')
                    : '<span class="text-xs text-[--text-muted-dark]">No dependencies</span>';
            };

            const renderVersionsList = () => {
                versionsHistoryList.innerHTML = '';
                const filterText = searchInput.value.toLowerCase().trim();
                
                const allGroupedPrompts = prompts.reduce((acc, p) => {
                    if (!acc[p.promptId]) {
                        acc[p.promptId] = { title: p.title, project: p.project, versions: [] };
                    }
                    acc[p.promptId].versions.push(p);
                    acc[p.promptId].title = p.title;
                    acc[p.promptId].project = p.project;
                    return acc;
                }, {});

                const filteredAndSortedGroups = Object.keys(allGroupedPrompts)
                    .map(promptId => {
                        const group = allGroupedPrompts[promptId];
                        // Filter versions within the group first
                        const matchingVersions = group.versions.filter(v => {
                            const matchesStatus = activeStatusFilter === 'all' || normalizeStatus(v.status) === normalizeStatus(activeStatusFilter);
                            const matchesProject = activeProjectFilter === 'all' || ((v.project || '').toLowerCase() === activeProjectFilter.toLowerCase());
                            if (!matchesStatus || !matchesProject) return false;

                            if (filterText === '') return true;

                            if (filterText.startsWith('#')) {
                                return v.tags && v.tags.some(tag => tag.toLowerCase().includes(filterText));
                            } else {
                                const matchesTitle = v.title.toLowerCase().includes(filterText);
                                const matchesProject = v.project && v.project.toLowerCase().includes(filterText);
                                const matchesTags = v.tags && v.tags.some(tag => tag.toLowerCase().includes(filterText));
                                return matchesTitle || matchesProject || matchesTags;
                            }
                        });

                        // If the group has matching versions, return it with only those versions
                        if (matchingVersions.length > 0) {
                            return {
                                promptId,
                                title: group.title,
                                project: group.project,
                                versions: matchingVersions.sort((a, b) => parseFloat(b.version) - parseFloat(a.version))
                            };
                        }
                        return null; // Otherwise, discard the group
                    })
                    .filter(Boolean); // Remove null groups


                if (filteredAndSortedGroups.length === 0) {
                    versionsHistoryList.innerHTML = `<p class="text-sm text-[--text-muted-dark] p-2">No results found.</p>`;
                    return;
                }

                const frag = document.createDocumentFragment();
                filteredAndSortedGroups.forEach(group => {
                    const isExpanded = expandedPromptGroups.has(group.promptId);
                    const groupContainer = document.createElement('div');
                    groupContainer.className = 'prompt-group group';
                    const header = document.createElement('div');
                    header.className = `prompt-group-header ${isExpanded ? 'expanded' : ''}`;
                    header.dataset.promptId = group.promptId;
                    header.innerHTML = `
                        <div class="flex items-center flex-grow truncate">
                            <svg class="toggle-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                            <div class="flex flex-col">
                                <span class="truncate font-sans font-medium text-xs">${S(group.title)}</span>
                                <span class="truncate font-sans text-[10px] text-[--text-muted-dark]">${S(group.project || 'No project')}</span>
                            </div>
                        </div>
                        <button data-action="delete-group" data-prompt-id="${escapeAttr(String(group.promptId))}" class="delete-group-btn invisible group-hover:visible p-1 rounded-md hover:bg-red-900/50 text-[--text-muted-dark] hover:text-red-400">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    `;
                    const subList = document.createElement('div');
                    subList.className = `version-sub-list ${isExpanded ? 'expanded' : ''}`;
                    if (isExpanded) {
                        const itemsFrag = document.createDocumentFragment();
                        group.versions.forEach(p => {
                            const item = document.createElement('div');
                            item.className = 'version-item font-mono text-xs';
                            // Make the whole row clickable for selection
                            item.setAttribute('data-action', 'select');
                            item.dataset.id = String(p.id);
                            item.innerHTML = `
                                <div class="flex items-center flex-grow" data-action="select" data-id="${escapeAttr(String(p.id))}">
                                    <input type="checkbox" class="pm-checkbox mr-3" aria-label="Select version ${S(p.version)}" data-id="${escapeAttr(String(p.id))}" data-prompt-id="${escapeAttr(String(p.promptId))}">
                                    <span class="truncate pr-1 text-gray-400">v</span>
                                    <span class="font-medium text-white">${S(p.version)}</span>
                                </div>
                                <span class="text-xs text-gray-500" data-action="select" data-id="${escapeAttr(String(p.id))}">${formatDate(p.date)}</span>
                            `;
                            if (String(p.id) === String(selectedVersionId)) item.classList.add('selected');
                            itemsFrag.appendChild(item);
                        });
                        subList.appendChild(itemsFrag);
                    }
                    groupContainer.appendChild(header);
                    groupContainer.appendChild(subList);
                    frag.appendChild(groupContainer);
                });
                versionsHistoryList.appendChild(frag);
            };

            const renderGallery = () => {
                galleryGrid.innerHTML = ''; // Clears previous content

                const groupedPrompts = prompts.reduce((acc, p) => {
                    if (!acc[p.promptId]) {
                        acc[p.promptId] = [];
                    }
                    acc[p.promptId].push(p);
                    return acc;
                }, {});

                const latestVersions = Object.values(groupedPrompts).map(versions => {
                    return versions.sort((a, b) => {
                        const [majorA, minorA = 0] = a.version.split('.').map(Number);
                        const [majorB, minorB = 0] = b.version.split('.').map(Number);
                        if (majorA !== majorB) return majorB - majorA;
                        return minorB - minorA;
                    })[0];
                });

                latestVersions.forEach(prompt => {
                    const versionCount = groupedPrompts[prompt.promptId].length;
                    const depCount = Array.isArray(prompt.dependencies) ? prompt.dependencies.length : (prompt.parent_id ? 1 : 0);
                    let dependencyTitle = 'N/A';
                    if (prompt.parent_id) {
                        const parentPrompt = prompts.find(p => p.id === prompt.parent_id);
                        if (parentPrompt) {
                            dependencyTitle = `${parentPrompt.title} (v${parentPrompt.version})`;
                        }
                    }

                    const card = document.createElement('div');
                    card.className = 'gallery-card standard-card bg-[--card-bg-dark] border border-[--border-dark] rounded-md p-3 flex flex-col text-xs text-[--text-dark]';
                    card.innerHTML = `
                        <div class="flex items-center gap-2 mb-1">
                            <h3 class="font-bold text-base truncate pr-2 flex-1 min-w-0" style="color: var(--accent-fuchsia);">${prompt.title}</h3>
                            <span class="text-xs font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5 shrink-0">${versionCount} ${versionCount > 1 ? 'versions' : 'version'}</span>
                        </div>
                        <div class="mb-1">
                            <span class="text-[10px] font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5">${depCount} ${depCount === 1 ? 'dependency' : 'dependencies'}</span>
                        </div>
                        <div class="space-y-1 flex-grow">
                            <p><strong class="text-[--text-muted-dark] font-normal">Project:</strong> ${prompt.project || 'N/A'}</p>
                            <p><strong class="text-[--text-muted-dark] font-normal">LLM:</strong> ${prompt.llm || 'N/A'}</p>
                            <p><strong class="text-[--text-muted-dark] font-normal">Repo:</strong> ${prompt.githubRepoFull || prompt.githubRepo || 'N/A'}</p>
                        </div>
                        <div class="mt-3 pt-2 border-t border-[--border-dark] grid grid-cols-3 gap-2 text-center font-mono">
                            <div>
                                <p class="text-[--text-muted-dark] text-xs">Temp</p>
                                <p class="font-semibold text-sm">${prompt.temperature}</p>
                            </div>
                            <div>
                                <p class="text-[--text-muted-dark] text-xs">Top P</p>
                                <p class="font-semibold text-sm">${prompt.topP}</p>
                            </div>
                            <div>
                                <p class="text-[--text-muted-dark] text-xs">Effort</p>
                                <p class="font-semibold text-sm">${prompt.effort}</p>
                            </div>
                        </div>
                    `;
                    card.addEventListener('click', () => {
                        loadVersionIntoEditor(prompt.id);
                        galleryModal.classList.add('hidden');
                    });
                    galleryGrid.appendChild(card);
                });
            };

            const renderProjectsView = () => {
                projectsListContainer.innerHTML = '';
                // Build repositories dropdown options from GitHub connections list
                let repoOptions = [];
                try {
                    const ghList = Array.isArray(window.__PM_GH_REPO_LIST) ? window.__PM_GH_REPO_LIST : [];
                    repoOptions = ghList.map(r => ({ id: r.id, label: r.repo || r.id }));
                } catch {}
                const groupedByProject = prompts.reduce((acc, p) => {
                    const project = p.project || 'No Project';
                    if (!acc[project]) {
                        acc[project] = [];
                    }
                    acc[project].push(p);
                    return acc;
                }, {});

                const allProjectSet = new Set([...Object.keys(groupedByProject), ...projectNames]);
                const allProjects = Array.from(allProjectSet).sort();

                allProjects.forEach(project => {
                    const projectWrapper = document.createElement('div');
                    projectWrapper.className = 'mb-6';
                    
                    const headerRow = document.createElement('div');
                    headerRow.className = 'flex items-center justify-between border-b border-[--border-dark] pb-2 mb-3';
                    const projectTitle = document.createElement('h3');
                    projectTitle.className = 'text-lg font-bold text-[--accent-fuchsia]';
                    projectTitle.textContent = project;
                    headerRow.appendChild(projectTitle);
                    // Repo selector on the right
                    const repoWrap = document.createElement('div');
                    repoWrap.className = 'flex items-center gap-2';
                    const repoLabel = document.createElement('label');
                    repoLabel.className = 'text-xs font-medium text-[--text-muted-dark]';
                    repoLabel.textContent = 'Repository:';
                    const repoSelect = document.createElement('select');
                    repoSelect.className = 'form-control rounded-md py-1 px-2 text-xs';
                    const emptyOpt = document.createElement('option');
                    emptyOpt.value = '';
                    emptyOpt.textContent = 'Unassigned';
                    repoSelect.appendChild(emptyOpt);
                    repoOptions.forEach(({ id, label }) => {
                        const opt = document.createElement('option');
                        opt.value = id;
                        opt.textContent = label;
                        repoSelect.appendChild(opt);
                    });
                    // Preselect saved mapping
                    const saved = projectRepoMap[project] || '';
                    repoSelect.value = saved;
                    repoSelect.addEventListener('change', async () => {
                        projectRepoMap[project] = repoSelect.value;
                        saveProjectRepoMapToStorage();
                        try { await updateGlobalList('project_repo_map', projectRepoMap); } catch {}
                    });
                    repoWrap.appendChild(repoLabel);
                    repoWrap.appendChild(repoSelect);
                    headerRow.appendChild(repoWrap);
                    projectWrapper.appendChild(headerRow);

                    const table = document.createElement('table');
                    table.className = 'w-full text-left text-xs table-fixed';
                    table.innerHTML = `
                        <thead>
                            <tr class="border-b border-[--border-dark]">
                                <th class="py-2 px-2 font-semibold w-[25%]">Prompt</th>
                                <th class="py-2 px-2 font-semibold text-center w-[8%]">Version</th>
                                <th class="py-2 px-2 font-semibold w-[22%]">Dependence</th>
                                <th class="py-2 px-2 font-semibold w-[15%]">Target</th>
                                <th class="py-2 px-2 font-semibold text-center w-[7%]">Temp</th>
                                <th class="py-2 px-2 font-semibold text-center w-[7%]">Top P</th>
                                <th class="py-2 px-2 font-semibold w-[10%]">Effort</th>
                                <th class="py-2 px-2 font-semibold text-center w-[6%]">Notes</th>
                            </tr>
                        </thead>
                    `;
                    const tbody = document.createElement('tbody');
                    const rows = (groupedByProject[project] || []).sort((a,b) => a.title.localeCompare(b.title) || parseFloat(b.version) - parseFloat(a.version));
                    rows.forEach(prompt => {
                        let dependencyTitle = 'N/A';
                        if (prompt.parent_id) {
                            const parentPrompt = prompts.find(p => p.id === prompt.parent_id);
                            if (parentPrompt) {
                                dependencyTitle = `${parentPrompt.title} (v${parentPrompt.version})`;
                            }
                        }

                        const row = document.createElement('tr');
                        row.className = 'hover:bg-[#333] cursor-pointer border-b border-[--border-dark]';
                        row.dataset.id = prompt.id;
                        row.innerHTML = `
                            <td class="py-2 px-2 truncate">${S(prompt.title)}</td>
                            <td class="py-2 px-2 text-center">${S(prompt.version)}</td>
                            <td class="py-2 px-2 truncate">${S(dependencyTitle)}</td>
                            <td class="py-2 px-2 truncate">${S(prompt.llm)}</td>
                            <td class="py-2 px-2 text-center">${S(prompt.temperature)}</td>
                            <td class="py-2 px-2 text-center">${S(prompt.topP)}</td>
                            <td class="py-2 px-2">${S(prompt.effort)}</td>
                        `;
                        
                        const commentsCell = document.createElement('td');
                        commentsCell.className = 'py-2 px-2 text-center';
                        if (prompt.comments && prompt.comments.trim() !== '') {
                            commentsCell.innerHTML = `
                                <button data-action="view-comments" data-id="${escapeAttr(String(prompt.id))}" class="p-1 rounded-md text-[--text-muted-dark] hover:text-white hover:bg-[#333]">
                                    <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12c0 4.556-4.03 8.25-9 8.25a9.764 9.764 0 01-2.555-.337A5.972 5.972 0 015.41 20.97a5.969 5.969 0 01-.474-.065 4.48 4.48 0 00.978-2.025c.09-.457-.133-.901-.467-1.226C3.93 16.178 3 14.189 3 12c0-4.556 4.03-8.25 9-8.25s9 3.694 9 8.25z" />
                                    </svg>
                                </button>
                            `;
                        }
                        row.appendChild(commentsCell);
                        tbody.appendChild(row);
                    });

                    table.appendChild(tbody);
                    projectWrapper.appendChild(table);
                    projectsListContainer.appendChild(projectWrapper);
                });
            };

            const renderTemplatesGrid = () => {
                const selectedProject = (typeof templatesProjectFilter !== 'undefined' && templatesProjectFilter) ? templatesProjectFilter.value : 'all';
                templatesGridContainer.innerHTML = '';
                const list = (selectedProject === 'all') ? templates : templates.filter(t => (t.project || '') === selectedProject);
                if (list.length === 0) {
                    templatesGridContainer.innerHTML = `<p class="text-sm text-[--text-muted-dark] col-span-full">No templates saved.</p>`;
                    return;
                }

                list.forEach(template => {
                    let dependencyTitle = 'N/A';
                    if (template.parent_id) {
                        const parentPrompt = prompts.find(p => p.id === template.parent_id);
                        if (parentPrompt) {
                            dependencyTitle = `${parentPrompt.title} (v${parentPrompt.version})`;
                        }
                    }
                    const depCount = Array.isArray(template.dependencies) ? template.dependencies.length : (template.parent_id ? 1 : 0);

                    const card = document.createElement('div');
                    card.className = 'gallery-card standard-card bg-[--card-bg-dark] border border-[--border-dark] rounded-md p-3 flex flex-col text-xs text-[--text-dark]';
                    card.dataset.id = template.id;

                    card.innerHTML = `
                        <div class="flex justify-between items-start mb-2">
                            <h3 class="font-bold text-base truncate pr-2" style="color: var(--accent-fuchsia);">${S(template.name)}</h3>
                            <span class="text-xs font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5">Template</span>
                        </div>
                        <div class="mb-1">
                            <span class="text-[10px] font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5">${depCount} ${depCount === 1 ? 'dependency' : 'dependencies'}</span>
                        </div>
                        <div class="space-y-1 flex-grow mb-3">
                            <p class="truncate"><strong class="text-[--text-muted-dark] font-normal">Based on:</strong> ${S(template.title || 'N/A')}</p>
                            <p><strong class="text-[--text-muted-dark] font-normal">Project:</strong> ${S(template.project || 'N/A')}</p>
                            <p><strong class="text-[--text-muted-dark] font-normal">LLM:</strong> ${S(template.llm || 'N/A')}</p>
                        </div>
                        <div class="mt-auto pt-2 border-t border-[--border-dark] grid grid-cols-3 gap-2 text-center font-mono">
                            <div>
                                <p class="text-[--text-muted-dark] text-xs">Temp</p>
                                <p class="font-semibold text-sm">${S(template.temperature)}</p>
                            </div>
                            <div>
                                <p class="text-[--text-muted-dark] text-xs">Top P</p>
                                <p class="font-semibold text-sm">${S(template.topP)}</p>
                            </div>
                             <div>
                                <p class="text-[--text-muted-dark] text-xs">Effort</p>
                                <p class="font-semibold text-sm">${S(template.effort)}</p>
                            </div>
                        </div>
                        <div class="mt-3 pt-3 border-t border-[--border-dark] flex gap-2">
                            <button data-action="load-template" class="action-button primary flex-grow text-center">Use</button>
                            <button data-action="delete-template" class="action-button text-red-500 hover:bg-red-900/20 hover:border-red-800">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                            </button>
                        </div>
                    `;
                    templatesGridContainer.appendChild(card);
                });
            };
            
            const updateStatusSelectorUI = (status) => {
                document.querySelectorAll('.status-option').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.status === status) btn.classList.add('active');
                });
            };

            const updateStatusFilterUI = () => {
                const sel = document.getElementById('status-filter-select');
                if (sel) sel.value = activeStatusFilter;
            };

            const updateProjectFilterUI = () => {
                const sel = document.getElementById('project-filter-select');
                if (sel) sel.value = activeProjectFilter;
            };

            const populateProjectFilter = () => {
                const sel = document.getElementById('project-filter-select');
                if (!sel) return;
                const set = new Set();
                set.add('all');
                try {
                    (prompts || []).forEach(p => { if (p.project && String(p.project).trim()) set.add(String(p.project).trim()); });
                    (projectNames || []).forEach(n => { if (n && String(n).trim()) set.add(String(n).trim()); });
                } catch {}
                const values = Array.from(set).sort((a,b) => (a==='all')?-1:(b==='all')?1:a.localeCompare(b));
                sel.innerHTML = '';
                values.forEach(v => {
                    const opt = document.createElement('option');
                    opt.value = v;
                    opt.textContent = v === 'all' ? 'All' : v;
                    sel.appendChild(opt);
                });
                sel.value = activeProjectFilter;
            };

            const updateEditorStats = () => {
                const content = mainEditor.value;
                const charCount = content.length;
                const wordCount = content.trim().split(/\s+/).filter(Boolean).length;
                const tokenCount = Math.ceil(charCount / 4);
                editorStats.textContent = `${tokenCount} tokens / ${wordCount} words / ${charCount} characters`;
            };

            // ===== Dashboard helpers =====
            const getISOWeek = (date) => {
                const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
                const dayNum = d.getUTCDay() || 7;
                d.setUTCDate(d.getUTCDate() + 4 - dayNum);
                const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
                const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1)/7);
                return { year: d.getUTCFullYear(), week: weekNo };
            };

            const groupByPeriod = (items, period) => {
                const map = new Map();
                const add = (key, t, w, c, d) => {
                    const cur = map.get(key) || { tokens: 0, words: 0, chars: 0, count: 0, sort: d.getTime() };
                    cur.tokens += t; cur.words += w; cur.chars += c; cur.count += 1; cur.sort = Math.max(cur.sort, d.getTime());
                    map.set(key, cur);
                };
                items.forEach(p => {
                    const content = p.content || '';
                    const chars = content.length || 0;
                    const words = (content.trim().match(/\S+/g) || []).length;
                    const tokens = Math.ceil(chars / 4);
                    const d = p.date ? new Date(p.date) : new Date();
                    let key;
                    if (period === 'day') {
                        key = d.toISOString().slice(0,10);
                    } else if (period === 'week') {
                        const { year, week } = getISOWeek(d);
                        key = `${year}-W${String(week).padStart(2,'0')}`;
                    } else {
                        key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
                    }
                    add(key, tokens, words, chars, d);
                });
                const labels = Array.from(map.keys()).sort((a,b) => (map.get(a).sort || 0) - (map.get(b).sort || 0));
                const data = labels.map(l => map.get(l));
                return { labels, data };
            };

            const getCounts = (arr, mapper) => {
                const map = new Map();
                arr.forEach(x => {
                    const key = mapper(x) || 'N/A';
                    map.set(key, (map.get(key)||0)+1);
                });
                const labels = Array.from(map.keys());
                const data = labels.map(l => map.get(l));
                return { labels, data };
            };

            const getTopTags = (arr, topN = 10) => {
                const map = new Map();
                arr.forEach(p => {
                    (p.tags || []).forEach(tag => {
                        map.set(tag, (map.get(tag)||0)+1);
                    });
                });
                const entries = Array.from(map.entries()).sort((a,b) => b[1]-a[1]).slice(0, topN);
                return { labels: entries.map(e=>e[0]), data: entries.map(e=>e[1]) };
            };

            const destroyIf = (chart) => { if (chart && typeof chart.destroy === 'function') chart.destroy(); };
            const getChartColors = () => {
                const isLight = document.documentElement.getAttribute('data-theme') === 'light';
                const text = getComputedStyle(document.documentElement).getPropertyValue('--text-dark')?.trim() || (isLight ? '#1F2937' : '#e5e7eb');
                return {
                    line1: 'rgba(236, 72, 153, 1)',
                    line2: 'rgba(59, 130, 246, 1)',
                    line3: 'rgba(16, 185, 129, 1)',
                    bar: 'rgba(234, 179, 8, 0.9)',
                    dough: ['#60A5FA','#F472B6','#34D399','#F59E0B','#A78BFA','#F43F5E','#10B981','#8B5CF6','#22D3EE','#EAB308'],
                    grid: isLight ? 'rgba(0,0,0,0.08)' : 'rgba(148,163,184,0.2)',
                    text,
                    tooltipBg: isLight ? 'rgba(0,0,0,0.75)' : 'rgba(15,15,15,0.9)',
                    tooltipColor: '#FFFFFF'
                };
            };

            const renderDashboardCharts = (period = 'month') => {
                if (typeof Chart === 'undefined') {
                    showModal('Unavailable', 'Dashboard requires Chart.js which is not loaded (offline).', [
                        { text: 'OK', className: 'action-button primary', onClick: hideModal }
                    ]);
                    return;
                }
                const ctxTokens = document.getElementById('tokensChart').getContext('2d');
                const ctxPrompts = document.getElementById('promptsChart').getContext('2d');
                const ctxModels  = document.getElementById('modelsChart').getContext('2d');
                const ctxProjects= document.getElementById('projectsChart').getContext('2d');
                const ctxStatus  = document.getElementById('statusChart').getContext('2d');
                const ctxTags    = document.getElementById('tagsChart').getContext('2d');

                const grouped = groupByPeriod(prompts, period);
                const labels = grouped.labels;
                const tokens = grouped.data.map(d => d.tokens);
                const words  = grouped.data.map(d => d.words);
                const chars  = grouped.data.map(d => d.chars);
                const counts = grouped.data.map(d => d.count);

                const chartColors = getChartColors();

                destroyIf(tokensChart); destroyIf(promptsChart); destroyIf(modelsChart); destroyIf(projectsChart); destroyIf(statusChart); destroyIf(tagsChart);

                tokensChart = new Chart(ctxTokens, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            { label: 'Tokens', data: tokens, borderColor: chartColors.line1, backgroundColor: chartColors.line1, fill: false, tension: 0.2 },
                            { label: 'Words',  data: words,  borderColor: chartColors.line2, backgroundColor: chartColors.line2, fill: false, tension: 0.2 },
                            { label: 'Chars',  data: chars,  borderColor: chartColors.line3, backgroundColor: chartColors.line3, fill: false, tension: 0.2 }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: { padding: { top: 2, right: 2, bottom: 2, left: 2 } },
                        plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } },
                        elements: { point: { radius: 0, hitRadius: 2 }, line: { borderWidth: 1 } },
                        scales: {
                            x: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } },
                            y: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } }
                        }
                    }
                });

                promptsChart = new Chart(ctxPrompts, {
                    type: 'bar',
                    data: { labels, datasets: [{ label: 'Versions', data: counts, backgroundColor: chartColors.bar, barPercentage: 0.9, categoryPercentage: 0.9 }] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: { padding: { top: 2, right: 2, bottom: 2, left: 2 } },
                        plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } },
                        scales: {
                            x: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } },
                            y: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } }
                        }
                    }
                });

                const models = getCounts(prompts, p => p.llm || '');
                modelsChart = new Chart(ctxModels, {
                    type: 'doughnut', data: { labels: models.labels, datasets: [{ data: models.data, backgroundColor: chartColors.dough }] },
                    options: { responsive: true, maintainAspectRatio: false, cutout: '60%', plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } } }
                });

                const projects = getCounts(prompts, p => p.project || 'No Project');
                projectsChart = new Chart(ctxProjects, {
                    type: 'bar', data: { labels: projects.labels, datasets: [{ label: 'Prompts', data: projects.data, backgroundColor: chartColors.line2, barPercentage: 0.9, categoryPercentage: 0.9 }] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        layout: { padding: { top: 2, right: 2, bottom: 2, left: 2 } },
                        plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } },
                        scales: {
                            x: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } },
                            y: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } }
                        }
                    }
                });

                const status = getCounts(prompts, p => normalizeStatus(p.status) || 'unknown');
                statusChart = new Chart(ctxStatus, {
                    type: 'doughnut', data: { labels: status.labels, datasets: [{ data: status.data, backgroundColor: chartColors.dough }] },
                    options: { responsive: true, maintainAspectRatio: false, cutout: '60%', plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } } }
                });

                const topTags = getTopTags(prompts, 10);
                tagsChart = new Chart(ctxTags, {
                    type: 'bar', data: { labels: topTags.labels, datasets: [{ label: 'Usage', data: topTags.data, backgroundColor: chartColors.line3, barPercentage: 0.9, categoryPercentage: 0.9 }] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        layout: { padding: { top: 2, right: 2, bottom: 2, left: 2 } },
                        plugins: { legend: { labels: { color: chartColors.text, boxWidth: 10, font: { size: 10 } } }, tooltip: { backgroundColor: chartColors.tooltipBg, titleColor: chartColors.tooltipColor, bodyColor: chartColors.tooltipColor } },
                        scales: {
                            x: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } },
                            y: { ticks: { color: chartColors.text, autoSkip: true, maxTicksLimit: 4, font: { size: 9 } }, grid: { color: chartColors.grid, lineWidth: 0.5 } }
                        }
                    }
                });
            };

            // ===== Dashboard events =====
            if (dashboardBtn && dashboardModal) {
                dashboardBtn.addEventListener('click', () => {
                    dashboardModal.classList.remove('hidden');
                    const sel = document.getElementById('dashboard-period-select');
                    const period = sel ? sel.value : 'month';
                    renderDashboardCharts(period);
                });
                const closeBtn = document.getElementById('close-dashboard-btn');
                closeBtn && closeBtn.addEventListener('click', () => {
                    dashboardModal.classList.add('hidden');
                });
                dashboardModal.addEventListener('click', (e) => {
                    if (e.target === dashboardModal) dashboardModal.classList.add('hidden');
                });
                const sel = document.getElementById('dashboard-period-select');
                sel && sel.addEventListener('change', (e) => {
                    renderDashboardCharts(e.target.value);
                });
            }

            // ===== API Console =====
            // ===== Kanban =====
            const kanbanBtn = document.getElementById('kanban-btn');
            const kanbanModal = document.getElementById('kanban-modal');
            const closeKanbanBtn = document.getElementById('close-kanban-modal');
            const kanbanBoard = document.getElementById('kanban-board');
            const kanbanScopeSelect = document.getElementById('kanban-scope-select');
            const kanbanEntitySelect = document.getElementById('kanban-entity-select');

            const getKanbanEntities = (scope) => {
                if (scope === 'project') {
                    // Use union of known projectNames (global list) and projects present in prompts
                    const fromPrompts = prompts.map(p => p.project).filter(Boolean);
                    const fromGlobals = Array.isArray(projectNames) ? projectNames.filter(Boolean) : [];
                    return Array.from(new Set([...fromGlobals, ...fromPrompts])).sort();
                }
                // prompt scope: list prompt groups by title
                const groups = prompts.reduce((acc,p)=>{ (acc[p.promptId] ||= []).push(p); return acc; },{});
                const entries = Object.entries(groups).map(([id, vers]) => ({ id, title: vers[0]?.title || id }));
                // sort by title
                return entries.sort((a,b)=>a.title.localeCompare(b.title));
            };

            const buildKanbanColumns = () => {
                kanbanBoard.innerHTML = '';
                STATUS_ORDER.forEach(st => {
                    const col = document.createElement('div');
                    col.className = 'panel-soft rounded-md border border-[--border-dark] flex flex-col min-h-0';
                    col.dataset.status = st;
                    const header = document.createElement('div');
                    header.className = 'px-3 py-2 border-b border-[--border-dark] text-xs font-semibold uppercase tracking-wide text-[--text-muted-dark]';
                    header.textContent = st;
                    const list = document.createElement('div');
                    list.className = 'flex-1 overflow-auto p-2 space-y-2';
                    list.dataset.dropzone = st;
                    col.appendChild(header);
                    col.appendChild(list);
                    kanbanBoard.appendChild(col);
                });
            };

            const kanbanCard = (p) => {
                const card = document.createElement('div');
                card.className = 'rounded-md border border-[--border-dark] bg-[--card-bg-dark] p-2 text-xs cursor-move';
                card.draggable = true;
                card.dataset.id = p.id;
                card.innerHTML = `<div class="font-semibold">${S(p.title)}</div><div class="opacity-70">v${S(p.version)} · ${S(p.project||'No project')}</div>`;
                card.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', String(p.id));
                });
                return card;
            };

            const renderKanban = () => {
                buildKanbanColumns();
                const scope = kanbanScopeSelect.value;
                let entity = kanbanEntitySelect.value;
                let items = prompts.slice();
                if (scope === 'project') {
                    if (!entity) return; // wait for selection
                    items = items.filter(p => p.project === entity);
                } else {
                    if (!entity) return; // wait for selection
                    items = items.filter(p => String(p.promptId) === String(entity));
                }
                // place cards
                const byStatus = new Map();
                items.forEach(p => {
                    const st = normalizeStatus(p.status);
                    const arr = byStatus.get(st) || [];
                    arr.push(p);
                    byStatus.set(st, arr);
                });
                STATUS_ORDER.forEach(st => {
                    const list = kanbanBoard.querySelector(`[data-dropzone="${st}"]`);
                    const arr = byStatus.get(st) || [];
                    list.innerHTML = '';
                    arr.sort((a,b)=> (a.title||'').localeCompare(b.title||''));
                    arr.forEach(p => list.appendChild(kanbanCard(p)));
                });
            };

            const wireKanbanDnD = () => {
                kanbanBoard.addEventListener('dragover', (e) => {
                    const zone = e.target.closest('[data-dropzone]');
                    if (zone) {
                        e.preventDefault();
                    }
                });
                kanbanBoard.addEventListener('drop', async (e) => {
                    const zone = e.target.closest('[data-dropzone]');
                    if (!zone) return;
                    e.preventDefault();
                    const id = e.dataTransfer.getData('text/plain');
                    const targetStatus = normalizeStatus(zone.dataset.dropzone);
                    const item = prompts.find(p => String(p.id) === String(id));
                    if (!item) return;
                    if (normalizeStatus(item.status) === targetStatus) return;
                    item.status = targetStatus;
                    // persist
                    try { await upsertItem('prompts', mapPromptUIToDb(item)); } catch {}
                    renderKanban();
                    // refresh versions list and charts
                    renderVersionsList();
                });
            };

            const openKanban = () => {
                if (!kanbanModal) return;
                kanbanModal.classList.remove('hidden');
                // populate selects
                const scope = kanbanScopeSelect.value || 'project';
                const entities = getKanbanEntities(scope);
                kanbanEntitySelect.innerHTML = '';
                if (scope === 'project') {
                    if (entities.length === 0) {
                        const opt = document.createElement('option');
                        opt.value = '';
                        opt.textContent = 'No projects';
                        opt.disabled = true;
                        opt.selected = true;
                        kanbanEntitySelect.appendChild(opt);
                    } else {
                        entities.forEach(name => {
                            const opt = document.createElement('option');
                            opt.value = name; opt.textContent = name; kanbanEntitySelect.appendChild(opt);
                        });
                        // Ensure a selection exists
                        kanbanEntitySelect.value = entities[0];
                    }
                } else {
                    if (entities.length === 0) {
                        const opt = document.createElement('option');
                        opt.value = '';
                        opt.textContent = 'No prompts';
                        opt.disabled = true;
                        opt.selected = true;
                        kanbanEntitySelect.appendChild(opt);
                    } else {
                        entities.forEach(({id, title}) => {
                            const opt = document.createElement('option');
                            opt.value = id; opt.textContent = title; kanbanEntitySelect.appendChild(opt);
                        });
                        kanbanEntitySelect.value = entities[0].id;
                    }
                }
                renderKanban();
            };

            kanbanBtn && kanbanBtn.addEventListener('click', () => {
                // close List Manager if open (reuse modal policy)
                const listManager = document.getElementById('list-manager-modal');
                if (listManager) listManager.classList.add('hidden');
                openKanban();
                wireKanbanDnD();
            });
            closeKanbanBtn && closeKanbanBtn.addEventListener('click', () => kanbanModal.classList.add('hidden'));
            kanbanModal && kanbanModal.addEventListener('click', (e) => { if (e.target === kanbanModal) kanbanModal.classList.add('hidden'); });
            kanbanScopeSelect && kanbanScopeSelect.addEventListener('change', () => openKanban());
            kanbanEntitySelect && kanbanEntitySelect.addEventListener('change', () => renderKanban());

            const apiConsoleBtn = document.getElementById('api-console-btn');
            const apiConsoleModal = document.getElementById('api-console-modal');
            const closeApiConsoleBtn = document.getElementById('close-api-console-btn');
            const initSqlTextarea = document.getElementById('init-sql-textarea');
            const supabaseUrlInput = document.getElementById('supabase-url-input');
            const supabaseKeyInput = document.getElementById('supabase-key-input');
            const supabaseIntegrateBtn = document.getElementById('supabase-integrate-btn');
            const supabaseIntegrateStatus = document.getElementById('supabase-integrate-status');
            const llmApiServerSelect = document.getElementById('llm-api-server-select');
            const llmApiKeyInput = document.getElementById('llm-api-key-input');
            const llmTestBtn = null; // removed
            const llmTestStatus = null; // removed
            const llmCurlInput = document.getElementById('llm-curl-input');
            const llmCurlStatus = null;
            const githubTokenInput = document.getElementById('github-token-input');
            const githubRepoInput = document.getElementById('github-repo-input');
            const githubTestBtn = document.getElementById('github-test-btn');
            const githubTestStatus = document.getElementById('github-test-status');
            // LLM store-on-server is mandatory; checkbox removed
            // GitHub store-on-server is mandatory; checkbox removed
            const apiTabBtns = document.querySelectorAll('.api-tab-btn');
            const llmApiListEl = document.getElementById('llm-api-list');
            const llmAddApiBtn = document.getElementById('llm-add-api-btn');
            const llmAddStatus = document.getElementById('llm-add-status');
            const ghRepoListEl = document.getElementById('github-repo-list');
            const ghAddRepoBtn = document.getElementById('github-add-repo-btn');
            // Proxy is always ON; remove UI toggle
            // removed copy buttons for function code templates
            const llmLoadModelsBtn = null; // global removed
            const llmRebuildListBtn = null; // removed
            const llmAvailableModelsEl = document.getElementById('llm-available-models');
            const ghLoadReposBtn = document.getElementById('github-load-repos-btn');
            const ghAvailableReposEl = document.getElementById('github-available-repos');
            const ghReposToggle = document.getElementById('github-repos-toggle');
            const ghReposCaret = document.getElementById('github-repos-caret');
            // Dock GitHub toggle elements
            const dockGhLoadReposBtn = document.getElementById('dock-github-load-repos-btn');
            const dockGhAvailableReposEl = document.getElementById('dock-github-available-repos');
            const dockGhReposToggle = document.getElementById('dock-github-repos-toggle');
            const dockGhReposCaret = document.getElementById('dock-github-repos-caret');
            const ghRepoFoldersToggle = document.getElementById('github-repo-folders-toggle');
            const ghRepoFoldersCaret = document.getElementById('github-repo-folders-caret');
            const ghLoadFoldersBtn = document.getElementById('github-load-folders-btn');
            const ghRepoFoldersEl = document.getElementById('github-repo-folders');
            // API STATUS elements
            const apiStatusPill = document.getElementById('api-status-pill');
            const apiStatusModal = document.getElementById('api-status-modal');
            const closeApiStatusModalBtn = document.getElementById('close-api-status-modal');
            const apiStatusSummary = document.getElementById('api-status-summary');
            const apiStatusErrors = document.getElementById('api-status-errors');
            const apiListOnline = document.getElementById('api-list-online');
            const apiListOffline = document.getElementById('api-list-offline');
            const verifyFunctionsBtn = document.getElementById('verify-functions-btn');
            const verifyOpenaiStatus = document.getElementById('verify-openai-status');
            const verifyAllBtn = document.getElementById('llm-verify-all-btn');
            const verifyOut = document.getElementById('llm-verify-output');
            const verifyProgress = document.getElementById('llm-verify-progress');
            const verifyGithubStatus = document.getElementById('verify-github-status');

                        // SQL console and templates removed from UI

            const API_KEYS = {
                supabase_url: 'supabase_url',
                supabase_key: 'supabase_anon_key',
        // legacy local secret keys removed; secrets must be stored server-side only
        llm_base: 'llm_api_base', // kept only to aid curl parsing UI, not persisted
        llm_key: 'llm_api_key',   // kept only to aid curl parsing UI, not persisted
        gh_token: 'github_token', // kept only for UI input convenience, not persisted
        gh_repo: 'github_repo',
        llm_multi: 'llm_api_list',    // array of { id, base, label, server: true }
        gh_multi: 'github_repo_list', // array of { id, repo, server: true }
                llm_active: 'llm_api_active_id',
                                gh_active: 'github_repo_active_id',
                                use_proxy: 'use_proxy_mode'
            };

            // Built-in providers library (seeded with Anthropic). These appear in LLM SERVER dropdown alongside saved servers.
            const LLM_STATIC_LIBRARY = [
                {
                    id: 'openai',
                    label: 'OpenAI',
                    base: 'https://api.openai.com/v1',
                    models: [
                        'o1',
                        'o3',
                        'o3-mini',
                        'o4-mini',
                        'gpt-4o',
                        'gpt-4o-mini',
                        'gpt-4.1',
                        'gpt-4.1-mini',
                        'gpt-4.1-nano',
                        'gpt-5',
                        'gpt-5-mini',
                        'gpt-5-nano',
                        'gpt-5-chat'
                    ]
                },
                {
                    id: 'anthropic',
                    label: 'Anthropic',
                    base: 'https://api.anthropic.com/v1',
                    versionHeader: { 'anthropic-version': '2023-06-01' },
                    models: [
                        'claude-opus-4-1-20250805',
                        'claude-opus-4-20250514',
                        'claude-sonnet-4-20250514',
                        'claude-3-7-sonnet-20250219',
                        'claude-3-5-sonnet-20240620',
                        'claude-3-haiku-20240307',
                        'claude-3-opus-20240229',
                        'claude-3-sonnet-20240229',
                        'claude-2',
                        'claude-2.1',
                        'claude-instant-1.2'
                    ]
                },
                {
                    id: 'cohere',
                    label: 'Cohere',
                    base: 'https://api.cohere.ai/v1',
                    models: [
                        'command-a-03-2025',
                        'command-r-plus-08-2024',
                        'embed-english-v3.0',
                        'embed-multilingual-v3.0',
                        'rerank-english-v1.0'
                    ]
                },
                {
                    id: 'google',
                    label: 'Google Gemini',
                    base: 'https://generativelanguage.googleapis.com/v1beta',
                    models: [
                        'gemini-2.5-pro',
                        'gemini-2.5-flash',
                        'gemini-2.5-flash-lite',
                        'gemini-2.0-flash',
                        'gemini-2.0-flash-lite',
                        'gemini-1.5-pro-latest',
                        'gemini-1.5-flash-latest',
                        'gemma-3',
                        'embedding-002',
                        'aqa-model'
                    ]
                },
                {
                    id: 'mistral',
                    label: 'Mistral AI',
                    base: 'https://api.mistral.ai/v1',
                    models: [
                        'mistral-medium-2508',
                        'mistral-medium-latest',
                        'magistral-medium-2507',
                        'codestral-2508',
                        'devstral-medium-2507',
                        'ministral-8b-2410',
                        'mistral-large-2411',
                        'pixtral-large-2411',
                        'mistral-small-2407'
                    ]
                },
                {
                    id: 'deepseek',
                    label: 'Deepseek',
                    base: 'https://api.deepseek.com/v1',
                    models: [
                        'deepseek-chat',
                        'deepseek-reasoner'
                    ]
                },
                {
                    id: 'perplexity',
                    label: 'Perplexity',
                    base: 'https://api.perplexity.ai',
                    models: [
                        'sonar',
                        'sonar-small-online',
                        'sonar-medium-online',
                        'sonar-small-chat',
                        'sonar-medium-chat',
                        'sonar-pro',
                        'sonar-reasoning',
                        'sonar-experimental'
                    ]
                }
            ];

    // Remove legacy migration that stored secrets locally. Connections must be created via server only.
    function migrateSingleLlmToMulti() { return; }

            const loadApiSettings = () => {
                try {
            // Proxy toggle removed; proxy is always enabled
            // Enforce server storage for LLM (no UI toggle)
            // Enforce server storage for GitHub (no UI toggle)
                    // Do not auto-fill secrets from localStorage anymore; keep inputs empty by default
                    if (llmApiServerSelect) { try { populateServerSelectOptions(); } catch {} }
                    
                    if (llmApiKeyInput) llmApiKeyInput.value = '';
                    if (githubTokenInput) githubTokenInput.value = '';
                    if (githubRepoInput) githubRepoInput.value = window.__PM_GH_REPO || '';
                    // Ensure legacy single LLM is visible in the multi list
                    migrateSingleLlmToMulti();
                    renderLlmApiList();
                    renderGithubRepoList();
                    // Prune orphaned LLM groups so Target LLM mirrors API Console
                    syncLlmListWithConnections();
                } catch (e) { console.warn('Failed to load API settings', e); }
            };

    // Proxy-only mode: always true
    const useProxyEnabled = () => true;

            // Populate LLM SERVER dropdown with stored server connections
            function populateServerSelectOptions() {
                if (!llmApiServerSelect) return;
                const conns = (typeof getLlmConnections === 'function') ? getLlmConnections().filter(c => c && c.server) : [];
                const activeId = window.__PM_LLM_ACTIVE;
                llmApiServerSelect.innerHTML = '';
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = (LLM_STATIC_LIBRARY.length || conns.length) ? 'Choose a server…' : 'No servers yet';
                llmApiServerSelect.appendChild(placeholder);
                // Add built-in providers first
                (LLM_STATIC_LIBRARY || []).forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = `lib:${p.id}`;
                    opt.textContent = `${p.label}`;
                    llmApiServerSelect.appendChild(opt);
                });
                conns.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = c.label || (c.base ? (()=>{ try { return new URL(c.base).hostname; } catch { return 'LLM'; } })() : 'LLM');
                    if (c.id === activeId) opt.selected = true;
                    llmApiServerSelect.appendChild(opt);
                });
            }
            
            function getSelectedServerBase() {
                try {
                    if (!llmApiServerSelect || !llmApiServerSelect.value) return '';
                    const id = llmApiServerSelect.value;
                    if (id.startsWith('lib:')) {
                        const lib = (LLM_STATIC_LIBRARY || []).find(p => `lib:${p.id}` === id);
                        return lib?.base || '';
                    }
                    const conns = (typeof getLlmConnections === 'function') ? getLlmConnections() : [];
                    const found = conns.find(c => c.id === id);
                    return found?.base || '';
                } catch { return ''; }
            }

            async function verifyFunctions() {
                if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return { openai: false, github: false };
                const base = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                const headers = await buildFnHeaders();
                const tryProbe = async (path, body) => {
                    try {
                        const r = await fetch(base + path, { method: 'POST', headers, body: JSON.stringify(body) });
                        return r.status !== 404;
                    } catch { return false; }
                };
                const openai = await tryProbe('/proxy-ai-api', { path: 'models', method: 'GET', config_id: '00000000-0000-0000-0000-000000000000' })
                             || await tryProbe('/proxy-llm', { path: 'models', method: 'GET', conn_id: '00000000-0000-0000-0000-000000000000' });
                const github = await tryProbe('/proxy-github-conn', { path: 'user', method: 'GET', conn_id: '00000000-0000-0000-0000-000000000000' });
                return { openai, github };
            }
            // Note: connections-manager POST expects { type: 'llm'|'github', label, base_url, api_key } and sets user_id via JWT
            //       connections-manager DELETE expects ?id=uuid and validates ownership via JWT+RLS
            //       proxy-llm expects { conn_id, path, method, body }, resolves credentials from api_connections, decrypts, and proxies

            const saveIfPresent = (el, key) => {
                // Never persist LLM/GitHub secrets to localStorage anymore
                const forbidden = new Set([API_KEYS.llm_key, API_KEYS.llm_base, API_KEYS.gh_token]);
                if (!el || !el.value || forbidden.has(key)) return;
                window[key === API_KEYS.llm_base ? '__PM_LLM_BASE' : '__PM_GH_REPO'] = el.value;
            };
            // ===== Active connection helpers (global) =====
            function getActiveLlmConn() {
                const list = Array.isArray(window.__PM_LLM_MULTI) ? window.__PM_LLM_MULTI : [];
                const activeId = window.__PM_LLM_ACTIVE;
                return list.find(i => i.id === activeId) || null;
            }
            // Pending server-stored LLM connection created during Test, before user clicks Add
            let PENDING_LLM_CONN = null; // { id, base, label, server: true }
        // Cache detected function variants
    let FN_VARIANTS = { aiProxy: null, saveConfig: null, listConfig: null, deleteConfig: null, connLlm: null, connGh: null, ghProxy: null };
        async function detectFnVariants() {
            if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return FN_VARIANTS;
            if (FN_VARIANTS.aiProxy) return FN_VARIANTS;
            const base = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
            const headers = await buildFnHeaders();
            try {
                const r = await fetch(base + '/proxy-ai-api', { method: 'POST', headers, body: JSON.stringify({ path: 'models', method: 'GET', config_id: '00000000-0000-0000-0000-000000000000' }) });
                if (r.status !== 404) FN_VARIANTS.aiProxy = 'new';
            } catch {}
            try {
                if (!FN_VARIANTS.aiProxy) {
                    const r = await fetch(base + '/proxy-llm', { method: 'POST', headers, body: JSON.stringify({ path: 'models', method: 'GET', conn_id: '00000000-0000-0000-0000-000000000000' }) });
                    if (r.status !== 404) FN_VARIANTS.aiProxy = 'old';
                }
            } catch {}
            try {
                const r = await fetch(base + '/save-ai-api-config', { method: 'POST', headers, body: JSON.stringify({ name: 'probe', provider: 'openai', base_url: 'https://api.openai.com/v1', api_key: 'x' }) });
                if (r.status !== 404) FN_VARIANTS.saveConfig = 'new';
            } catch {}
            try {
                const r = await fetch(base + '/list-ai-api-configs', { method: 'GET', headers });
                if (r.status !== 404) FN_VARIANTS.listConfig = 'new';
            } catch {}
            try {
                const r = await fetch(base + '/delete-ai-api-config?id=00000000-0000-0000-0000-000000000000', { method: 'DELETE', headers });
                if (r.status !== 404) FN_VARIANTS.deleteConfig = 'new';
            } catch {}
            try {
                const r = await fetch(base + '/connections-llm', { method: 'POST', headers, body: JSON.stringify({ base_url: 'x', api_key: 'x' }) });
                if (r.status !== 404) FN_VARIANTS.connLlm = 'present';
            } catch {}
            try {
                const r = await fetch(base + '/connections-github', { method: 'POST', headers, body: JSON.stringify({ repo: 'x/y', token: 'z' }) });
                if (r.status !== 404) FN_VARIANTS.connGh = 'present';
            } catch {}
            try {
                const r = await fetch(base + '/proxy-github-conn', { method: 'POST', headers, body: JSON.stringify({ path: 'user', method: 'GET', conn_id: '00000000-0000-0000-0000-000000000000' }) });
                if (r.status !== 404) FN_VARIANTS.ghProxy = 'conn';
            } catch {}
            if (!FN_VARIANTS.saveConfig) FN_VARIANTS.saveConfig = 'old';
            return FN_VARIANTS;
        }

        async function buildFnHeaders() {
            const base = { 'Content-Type': 'application/json', 'apikey': FINAL_SUPABASE_KEY };
            try {
                if (supabaseClient && supabaseClient.auth) {
                    const { data } = await supabaseClient.auth.getSession();
                    const token = data?.session?.access_token;
                    if (token) return { ...base, 'Authorization': `Bearer ${token}` };
                }
            } catch {}
            // fallback to anon key (may not authorize user-only functions)
            return { ...base, 'Authorization': `Bearer ${FINAL_SUPABASE_KEY}` };
        }

        // ===== API STATUS helpers =====
        async function listServerApis() {
            const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
            const headers = await buildFnHeaders();
            await detectFnVariants();
            try {
                if (FN_VARIANTS.listConfig === 'new') {
                    const res = await fetch(baseFn + '/list-ai-api-configs', { method: 'GET', headers });
                    if (res.ok) {
                        const json = await res.json();
                        return (Array.isArray(json) ? json : []).map(x => ({ id: x.id, label: x.name || x.provider || 'API', base: x.base_url || '', provider: x.provider || 'openai', type: 'llm' }));
                    }
                }
            } catch {}
            try {
                const conns = (typeof getLlmConnections === 'function') ? getLlmConnections() : [];
                return conns.filter(c => c && c.server).map(c => ({ id: c.id, label: c.label || 'LLM', base: c.base || '', provider: (typeof detectProvider === 'function' ? detectProvider(c.base || '') : 'openai'), type: 'llm' }));
            } catch { return []; }
        }

        async function probeApi(conn) {
            try {
                const base = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                const headers = await buildFnHeaders();
                const body = { conn_id: conn.id, path: 'models', method: 'GET' };
                const res = await fetch(base + '/proxy-llm', { method: 'POST', headers, body: JSON.stringify(body) });
                if (!res.ok) throw new Error('HTTP ' + res.status);
                return { ok: true };
            } catch (e) { return { ok: false, error: e?.message || String(e) }; }
        }

        async function refreshApiStatus() {
            try {
                if (apiStatusPill) { apiStatusPill.textContent = 'API STATUS'; apiStatusPill.style.color = ''; }
                const conns = await listServerApis();
                const results = await Promise.all(conns.map(async c => ({ c, r: await probeApi(c) })));
                const online = results.filter(x => x.r.ok).map(x => x.c);
                const offline = results.filter(x => !x.r.ok).map(x => ({ ...x.c, error: x.r.error }));
                const total = conns.length;
                const on = online.length;
                const off = offline.length;
                if (apiStatusPill) {
                    const isLight = document.documentElement.getAttribute('data-theme') === 'light';
                    const onColor = isLight ? 'var(--accent-fuchsia)' : 'var(--accent-mint)';
                    const offColor = 'var(--accent-red)';
                    apiStatusPill.innerHTML = `API STATUS: ${on}/${total} [<span style="color: ${onColor}">${on}</span>/<span style="color: ${offColor}">${off}</span>]`;
                }
                if (apiStatusSummary) {
                    const isLight = document.documentElement.getAttribute('data-theme') === 'light';
                    const onColor = isLight ? 'var(--accent-fuchsia)' : 'var(--accent-mint)';
                    const offColor = 'var(--accent-red)';
                    apiStatusSummary.innerHTML = `Online: <span style="color: ${onColor}">${on}</span> • Offline: <span style="color: ${offColor}">${off}</span> • Total: ${total}`;
                }
                if (apiListOnline) apiListOnline.innerHTML = online.map(x => `<li class="flex items-center justify-between"><span>${S(x.label || 'API')}</span><span class="text-[10px] text-[--text-muted-dark]">${S(x.provider || '')}</span></li>`).join('');
                if (apiListOffline) apiListOffline.innerHTML = offline.map(x => `<li class="flex items-center justify-between"><span>${S(x.label || 'API')}</span><span class="text-[10px] text-red-400">${S(x.error || 'verify your api')}</span></li>`).join('');
                if (apiStatusErrors) {
                    const errs = offline.map(x => `${x.label || 'API'}: ${x.error || ''}`).filter(Boolean).join('\n');
                    apiStatusErrors.textContent = errs || '';
                    apiStatusErrors.classList.toggle('hidden', !errs);
                }
            } catch {}
        }

        if (apiStatusPill) {
            apiStatusPill.addEventListener('click', () => {
                // Open first with a quick loading state, then refresh asynchronously
                if (apiStatusSummary) apiStatusSummary.textContent = 'Loading…';
                if (apiListOnline) apiListOnline.innerHTML = '';
                if (apiListOffline) apiListOffline.innerHTML = '';
                if (apiStatusErrors) { apiStatusErrors.textContent = ''; apiStatusErrors.classList.add('hidden'); }
                apiStatusModal?.classList.remove('hidden');
                refreshApiStatus().catch(() => {});
            });
        }
        if (closeApiStatusModalBtn) closeApiStatusModalBtn.addEventListener('click', () => apiStatusModal?.classList.add('hidden'));
        if (apiStatusModal) apiStatusModal.addEventListener('click', (e) => { if (e.target === apiStatusModal) apiStatusModal.classList.add('hidden'); });

        async function llmRequest(path, init = {}) {
            // Proxy-only: require Supabase and a server-stored connection
            const connOverrideId = init && init.connId ? init.connId : null;
            const conn = connOverrideId ? (typeof getLlmConnections === 'function' ? getLlmConnections().find(c => c.id === connOverrideId) : null) || getActiveLlmConn() : getActiveLlmConn();
            if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) throw new Error('Supabase proxy not configured.');
            if (!conn || !conn.server) throw new Error('Active LLM connection is not server-stored. Add it in API Console > LLM.');
            const raw = init && 'body' in init ? init.body : null;
            const method = init && init.method ? init.method : 'POST';
            let fwdHeaders = init && init.headers ? { ...init.headers } : undefined;
            let bodyObj = null;
            if (raw) {
                if (typeof raw === 'string') { try { bodyObj = JSON.parse(raw); } catch { bodyObj = null; } }
                else if (typeof raw === 'object') { bodyObj = raw; }
            }
            // Provider-aware header injection (Anthropic requires anthropic-version)
            try {
                const prov = (typeof detectProvider === 'function') ? detectProvider(conn.base || '') : 'openai';
                if (prov === 'anthropic') {
                    fwdHeaders = Object.assign({ 'anthropic-version': '2023-06-01' }, fwdHeaders || {});
                }
            } catch {}
            await detectFnVariants();
            const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
            const headersFn = await buildFnHeaders();
            if (FN_VARIANTS.aiProxy === 'new') {
                return fetch(baseFn + '/proxy-ai-api', { method: 'POST', headers: headersFn, body: JSON.stringify({ config_id: conn.id, path, method, body: bodyObj, headers: fwdHeaders }) });
            }
            return fetch(baseFn + '/proxy-llm', { method: 'POST', headers: headersFn, body: JSON.stringify({ conn_id: conn.id, path, method, body: bodyObj, headers: fwdHeaders }) });
        }

            function getActiveGithubConn() {
                const list = Array.isArray(window.__PM_GH_MULTI) ? window.__PM_GH_MULTI : [];
                const activeId = window.__PM_GH_ACTIVE;
                return list.find(i => i.id === activeId) || null;
            }
            async function githubRequest(path, init = {}) {
                // Proxy-only: require Supabase
                if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) throw new Error('Supabase proxy not configured.');
                const body = init && 'body' in init ? init.body : null;
                const method = init && init.method ? init.method : 'GET';
                const base = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                const headers = await buildFnHeaders();
                // Prefer connection-based proxy if an active server-stored connection exists
                const conn = getActiveGithubConn();
                if (conn && conn.server) {
                    return fetch(base + '/proxy-github-conn', { method: 'POST', headers, body: JSON.stringify({ conn_id: conn.id, path, method, body }) });
                }
                throw new Error('Active GitHub connection is not server-stored. Add it in API Console > GitHub.');
            }

            // expose minimal API for future use
            window.PromptManaAPI = Object.assign(window.PromptManaAPI || {}, {
                getActiveLlmConn, llmRequest, getActiveGithubConn, githubRequest
            });


            const setStatus = (el, ok, msgOk = 'OK', msgFail = 'Failed') => {
                if (!el) return;
                el.textContent = ok ? msgOk : msgFail;
                el.style.color = ok ? 'var(--accent-mint)' : 'var(--accent-red)';
            };

            

            const testSupabase = async (url, key) => {
                try {
                    if (!window.supabase || !window.supabase.createClient) return false;
                    const client = window.supabase.createClient(url, key);
                    const { error } = await client.from('global_lists').select('name').limit(1);
                    if (error && (error.code === '42P01' || (error.message && error.message.includes('relation')))) {
                        // table missing but auth ok => treat as connected
                        return true;
                    }
                    return !error;
                } catch { return false; }
            };

            // Probe a single model using its connection and provider-safe body
            async function probeModel(conn, modelId) {
                const base = conn?.base || '';
                const provider = (typeof detectProvider === 'function') ? detectProvider(base) : 'openai';
                const minimalMsg = [{ role: 'user', content: 'ping' }];
                let path = 'chat/completions';
                let headers = {};
                let effectiveBody;
                if (provider === 'anthropic') {
                    path = 'messages';
                    headers = { 'anthropic-version': '2023-06-01' };
                    effectiveBody = { model: modelId, max_tokens: 1, messages: minimalMsg };
                } else if (provider === 'cohere') {
                    path = 'generate';
                    effectiveBody = { model: modelId, max_tokens: 1, messages: minimalMsg };
                } else if (provider === 'deepseek') {
                    path = 'chat/completions';
                    effectiveBody = { model: modelId, max_tokens: 1, messages: minimalMsg };
                } else if (provider === 'mistral') {
                    path = 'chat/completions';
                    effectiveBody = { model: modelId, max_tokens: 1, messages: minimalMsg };
                } else if (provider === 'google') {
                    const bInfo = sanitizeRequestForModel({ body: { model: modelId, messages: minimalMsg, max_tokens: 64 }, provider: 'google', model: modelId });
                    const b = bInfo.body;
                    const p = `models/${modelId}:generateContent`;
                    return llmRequest(p, { method: 'POST', body: b, headers: { 'x-pm-auth': 'google-query-key' }, connId: conn?.id });
                } else if (provider === 'perplexity') {
                    path = 'chat/completions';
                    effectiveBody = { model: modelId, max_tokens: 1, messages: minimalMsg };
                } else {
                    const rawBody = { model: modelId, messages: minimalMsg };
                    const caps = sanitizeRequestForModel({ body: rawBody, provider, model: modelId });
                    if (caps.unsupportedReason) {
                        return new Response(`UNSUPPORTED in Run/Diagnostics (${caps.unsupportedReason})`, { status: 400 });
                    }
                    // OpenAI must use Responses API with the specified shape
                    if (provider === 'openai') {
                        path = 'responses';
                        const b = caps.body || {};
                        const inputText = (typeof b.input === 'string' && b.input) ? b.input : (Array.isArray(rawBody.messages) ? rawBody.messages.map(m => m.content).join('\n\n') : 'ping');
                        effectiveBody = Object.assign({ model: modelId, input: inputText }, b);
                    } else if (caps.preferEndpoint === 'embeddings' && provider !== 'openai') {
                        path = 'embeddings';
                        const b = caps.body || {};
                        const inputText = (Array.isArray(rawBody.messages) ? rawBody.messages.map(m => m.content).join('\n\n') : (b.input || 'ping'));
                        effectiveBody = Object.assign({ model: modelId, input: inputText }, b);
                    } else {
                        effectiveBody = caps.body || rawBody;
                    }
                }
                // Send sanitized+converted body
                let res = await llmRequest(path, { method: 'POST', body: effectiveBody, headers, connId: conn?.id });
                if (!res.ok && (provider === 'openai' || provider === 'xai') && res.status === 400) {
                    try {
                        const j = await res.json();
                        if ((j?.error?.code === 'unsupported_value' || j?.error?.code === 'unsupported_parameter') && j?.error?.param) {
                            const copy = Object.assign({}, caps.body || rawBody);
                            delete copy[j.error.param];
                            res = await llmRequest(path, { method: 'POST', body: copy, headers, connId: conn?.id });
                        } else if (/Unsupported parameter/i.test(j?.error?.message || '')) {
                            const copy = Object.assign({}, caps.body || rawBody);
                            ['top_p','temperature','presence_penalty','frequency_penalty','seed','stop','response_format'].forEach(k => { if (k in copy) delete copy[k]; });
                            res = await llmRequest(path, { method: 'POST', body: copy, headers, connId: conn?.id });
                        }
                    } catch {}
                }
                // No OpenAI endpoint switching: always use Responses API
                return res;
            }

            async function verifyAllModels() {
                try {
                    if (verifyOut) verifyOut.textContent = '';
                    if (verifyProgress) verifyProgress.textContent = 'Starting…';
                    const conns = (typeof getLlmConnections === 'function') ? getLlmConnections() : [];
                    const groups = Object.keys(llmList || {});
                    const results = [];
                    // Map group -> conn
                    const groupToConn = {};
                    conns.forEach(c => { try { groupToConn[computeConnGroup(c)] = c; } catch {} });
                    for (const g of groups) {
                        const ids = (llmList[g] || []).slice(0); // copy
                        const conn = groupToConn[g] || null;
                        for (const id of ids) {
                            if (verifyProgress) verifyProgress.textContent = `Testing ${id}…`;
                            let status = 'OK';
                            let info = '';
                            try {
                                if (!conn) throw new Error('no-conn-for-group');
                                // If Proxy is ON and this non-openai conn is local, store on server first
                                if (!conn.server) throw new Error('connection-not-server');
                                const res = await probeModel(conn, id);
                                if (!res.ok) {
                                    status = `FAIL ${res.status}`;
                                    try { info = await res.text(); } catch {}
                                }
                            } catch (e) {
                                status = 'ERR';
                                info = e?.message || String(e);
                            }
                            results.push({ model: id, group: g, status, info });
                            if (verifyOut) verifyOut.textContent += `${g} :: ${id} -> ${status}${info ? ' — ' + info : ''}\n`;
                        }
                    }
                    if (verifyProgress) verifyProgress.textContent = 'Done';
                    return results;
                } catch (e) {
                    if (verifyProgress) verifyProgress.textContent = 'Error';
                    if (verifyOut) verifyOut.textContent += `Diagnostics error: ${e?.message || String(e)}\n`;
                    return [];
                }
            }

            // Helper: update LLM status pill
            function setLlmStatus(ok, textOk = 'LLM API: Online', textFail = 'LLM API: Offline') {
                const llmStatus = document.getElementById('llm-status-pill');
                if (!llmStatus) return;
                llmStatus.textContent = ok ? textOk : textFail;
                llmStatus.classList.remove('online','offline');
                llmStatus.classList.add(ok ? 'online' : 'offline');
            }

            // Run diagnostics, then filter model caches and llmList to only OK entries
            async function verifyAndFilterModels() {
                try {
                    // Ensure LLM lists are in sync with current connections
                    syncLlmListWithConnections();
                    const results = await verifyAllModels();
                    // Build a map of OK models per connection group
                    const okByGroup = {};
                    (results || []).forEach(r => {
                        const ok = r.status === 'OK';
                        if (ok) {
                            if (!okByGroup[r.group]) okByGroup[r.group] = new Set();
                            okByGroup[r.group].add(r.model);
                        }
                    });
                    // Filter per-connection caches and llmList to only OK models
                    const conns = (typeof getLlmConnections === 'function') ? getLlmConnections() : [];
                    conns.forEach(conn => {
                        const group = computeConnGroup(conn);
                        const cached = getModelsCache(conn.id) || [];
                        const okSet = okByGroup[group] || new Set();
                        const filtered = cached
                            .filter(id => okSet.has(id))
                            .filter(id => !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id));
                        setModelsCache(conn.id, filtered);
                    });
                    // Rebuild llmList strictly from filtered caches
                    rebuildLlmListFromConnections();
                    // Update selects/drawers with filtered ok models
                    if (typeof populateLlmSelect === 'function') populateLlmSelect();
                    if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                    // Mark status: Online if we had at least one OK model overall
                    const anyOk = (results || []).some(r => r.status === 'OK');
                    try { await refreshApiStatus(); } catch {}
                    return results;
                } catch (e) {
                    try { await refreshApiStatus(); } catch {}
                    return [];
                }
            }

        const testLLM = async (_base, _key, connId = null) => {
                const fail = (status = 0, text = '') => ({ ok: false, status, text });
                try {
            if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return fail(0, 'Supabase proxy not configured.');
                    if (!connId) return fail(0, 'Missing server-stored connection');
                    await detectFnVariants();
                    const fnUrl = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                    const fnHeaders = await buildFnHeaders();
                    const provider = (typeof detectProvider === 'function') ? detectProvider(_base || '') : 'openai';
                    // 1) Try GET /models
                    const firstBody = (FN_VARIANTS.aiProxy === 'new')
                        ? { config_id: connId, path: 'models', method: 'GET' }
                        : { conn_id: connId, path: 'models', method: 'GET' };
                    try {
                        const r = await fetch(fnUrl + (FN_VARIANTS.aiProxy === 'new' ? '/proxy-ai-api' : '/proxy-llm'), { method: 'POST', headers: fnHeaders, body: JSON.stringify(firstBody) });
                        if (r.ok) return { ok: true, status: r.status, text: 'models ok' };
                        if (r.status === 401 || r.status === 403) {
                            const t = await r.text().catch(() => '');
                            return fail(r.status, t || 'Unauthorized');
                        }
                    } catch {}
                    // 2) Minimal probe per provider
                    let path = 'chat/completions';
                    let body = { model: 'gpt-4o-mini', max_tokens: 1, messages: [{ role: 'user', content: 'ping' }] };
                    let hdrs = undefined;
                    if (provider === 'xai') { body = { model: 'grok-3-mini-beta', max_tokens: 1, messages: [{ role: 'user', content: 'ping' }] }; }
                    if (provider === 'openai') {
                        // Use Responses API with required shape
                        path = 'responses';
                        body = { model: 'gpt-4o-mini', input: 'ping', stream: false, service_tier: 'auto', reasoning: 'medium' };
                    }
                    const secondBody = (FN_VARIANTS.aiProxy === 'new')
                        ? { config_id: connId, path, method: 'POST', body, headers: hdrs }
                        : { conn_id: connId, path, method: 'POST', body, headers: hdrs };
                    const r2 = await fetch(fnUrl + (FN_VARIANTS.aiProxy === 'new' ? '/proxy-ai-api' : '/proxy-llm'), { method: 'POST', headers: fnHeaders, body: JSON.stringify(secondBody) });
                    if (r2.ok) return { ok: true, status: r2.status, text: 'chat ok' };
                    const txt = await r2.text().catch(() => '');
                    if (r2.status === 400 && /model/i.test(txt)) return { ok: true, status: r2.status, text: 'auth ok (model error)' };
                    return fail(r2.status, txt);
                } catch (e) {
                    return fail(0, (e && e.message) ? e.message : 'Unknown error');
                }
            };

            const testGitHub = async (_token, connId = null) => {
                try {
                    if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return false;
                    if (!connId) return false; // require server-stored connection
                    const fnUrl = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                    const headers = await buildFnHeaders();
                    const res = await fetch(fnUrl + '/proxy-github-conn', { method: 'POST', headers, body: JSON.stringify({ conn_id: connId, path: 'user', method: 'GET' }) });
                    return res.ok;
                } catch { return false; }
            };

            const switchApiTab = (tab) => {
                ['sql','llm','git'].forEach(t => {
                    const panel = document.getElementById(`api-panel-${t}`);
                    if (panel) panel.classList.toggle('hidden', t !== tab);
                });
                apiTabBtns.forEach(btn => btn.classList.toggle('primary', btn.dataset.apiTab === tab));
                // Do not auto-load models; render existing caches and let user click per-connection Load
                if (tab === 'llm') { try { renderLlmModelsPerConn(); } catch {} }
                if (tab === 'git') { try { loadAccessibleRepos(); } catch {} }
            };

                if (apiConsoleBtn && apiConsoleModal) {
                apiConsoleBtn.addEventListener('click', () => {
                    apiConsoleModal.classList.remove('hidden');
                    loadApiSettings();
                    switchApiTab('llm');
                    // Ensure models list reflects filtered OK models
                    try { renderLlmModelsPerConn(); } catch {}
                });
                if (closeApiConsoleBtn) closeApiConsoleBtn.addEventListener('click', () => apiConsoleModal.classList.add('hidden'));
                // Close API Console on overlay click
                apiConsoleModal.addEventListener('click', (e) => {
                    if (e.target === apiConsoleModal) apiConsoleModal.classList.add('hidden');
                });
                apiConsoleModal.addEventListener('click', (e) => { if (e.target === apiConsoleModal) apiConsoleModal.classList.add('hidden'); });

                // Tab switching
                apiTabBtns.forEach(btn => btn.addEventListener('click', () => switchApiTab(btn.dataset.apiTab)));

                

                // Removed Anthropics version wiring

                if (verifyFunctionsBtn) verifyFunctionsBtn.addEventListener('click', async () => {
                    const res = await verifyFunctions();
                    if (verifyOpenaiStatus) setStatus(verifyOpenaiStatus, res.openai);
                    if (verifyGithubStatus) setStatus(verifyGithubStatus, res.github);
                });

                // LLM Test button removed (repurposed later)

                // Parse curl helpers
        const parseCurl = (txt) => {
                    try {
                        if (!txt || !/curl\s/i.test(txt)) return null;
                        // Normalize quotes and whitespace
                        const s = txt.replace(/\\\n/g, ' ').replace(/\s+/g, ' ').trim();
            const urlMatch = s.match(/curl\s+([^\s\\]+)|curl\s+-X\s+\w+\s+([^\s\\]+)/i);
                        const fullUrl = (urlMatch && (urlMatch[1] || urlMatch[2])) || '';
            // Try common header forms: Authorization: Bearer <key> or x-api-key: <key>
            const authMatch = s.match(/-H\s+"?Authorization:\s*Bearer\s+([^"]+)"?| -H 'Authorization:\s*Bearer\s*([^']+)'/i);
            const xApiKeyMatch = s.match(/-H\s+"?x-api-key:\s*([^"\s]+)"?| -H 'x-api-key:\s*([^']+)'/i);
            const token = ((authMatch && (authMatch[1] || authMatch[2])) || (xApiKeyMatch && (xApiKeyMatch[1] || xApiKeyMatch[2])) || '').trim();
                        // Try to capture JSON body from -d '...'
                        let model = '';
                        try {
                            const dMatch = txt.match(/-d\s+"([\s\S]*?)"|-d\s+'([\s\S]*?)'/);
                            const bodyRaw = (dMatch && (dMatch[1] || dMatch[2])) || '';
                            if (bodyRaw) {
                                const normalized = bodyRaw.replace(/\\"/g, '"');
                                try { const obj = JSON.parse(normalized); if (obj && obj.model) model = obj.model; } catch {}
                                if (!model) {
                                    const m = normalized.match(/"model"\s*:\s*"([^"]+)"/);
                                    model = m ? m[1] : '';
                                }
                            }
                        } catch {}
                        let base = fullUrl;
                        try {
                            const u = new URL(fullUrl);
                            // strip trailing path to provider base e.g., /v1 or /v1/chat/completions -> /v1
                            const parts = u.pathname.split('/').filter(Boolean);
                            const v1Idx = parts.indexOf('v1');
                            const keep = v1Idx >= 0 ? parts.slice(0, v1Idx + 1).join('/') : parts.slice(0, 1).join('/');
                            u.pathname = '/' + keep;
                            u.search = '';
                            base = u.origin + u.pathname;
                        } catch {}
                        return { base, key: token, model };
                    } catch { return null; }
                };

                // Parse/add curl logic removed; handled by unified ADD LLM

                // GitHub test and persist
                if (githubTestBtn) githubTestBtn.addEventListener('click', async () => {
                    saveIfPresent(githubRepoInput, API_KEYS.gh_repo);
                    const token = githubTokenInput.value.trim();
                    const repo  = githubRepoInput.value.trim();
                    // Encourage server-stored connection for tests
                    let ok = false;
                    try {
                        const active = getActiveGithubConn();
                        if (active && active.server) ok = await testGitHub(null, active.id);
                        else ok = await testGitHub(token);
                    } catch { ok = false; }
                    setStatus(githubTestStatus, ok, 'OK', 'Failed');
                    // Auto-save on server if requested
                    if (ok) {
                        try {
                            await detectFnVariants();
                            const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                            const headersFn = await buildFnHeaders();
                            const res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers: headersFn, body: JSON.stringify({ type: 'github', label: repo || 'repo', base_url: repo, api_key: token }) });
                            if (res.ok) {
                                const { id } = await res.json();
                                const list = JSON.parse(localStorage.getItem(API_KEYS.gh_multi) || '[]');
                                if (!list.some(i => i.id === id)) list.push({ id, repo, server: true });
                                localStorage.setItem(API_KEYS.gh_multi, JSON.stringify(list));
                                if (!localStorage.getItem(API_KEYS.gh_active)) localStorage.setItem(API_KEYS.gh_active, id);
                                renderGithubRepoList();
                            }
                        } catch {}
                    }
                });
            // Provider section toggle (OpenAI models list)
            const llmProviderOpenaiToggle = document.getElementById('llm-provider-openai-toggle');
            const llmProviderOpenaiCaret = document.getElementById('llm-provider-openai-caret');
            if (llmProviderOpenaiToggle) {
                llmProviderOpenaiToggle.addEventListener('click', () => {
                    const box = document.getElementById('llm-available-models');
                    if (!box) return;
                    const isHidden = box.classList.contains('hidden');
                    box.classList.toggle('hidden', !isHidden);
                    if (llmProviderOpenaiCaret) llmProviderOpenaiCaret.textContent = isHidden ? '▼' : '▶';
                    if (isHidden) { try { renderLlmModelsPerConn(); } catch {} }
                });
            }
            if (verifyAllBtn) verifyAllBtn.addEventListener('click', verifyAllModels);
                // LLM multi connections
                if (llmAddApiBtn) llmAddApiBtn.addEventListener('click', async () => {
                    const show = (msg, ok) => { try { if (llmAddStatus) { llmAddStatus.textContent = msg; llmAddStatus.style.color = ok ? 'var(--accent-mint)' : 'var(--accent-red)'; } } catch {} };
                    const clear = () => { try { if (llmAddStatus) { llmAddStatus.textContent = ''; llmAddStatus.style.color = 'var(--text-muted-dark)'; } } catch {} };
                    try {
                        clear();
                        // Validate Supabase config
                        if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) { 
                            show('Supabase não configurado', false); 
                            return; 
                        }
                        // Require user session (RLS)
                        try {
                            const { data } = await (supabaseClient?.auth?.getSession?.() || {});
                            const sess = data?.session;
                            if (!sess) { show('Faça login para adicionar', false); window.openLoginModal && window.openLoginModal(); return; }
                        } catch { show('Faça login para adicionar', false); window.openLoginModal && window.openLoginModal(); return; }
                        // Determine source: server dropdown or curl
                        let base = getSelectedServerBase();
                        let key  = (llmApiKeyInput?.value || '').trim();
                        if ((!base || !key) && llmCurlInput && llmCurlInput.value.trim()) {
                            const parsed = parseCurl(llmCurlInput.value.trim());
                            if (parsed && parsed.base && parsed.key) { base = parsed.base; key = key || parsed.key; }
                        }
                        if (!base || !key) { show('Selecione servidor e informe API key', false); return; }
                        // Detect functions
                        await detectFnVariants();
                        const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                        const headersFn = await buildFnHeaders();
                        // Create server-stored connection
                        let connId = PENDING_LLM_CONN && PENDING_LLM_CONN.base === base ? PENDING_LLM_CONN.id : null;
                        if (!connId) {
                            let res;
                            const label = (() => { try { return new URL(base).hostname; } catch { return 'LLM'; } })();
                            const provider = (typeof detectProvider === 'function') ? detectProvider(base) : 'openai';
                            if (FN_VARIANTS.saveConfig === 'new') {
                                res = await fetch(baseFn + '/save-ai-api-config', { method: 'POST', headers: headersFn, body: JSON.stringify({ name: label, provider, base_url: base, api_key: key }) });
                                if (res.status === 401 || res.status === 403) {
                                    res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers: headersFn, body: JSON.stringify({ type: 'llm', label, base_url: base, api_key: key, provider }) });
                                } else if (!res.ok && FN_VARIANTS.connLlm === 'present') {
                                    res = await fetch(baseFn + '/connections-llm', { method: 'POST', headers: headersFn, body: JSON.stringify({ label, provider, base_url: base, api_key: key }) });
                                }
                            } else if (FN_VARIANTS.connLlm === 'present') {
                                res = await fetch(baseFn + '/connections-llm', { method: 'POST', headers: headersFn, body: JSON.stringify({ label, provider, base_url: base, api_key: key }) });
                            } else {
                                res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers: headersFn, body: JSON.stringify({ type: 'llm', label, base_url: base, api_key: key, provider }) });
                            }
                            if (!res || !res.ok) { show('Falha ao salvar conexão', false); return; }
                            const { id } = await res.json();
                            connId = id;
                            PENDING_LLM_CONN = { id: connId, base, label, server: true };
                        }
                        if (!connId) { show('Não foi possível criar conexão', false); return; }
                        // Persist to local list and mark active
                        const list = JSON.parse(localStorage.getItem(API_KEYS.llm_multi) || '[]');
                        const idx = list.findIndex(i => i.id === connId);
                        const entry = { id: connId, base, label: (PENDING_LLM_CONN?.label || (()=>{ try { return new URL(base).hostname; } catch { return 'LLM'; } })()), server: true };
                        if (idx >= 0) list[idx] = entry; else list.push(entry);
                        localStorage.setItem(API_KEYS.llm_multi, JSON.stringify(list));
                        localStorage.setItem(API_KEYS.llm_active, connId);
                        // Seed models from provider library to give immediate feedback
                        try {
                            const prov = (typeof detectProvider === 'function') ? detectProvider(base) : 'openai';
                            const conns = (typeof getLlmConnections === 'function') ? getLlmConnections() : [];
                            const entryConn = conns.find(i => i.id === connId) || entry;
                            const seedFromLib = (providerId) => {
                                const lib = (LLM_STATIC_LIBRARY || []).find(p => p.id === providerId);
                                const ids = Array.isArray(lib?.models) ? lib.models.slice(0) : [];
                                if (!ids.length) return;
                                setModelsCache(entryConn.id, ids);
                                try { persistAllModelCachesToServer(); } catch {}
                                try {
                                    const group = `${prov} — ${getConnLabel(entryConn)}`;
                                    llmList = llmList || {};
                                    llmList[group] = ids;
                                    if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                    if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                    if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                    if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                                } catch {}
                            };
                            if (prov === 'anthropic') seedFromLib('anthropic');
                            else if (prov === 'cohere') seedFromLib('cohere');
                            else if (prov === 'google') seedFromLib('google');
                            else if (prov === 'mistral') seedFromLib('mistral');
                            else if (prov === 'openai') seedFromLib('openai');
                            else if (prov === 'perplexity') seedFromLib('perplexity');
                            else if (prov === 'deepseek') seedFromLib('deepseek');
                        } catch {}
                        renderLlmApiList();
                        try { populateServerSelectOptions(); } catch {}
                        // Visually hint that you should load models for this new connection
                        try { startBlinkForConn(connId); } catch {}
                        // Load/seed models for this connection and show them immediately
                        try { await fetchModelsForConn(entry); stopBlinkForConn(connId); } catch {}
                        // Ensure the Models section is visible and refreshed
                        try {
                            const modelsBox = document.getElementById('llm-available-models');
                            const caret = document.getElementById('llm-provider-openai-caret');
                            if (modelsBox) modelsBox.classList.remove('hidden');
                            if (caret) caret.textContent = '▼';
                            renderLlmModelsPerConn();
                        } catch {}
                        // Keep lists coherent with connections, but avoid aggressive verification now
                        syncLlmListWithConnections();
                        show('Conexão adicionada', true);
                    } catch (e) {
                        show(e?.message ? String(e.message).slice(0, 120) : 'Erro inesperado', false);
                    }
                });

                // GitHub multi repos
                if (ghAddRepoBtn) ghAddRepoBtn.addEventListener('click', async () => {
                    const token = (githubTokenInput?.value || '').trim();
                    const repo  = (githubRepoInput?.value || '').trim();
                    if (!token || !repo) return;
                    // Proxy-only: require server storage
                    {
                        if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) return;
                        await detectFnVariants();
                        const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                        const headersFn = await buildFnHeaders();
                        // No save-ai-api-config for GitHub; keep connections-manager for GitHub
                        const res = await fetch(baseFn + '/connections-manager', { method: 'POST', headers: headersFn, body: JSON.stringify({ type: 'github', label: repo, base_url: repo, api_key: token }) });
                        if (!res.ok) return;
                        const { id } = await res.json();
                        const list = JSON.parse(localStorage.getItem(API_KEYS.gh_multi) || '[]');
                        list.push({ id, repo, server: true });
                        localStorage.setItem(API_KEYS.gh_multi, JSON.stringify(list));
                        if (!localStorage.getItem(API_KEYS.gh_active)) localStorage.setItem(API_KEYS.gh_active, id);
                        renderGithubRepoList();
                    }
                });
            }

            function renderLlmApiList() {
                if (!llmApiListEl) return;
                const list = JSON.parse(localStorage.getItem(API_KEYS.llm_multi) || '[]');
                const activeId = localStorage.getItem(API_KEYS.llm_active);
                llmApiListEl.innerHTML = '';
                list.forEach(({ id, base, label }) => {
                    const row = document.createElement('div');
                    row.className = 'flex items-center justify-between border border-[--border-dark] rounded-md p-2';
                    const left = document.createElement('div');
                    left.className = 'text-xs';
                    left.innerHTML = `<div class=\"font-semibold\">${S(label || new URL(base).hostname)} ${id===activeId ? '<span class=\\"ml-2 px-1 rounded border border-[--border-dark] text-[10px]\\">Active</span>' : ''}</div><div class=\"text-[--text-muted-dark]\">${S(base)}</div>`;
                    const right = document.createElement('div');
                    right.className = 'flex items-center gap-2';
                    const testBtn = document.createElement('button');
                    testBtn.className = 'action-button text-xs';
                    testBtn.textContent = 'Test';
                    const setBtn = document.createElement('button');
                    setBtn.className = 'action-button text-xs';
                    setBtn.textContent = 'Set active';
                    const delBtn = document.createElement('button');
                    delBtn.className = 'action-button text-xs';
                    delBtn.textContent = 'Delete';
                    const status = document.createElement('span');
                    status.className = 'text-[10px] font-mono';
                    testBtn.addEventListener('click', async () => {
                        const res = await testLLM(base, null, id);
                        setStatus(status, !!res.ok, 'OK', res && res.text ? String(res.text).slice(0, 64) : 'Fail');
                    });
                    setBtn.addEventListener('click', () => {
                        localStorage.setItem(API_KEYS.llm_active, id);
                        renderLlmApiList();
                        try { populateServerSelectOptions(); } catch {}
                        if (typeof populateLlmSelect === 'function') populateLlmSelect();
                        // Avoid auto-fetching models on switch; render list and let user Load per-connection
                        try { renderLlmModelsPerConn(); } catch {}
                        // Keep list coherence
                        syncLlmListWithConnections();
                    });
                    delBtn.addEventListener('click', async () => {
                        try {
                            if (FINAL_SUPABASE_URL && FINAL_SUPABASE_KEY) {
                                await detectFnVariants();
                                const base = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                                const headers = await buildFnHeaders();
                                if (FN_VARIANTS.deleteConfig === 'new') {
                                    await fetch(base + '/delete-ai-api-config?id=' + encodeURIComponent(id), { method: 'DELETE', headers });
                                } else {
                                    await fetch(base + '/connections-manager?id=' + encodeURIComponent(id), { method: 'DELETE', headers });
                                }
                            }
                        } catch {}
                        const cur = JSON.parse(localStorage.getItem(API_KEYS.llm_multi) || '[]');
                        localStorage.setItem(API_KEYS.llm_multi, JSON.stringify(cur.filter(i => i.id !== id)));
                        if (localStorage.getItem(API_KEYS.llm_active) === id) localStorage.removeItem(API_KEYS.llm_active);
                        renderLlmApiList();
                        try { populateServerSelectOptions(); } catch {}
                        if (typeof populateLlmSelect === 'function') populateLlmSelect();
                        // Avoid auto-load after delete; re-render groups
                        try { renderLlmModelsPerConn(); } catch {}
                        syncLlmListWithConnections();
                    });
                    right.appendChild(testBtn); right.appendChild(setBtn); right.appendChild(delBtn); right.appendChild(status);
                    row.appendChild(left); row.appendChild(right);
                    llmApiListEl.appendChild(row);
                });
            }

            function renderGithubRepoList() {
                if (!ghRepoListEl) return;
                const list = JSON.parse(localStorage.getItem(API_KEYS.gh_multi) || '[]');
                const activeId = localStorage.getItem(API_KEYS.gh_active);
                ghRepoListEl.innerHTML = '';
                list.forEach(({ id, repo }) => {
                    const row = document.createElement('div');
                    row.className = 'flex items-center justify-between border border-[--border-dark] rounded-md p-2';
                    const left = document.createElement('div');
                    left.className = 'text-xs';
                    left.innerHTML = `<div class=\"font-semibold\">${S(repo)} ${id===activeId ? '<span class=\\"ml-2 px-1 rounded border border-[--border-dark] text-[10px]\\">Active</span>' : ''}</div><div class=\"text-[--text-muted-dark]\">Token: ••••••••</div>`;
                    const right = document.createElement('div');
                    right.className = 'flex items-center gap-2';
                    const testBtn = document.createElement('button');
                    testBtn.className = 'action-button text-xs';
                    testBtn.textContent = 'Test';
                    const setBtn = document.createElement('button');
                    setBtn.className = 'action-button text-xs';
                    setBtn.textContent = 'Set active';
                    const delBtn = document.createElement('button');
                    delBtn.className = 'action-button text-xs';
                    delBtn.textContent = 'Delete';
                    const status = document.createElement('span');
                    status.className = 'text-[10px] font-mono';
                    testBtn.addEventListener('click', async () => {
                        const entry = (JSON.parse(localStorage.getItem(API_KEYS.gh_multi) || '[]').find(i => i.id === id) || {});
                        const ok = entry.server ? await testGitHub(null, id) : false;
                        setStatus(status, ok, 'OK', 'Fail');
                    });
                    setBtn.addEventListener('click', () => {
                        localStorage.setItem(API_KEYS.gh_active, id);
                        renderGithubRepoList();
                    });
                    delBtn.addEventListener('click', async () => {
                        try {
                            if (FINAL_SUPABASE_URL && FINAL_SUPABASE_KEY) {
                                const url = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1/connections-manager?id=' + encodeURIComponent(id);
                                const headers = await buildFnHeaders();
                                await fetch(url, { method: 'DELETE', headers });
                            }
                        } catch {}
                        const cur = JSON.parse(localStorage.getItem(API_KEYS.gh_multi) || '[]');
                        localStorage.setItem(API_KEYS.gh_multi, JSON.stringify(cur.filter(i => i.id !== id)));
                        if (localStorage.getItem(API_KEYS.gh_active) === id) localStorage.removeItem(API_KEYS.gh_active);
                        renderGithubRepoList();
                    });
                    right.appendChild(testBtn); right.appendChild(setBtn); right.appendChild(delBtn); right.appendChild(status);
                    row.appendChild(left); row.appendChild(right);
                    ghRepoListEl.appendChild(row);
                });
            }

            // ===== Provider-backed lists (per-connection) =====
            const getLlmConnections = () => JSON.parse(localStorage.getItem(API_KEYS.llm_multi) || '[]');
            // Track which connection ids should blink their Load models buttons
            let BLINK_CONN_IDS = new Set(JSON.parse(localStorage.getItem('pm_blink_conn_ids') || '[]'));
            function persistBlinkIds() { try { localStorage.setItem('pm_blink_conn_ids', JSON.stringify(Array.from(BLINK_CONN_IDS))); } catch {} }
            function startBlinkForConn(id) { try { if (!id) return; BLINK_CONN_IDS.add(id); persistBlinkIds(); renderLlmModelsPerConn(); } catch {} }
            function stopBlinkForConn(id) { try { if (!id) return; if (BLINK_CONN_IDS.has(id)) { BLINK_CONN_IDS.delete(id); persistBlinkIds(); renderLlmModelsPerConn(); } } catch {} }
            const getConnLabel = (conn) => {
                try { return conn.label || (conn.base ? new URL(conn.base).hostname : 'LLM'); } catch { return conn.label || 'LLM'; }
            };
            const detectProvider = (base) => {
                try {
                    const host = new URL(base).hostname.toLowerCase();
                    if (host.includes('openai')) return 'openai';
                    if (host.includes('x.ai') || host.includes('xai')) return 'xai';
                    if (host.includes('anthropic')) return 'anthropic';
                    if (host.includes('cohere')) return 'cohere';
                    if (host.includes('generativelanguage.googleapis.com')) return 'google';
                    if (host.includes('mistral.ai')) return 'mistral';
                    if (host.includes('deepseek')) return 'deepseek';
                    if (host.includes('perplexity.ai')) return 'perplexity';
                    if (host.includes('openrouter')) return 'openrouter';
                    return 'openai';
                } catch { return 'openai'; }
            };
            // Central model capability registry and sanitizer
            const MODEL_CAPS = [
                // OpenAI: image and specialized modalities – not supported by text Run
                { provider: 'openai', match: /^(dall-e-|gpt-image-1)/i, unsupportedReason: 'image_generation' },
                { provider: 'openai', match: /(realtime|transcribe|tts|audio-preview|whisper|video)/i, unsupportedReason: 'specialized_api' },
                // OpenAI: reasoning/new families – prefer Responses API
                { provider: 'openai', match: /^o1/i, preferEndpoint: 'responses', drop: ['temperature','top_p','presence_penalty','frequency_penalty','seed','response_format','stop'] },
                { provider: 'openai', match: /^o3/i, preferEndpoint: 'responses' },
                { provider: 'openai', match: /^o4/i, preferEndpoint: 'responses' },
                { provider: 'openai', match: /^gpt-4o/i, preferEndpoint: 'responses' },
                { provider: 'openai', match: /^gpt-4\.1/i, preferEndpoint: 'responses' },
                { provider: 'openai', match: /^gpt-5/i, preferEndpoint: 'responses' },
                // OpenAI: embeddings
                { provider: 'openai', match: /(embedding|^text-embedding-)/i, preferEndpoint: 'embeddings', allowed: ['model','input','encoding_format','dimensions','user'] },
                // OpenAI: deep research requires at least one tool
                { provider: 'openai', match: /deep-research/i, allowed: ['model','messages','tools','max_tokens','temperature','top_p','stop','presence_penalty','frequency_penalty','seed','response_format','stream'], ensureTools: 'web_search_preview' },
                // x.ai: image-only model not supported by text Run
                { provider: 'xai', match: /^grok-2-image-/i, unsupportedReason: 'image_generation' },
                // x.ai: be conservative – allow core sampling knobs only
                { provider: 'xai', match: /^grok-/i, allowed: ['model','messages','max_tokens','temperature','top_p','stop','stream'] },
                // Anthropic handled by provider rules below; no per-model overrides yet
                // Cohere: embeddings and rerank models
                { provider: 'cohere', match: /^embed-/i, preferEndpoint: 'embeddings', allowed: ['model','input'] },
                { provider: 'cohere', match: /^rerank-/i, unsupportedReason: 'specialized_api' },
                // Cohere chat/generate models (command-*)
                { provider: 'cohere', match: /^(command|command-r|command-a)/i, allowed: ['model','messages','max_tokens','temperature','top_p','top_k','stop_sequences','stream','service_tier','container','mcp_servers','metadata','system'] },
                // Google Gemini/Gemma
                { provider: 'google', match: /^embedding-002$/i, unsupportedReason: 'embeddings' },
                { provider: 'google', match: /^aqa-model$/i, unsupportedReason: 'specialized_api' },
                { provider: 'google', match: /^(gemini|gemma)-/i, allowed: ['model','contents','systemInstruction','generationConfig','safetySettings','tools','toolConfig','agentConfig'] },
                // Mistral
                { provider: 'mistral', match: /^pixtral-/i, unsupportedReason: 'image_generation' },
                { provider: 'mistral', match: /.*/i, allowed: ['model','messages','max_tokens','temperature','top_p','stop','stream','safe_prompt','random_seed'] },
                // Deepseek
                { provider: 'deepseek', match: /^deepseek-chat$/i, allowed: ['model','messages','max_tokens','temperature','top_p','presence_penalty','frequency_penalty','stop','stream','response_format','tools','tool_choice','logprobs','top_logprobs'] },
                { provider: 'deepseek', match: /^deepseek-reasoner$/i, drop: ['temperature','top_p','presence_penalty','frequency_penalty','logprobs','top_logprobs'] },
                // Perplexity (chat/completions compatible, with search extensions)
                { provider: 'perplexity', match: /^sonar(-.*)?$/i, allowed: ['model','messages','max_tokens','temperature','top_p','stop','stream','search_domain_filter','search_recency_filter','return_images','return_related_questions','search_mode'] },
            ];
            function getModelCaps(provider, model) {
                try {
                    const hit = MODEL_CAPS.find(r => r.provider === provider && r.match.test(model || ''));
                    return hit || { provider };
                } catch { return { provider }; }
            }
            function sanitizeRequestForModel({ body, provider, model }) {
                const caps = getModelCaps(provider, model);
                const out = { ...body };
                // Provider-level defaults
                if (provider === 'anthropic') {
                    // Anthropic doesn't support OpenAI penalties/seed/response_format
                    ['presence_penalty','frequency_penalty','seed','response_format'].forEach(k => { if (k in out) delete out[k]; });
                    // Translate stop -> stop_sequences
                    if (Array.isArray(out.stop) && out.stop.length) {
                        out.stop_sequences = out.stop;
                        delete out.stop;
                    }
                    // If first message is system and no top-level system provided, lift it
                    try {
                        if (!out.system && Array.isArray(out.messages) && out.messages.length) {
                            const first = out.messages[0];
                            if (first && first.role === 'system' && first.content) {
                                out.system = first.content;
                                out.messages = out.messages.slice(1);
                            }
                        }
                    } catch {}
                } else if (provider === 'xai') {
                    // Be conservative for x.ai by default
                    const allowed = (caps && caps.allowed) || ['model','messages','max_tokens','temperature','top_p','stop','stream'];
                    Object.keys(out).forEach(k => { if (!allowed.includes(k)) delete out[k]; });
                } else if (provider === 'openai') {
                    // Force Responses API with strict parameter set per spec
                    const m = (model || out.model || '').toString();
                    // Build input from messages/prompt if input not provided
                    if (typeof out.input === 'undefined') {
                        let inputText = '';
                        try {
                            if (Array.isArray(out.messages)) {
                                inputText = out.messages.map(m => m && m.content ? String(m.content) : '').filter(Boolean).join('\n\n');
                                delete out.messages;
                            } else if (typeof out.prompt === 'string') {
                                inputText = out.prompt;
                                delete out.prompt;
                            }
                        } catch {}
                        out.input = (typeof out.input === 'string' && out.input.trim()) ? out.input : (inputText || '');
                    }
                    // Defaults
                    // Normalize reasoning (object -> string) and default to 'medium'
                    if (out && typeof out.reasoning === 'object' && out.reasoning && typeof out.reasoning.effort === 'string') {
                        out.reasoning = out.reasoning.effort;
                    }
                    if (typeof out.reasoning === 'undefined' || !out.reasoning) out.reasoning = 'medium';
                    if (typeof out.service_tier === 'undefined') out.service_tier = 'auto';
                    if (typeof out.stream === 'undefined') out.stream = false;
                    // Clamp sampling knobs to valid ranges
                    if (typeof out.temperature === 'number') {
                        if (out.temperature < 0) out.temperature = 0; else if (out.temperature > 2) out.temperature = 2;
                    }
                    if (typeof out.top_p === 'number') {
                        if (out.top_p < 0) out.top_p = 0; else if (out.top_p > 1) out.top_p = 1;
                    }
                    // gpt-5 family extras and defaults
                    const isGpt5 = /^gpt-5(?:$|[-_])|^gpt-5-chat$/.test(m);
                    if (isGpt5 && typeof out.verbosity === 'undefined') out.verbosity = 'medium';
                    // Only include background if explicitly true
                    if (!out.background) delete out.background;
                    // Only include max_output_tokens if explicitly provided (number); clamp to [20, 300000]
                    if (typeof out.max_output_tokens !== 'number') {
                        delete out.max_output_tokens;
                    } else {
                        if (out.max_output_tokens < 20) out.max_output_tokens = 20;
                        if (out.max_output_tokens > 300000) out.max_output_tokens = 300000;
                    }
                    // Merge extra_args into the top-level and drop the container to avoid unknown-field errors
                    if (out.extra_args && typeof out.extra_args === 'object' && !Array.isArray(out.extra_args)) {
                        Object.entries(out.extra_args).forEach(([k, v]) => { if (!(k in out)) out[k] = v; });
                    }
                    delete out.extra_args;
                    // Enforce allowed fields
                    const allowed = new Set([
                        'model','input','temperature','top_p','max_output_tokens','reasoning','stream','background','service_tier',
                        // gpt-5 family
                        ...(isGpt5 ? ['verbosity','cfg','minimal_reasoning'] : []),
                    ]);
                    Object.keys(out).forEach(k => { if (!allowed.has(k)) delete out[k]; });
                    // Prefer Responses API for all OpenAI chat/generate traffic
                    return { body: out, preferEndpoint: 'responses', unsupportedReason: caps.unsupportedReason, ensureTools: undefined };
                } else if (provider === 'cohere') {
                    // Cohere generate/messages style; map OpenAI-ish fields
                    // Drop OpenAI-only penalties/seed/response_format/dimensions
                    ['presence_penalty','frequency_penalty','seed','response_format','dimensions'].forEach(k => { if (k in out) delete out[k]; });
                    // Map stop -> stop_sequences
                    if (Array.isArray(out.stop) && out.stop.length) {
                        out.stop_sequences = out.stop; delete out.stop;
                    }
                    // Optional system at top-level allowed; keep if present
                    // Ensure messages shape exists if prompting
                    if (!Array.isArray(out.messages) && out.prompt) {
                        out.messages = [{ role: 'user', content: out.prompt }];
                        delete out.prompt;
                    }
                } else if (provider === 'mistral') {
                    // Mistral chat-completions compatible with extra fields
                    // Map seed -> random_seed and drop OpenAI-only fields
                    if (typeof out.seed !== 'undefined' && typeof out.random_seed === 'undefined') { out.random_seed = out.seed; delete out.seed; }
                    ['response_format','dimensions','encoding_format','user'].forEach(k => { if (k in out) delete out[k]; });
                    // Ensure messages from prompt
                    if (!Array.isArray(out.messages) && out.prompt) {
                        out.messages = [{ role: 'user', content: out.prompt }];
                        delete out.prompt;
                    }
                    // Enforce allowed keys by caps
                    const allowed = (caps && Array.isArray(caps.allowed)) ? caps.allowed : ['model','messages','max_tokens','temperature','top_p','stop','stream','safe_prompt','random_seed'];
                    Object.keys(out).forEach(k => { if (!allowed.includes(k)) delete out[k]; });
                } else if (provider === 'google') {
                    // Map OpenAI-like shape to Gemini generateContent (plain JS)
                    const gc = {};
                    if (typeof out.temperature === 'number') gc.temperature = out.temperature;
                    if (typeof out.top_p === 'number') gc.topP = out.top_p;
                    if (typeof out.top_k === 'number') gc.topK = out.top_k;
                    if (typeof out.max_tokens === 'number') gc.maxOutputTokens = out.max_tokens;
                    if (Array.isArray(out.stop) && out.stop.length) gc.stopSequences = out.stop;
                    // Build contents from messages
                    let contents = [];
                    try {
                        if (Array.isArray(out.messages)) {
                            contents = out.messages
                                .filter(m => m && m.content && (m.role === 'user' || m.role === 'assistant' || m.role === 'model'))
                                .map(m => ({ role: m.role === 'assistant' ? 'model' : (m.role === 'model' ? 'model' : 'user'), parts: [{ text: m.content }] }));
                        } else if (typeof out.prompt === 'string') {
                            contents = [{ role: 'user', parts: [{ text: out.prompt }] }];
                        }
                    } catch {}
                    const sys = (out.system && String(out.system).trim()) ? { parts: [{ text: String(out.system) }] } : undefined;
                    const bodyOut = {};
                    if (sys) bodyOut.systemInstruction = sys;
                    if (contents.length) bodyOut.contents = contents;
                    if (Object.keys(gc).length) bodyOut.generationConfig = gc;
                    // Pass-through optional fields if already structured for Gemini
                    if (out.safetySettings) bodyOut.safetySettings = out.safetySettings;
                    if (out.tools) bodyOut.tools = out.tools;
                    if (out.toolConfig) bodyOut.toolConfig = out.toolConfig;
                    if (out.agentConfig) bodyOut.agentConfig = out.agentConfig;
                    return { body: bodyOut, preferEndpoint: caps.preferEndpoint, unsupportedReason: caps.unsupportedReason, ensureTools: caps.ensureTools };
                } else if (provider === 'deepseek') {
                    // Deepseek is OpenAI-compatible chat/completions. Apply OpenAI-like defaults but honor caps.
                    const defaultAllowed = ['model','messages','max_tokens','temperature','top_p','stop','presence_penalty','frequency_penalty','seed','response_format','stream','tools','tool_choice','logprobs','top_logprobs'];
                    let allowed = defaultAllowed;
                    if (caps && Array.isArray(caps.allowed)) allowed = caps.allowed;
                    if (caps && Array.isArray(caps.drop)) caps.drop.forEach(k => { if (k in out) delete out[k]; });
                    // Reasoner model: if tools are requested, redirect to chat model since reasoner doesn't support tools properly.
                    try {
                        const m = (model || out.model || '').toString();
                        if (/^deepseek-reasoner$/i.test(m) && Array.isArray(out.tools) && out.tools.length) {
                            out.model = 'deepseek-chat';
                        }
                    } catch {}
                    Object.keys(out).forEach(k => { if (!allowed.includes(k)) delete out[k]; });
                } else if (provider === 'perplexity') {
                    // Perplexity is OpenAI-compatible chat/completions with search extensions
                    // Ensure messages from prompt if provided
                    if (!Array.isArray(out.messages) && out.prompt) {
                        out.messages = [{ role: 'user', content: out.prompt }];
                        delete out.prompt;
                    }
                    // Drop clearly OpenAI-only extras not supported
                    ['presence_penalty','frequency_penalty','seed','response_format','dimensions','encoding_format','user','tools','tool_choice','logprobs','top_logprobs'].forEach(k => { if (k in out) delete out[k]; });
                    // Enforce allowed keys per caps
                    const allowed = (caps && Array.isArray(caps.allowed))
                        ? caps.allowed
                        : ['model','messages','max_tokens','temperature','top_p','stop','stream','search_domain_filter','search_recency_filter','return_images','return_related_questions','search_mode'];
                    Object.keys(out).forEach(k => { if (!allowed.includes(k)) delete out[k]; });
                }
                return { body: out, preferEndpoint: caps.preferEndpoint, unsupportedReason: caps.unsupportedReason, ensureTools: caps.ensureTools };
            }
            const modelsCacheKey = (id) => `llm_models_cache_${id}`;
            // In-memory models cache (cloud-only; no localStorage)
            const __MODELS_CACHE = {};
            const getModelsCache = (id) => { try { return Array.isArray(__MODELS_CACHE[modelsCacheKey(id)]) ? __MODELS_CACHE[modelsCacheKey(id)] : []; } catch { return []; } };
            const setModelsCache = (id, ids) => { try { __MODELS_CACHE[modelsCacheKey(id)] = Array.isArray(ids) ? ids.slice(0) : []; } catch {} };

            // Persist all per-connection model caches to DB (global_lists: 'llm_models_cache')
            async function persistAllModelCachesToServer() {
                try {
                    if (!supabaseClient || typeof updateGlobalList !== 'function') return;
                    const conns = getLlmConnections();
                    const map = {};
                    conns.forEach(c => { map[c.id] = getModelsCache(c.id) || []; });
                    await updateGlobalList('llm_models_cache', map);
                } catch {}
            }

            const computeConnGroup = (conn) => {
                try {
                    const prov = detectProvider(conn?.base || '');
                    return `${prov === 'openai' ? 'openai' : prov} — ${getConnLabel(conn)}`;
                } catch { return getConnLabel(conn) || 'LLM'; }
            };
            function syncLlmListWithConnections() {
                try {
                    const conns = getLlmConnections();
                    const allowed = new Set(conns.map(c => computeConnGroup(c)));
                    const next = {};
                    Object.keys(llmList || {}).forEach(g => { if (allowed.has(g)) next[g] = llmList[g]; });
                    llmList = next;
                    if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                    if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                    if (typeof populateLlmSelect === 'function') populateLlmSelect();
                    if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                } catch {}
            }
            function rebuildLlmListFromConnections() {
                try {
                    const conns = getLlmConnections();
                    const next = {};
                    conns.forEach(conn => {
                        const ids = (getModelsCache(conn.id) || []).filter(id => {
                            const prov = detectProvider(conn.base || '');
                            const caps = getModelCaps(prov, id);
                            if (caps.unsupportedReason) return false;
                            return !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id);
                        });
                        if (ids.length) next[computeConnGroup(conn)] = Array.from(new Set(ids)).sort();
                    });
                    llmList = next;
                    if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                    if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                    if (typeof populateLlmSelect === 'function') populateLlmSelect();
                    if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                } catch {}
            }

            async function fetchModelsForConn(conn) {
                try {
                    if (!conn) throw new Error('no connection');
                    let items = [];
                    if (conn.server) {
                        if (!FINAL_SUPABASE_URL || !FINAL_SUPABASE_KEY) throw new Error('proxy not configured');
                        await detectFnVariants();
                        const baseFn = FINAL_SUPABASE_URL.replace(/\/$/, '') + '/functions/v1';
                        const headersFn = await buildFnHeaders();
                        let res;
                        if (FN_VARIANTS.aiProxy === 'new') {
                            res = await fetch(baseFn + '/proxy-ai-api', { method: 'POST', headers: headersFn, body: JSON.stringify({ config_id: conn.id, path: 'models', method: 'GET' }) });
                        } else {
                            res = await fetch(baseFn + '/proxy-llm', { method: 'POST', headers: headersFn, body: JSON.stringify({ conn_id: conn.id, path: 'models', method: 'GET' }) });
                        }
                        if (!res.ok) {
                            // Surface unauthorized to prompt login
                            if (res.status === 401 || res.status === 403) {
                                try { const txt = await res.text(); } catch {}
                                try { window.openLoginModal && window.openLoginModal(); } catch {}
                                throw new Error('unauthorized');
                            }
                            throw new Error('models request failed');
                        }
                        const data = await res.json();
                        items = (data.data || data.models || data) || [];
                    } else {
                        throw new Error('Local LLM connections are not allowed. Please store this connection on server.');
                    }
                    const ids = Array.from(new Set(items
                        .map(m => m.id || m.name || m.model)
                        .filter(Boolean)
                        .filter(id => {
                            const prov = detectProvider(conn.base || '');
                            const caps = getModelCaps(prov, id);
                            if (caps.unsupportedReason) return false;
                            return !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id);
                        })
                    )).sort();
                    setModelsCache(conn.id, ids);
                    persistAllModelCachesToServer();
                    // Merge into llmList under this connection's label
                    try {
                        const prov = detectProvider(conn.base || '');
                        const label = `${prov === 'openai' ? 'openai' : prov} — ${getConnLabel(conn)}`;
                        llmList = llmList || {};
                        llmList[label] = ids;
                        if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                        if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                        if (typeof populateLlmSelect === 'function') populateLlmSelect();
                        if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                        // prune any stray groups not tied to current connections
                        syncLlmListWithConnections();
                    } catch {}
                    return ids;
                } catch (e) {
                    // Provider-specific fallback: some providers (e.g., x.ai) may not expose /models
                    try {
                        const prov = detectProvider(conn?.base || '');
                        if (prov === 'xai') {
                            const ids = [
                                'grok-3-beta',
                                'grok-3-fast-beta',
                                'grok-3-mini-beta',
                                'grok-3-mini-fast-beta',
                                'grok-2-image-1212',
                                'grok-2-1212',
                                'grok-2-vision-1212'
                            ];
                            setModelsCache(conn.id, ids);
                            persistAllModelCachesToServer();
                            try {
                                const label = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[label] = ids;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            // keep lists coherent
                            syncLlmListWithConnections();
                            return ids;
                        } else if (prov === 'deepseek') {
                            // DeepSeek: static known ids if listing isn't available
                            const ids = [
                                'deepseek-chat',
                                'deepseek-reasoner'
                            ];
                            setModelsCache(conn.id, ids);
                            persistAllModelCachesToServer();
                            try {
                                const label = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[label] = ids;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            syncLlmListWithConnections();
                            return ids;
                        } else if (prov === 'anthropic') {
                            // Use static library models for Anthropics if /models isn't available
                            const lib = (LLM_STATIC_LIBRARY || []).find(p => p.id === 'anthropic');
                            const ids = Array.isArray(lib?.models) ? lib.models.slice(0) : [];
                            setModelsCache(conn.id, ids);
                            persistAllModelCachesToServer();
                            try {
                                const label = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[label] = ids;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            syncLlmListWithConnections();
                            return ids;
                        } else if (prov === 'cohere') {
                            // Use static library models for Cohere if /models isn't available
                            const lib = (LLM_STATIC_LIBRARY || []).find(p => p.id === 'cohere');
                            const ids = Array.isArray(lib?.models) ? lib.models.slice(0) : [];
                            setModelsCache(conn.id, ids);
                            persistAllModelCachesToServer();
                            try {
                                const label = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[label] = ids;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            syncLlmListWithConnections();
                            return ids;
                        } else if (prov === 'cohere') {
                            // Use static library models for Cohere if /models isn't available
                            const lib = (LLM_STATIC_LIBRARY || []).find(p => p.id === 'cohere');
                            const ids = Array.isArray(lib?.models) ? lib.models.slice(0) : [];
                            setModelsCache(conn.id, ids);
                            persistAllModelCachesToServer();
                            try {
                                const label = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[label] = ids;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            syncLlmListWithConnections();
                            return ids;
                        } else if (prov === 'google') {
                            // Use static library models for Google Gemini if listing isn't available
                            const lib = (LLM_STATIC_LIBRARY || []).find(p => p.id === 'google');
                            const ids = Array.isArray(lib?.models) ? lib.models.slice(0) : [];
                            setModelsCache(conn.id, ids);
                            persistAllModelCachesToServer();
                            try {
                                const label = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[label] = ids;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            syncLlmListWithConnections();
                            return ids;
                        } else if (prov === 'mistral') {
                            // Use static library models for Mistral if /models isn't available
                            const lib = (LLM_STATIC_LIBRARY || []).find(p => p.id === 'mistral');
                            const ids = Array.isArray(lib?.models) ? lib.models.slice(0) : [];
                            setModelsCache(conn.id, ids);
                            persistAllModelCachesToServer();
                            try {
                                const label = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[label] = ids;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            syncLlmListWithConnections();
                            return ids;
                        } else if (prov === 'openai') {
                            // Use static library models for OpenAI if /models isn't available
                            const lib = (LLM_STATIC_LIBRARY || []).find(p => p.id === 'openai');
                            const ids = Array.isArray(lib?.models) ? lib.models.slice(0) : [];
                            setModelsCache(conn.id, ids);
                            persistAllModelCachesToServer();
                            try {
                                const label = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[label] = ids;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            syncLlmListWithConnections();
                            return ids;
                        } else if (prov === 'perplexity') {
                            // Use static library models for Perplexity if /models isn't available
                            const lib = (LLM_STATIC_LIBRARY || []).find(p => p.id === 'perplexity');
                            const ids = Array.isArray(lib?.models) ? lib.models.slice(0) : [];
                            setModelsCache(conn.id, ids);
                            persistAllModelCachesToServer();
                            try {
                                const label = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[label] = ids;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            syncLlmListWithConnections();
                            return ids;
                        }
                    } catch {}
                    throw e;
                }
            }

            function renderLlmModelsPerConn() {
                if (!llmAvailableModelsEl) return;
                const list = getLlmConnections();
                // Build grouped toggles per connection
                llmAvailableModelsEl.innerHTML = '';
                if (!list.length) {
                    llmAvailableModelsEl.innerHTML = '<div class="text-[--text-muted-dark]">No connections yet. Add an LLM API above.</div>';
                    return;
                }
                list.forEach((conn) => {
                    const prov = detectProvider(conn.base || '');
                    const label = getConnLabel(conn);
                    const header = document.createElement('div');
                    header.className = 'prompt-group-header flex items-center gap-2';
                    header.innerHTML = `<span class="toggle-icon">▶</span><span class="text-xs font-semibold text-[--text-muted-dark]">${S(label)}</span>`;
                    const wrap = document.createElement('div');
                    wrap.className = 'pl-2 mt-1 hidden';
                    const actions = document.createElement('div');
                    actions.className = 'flex items-center justify-between mb-1 gap-2';
                    const left = document.createElement('div');
                    left.className = 'text-[10px] text-[--text-muted-dark] font-mono truncate';
                    left.textContent = conn.base || '';
                    const right = document.createElement('div');
                    right.className = 'flex items-center gap-2';
                    const loadBtn = document.createElement('button');
                    loadBtn.className = 'action-button text-xs' + (BLINK_CONN_IDS && BLINK_CONN_IDS.has(conn.id) ? ' blink-llm' : '');
                    loadBtn.textContent = 'Load models';
                    const checkBtn = document.createElement('button');
                    checkBtn.className = 'action-button text-xs';
                    checkBtn.textContent = 'Check models';
                    right.appendChild(loadBtn);
                    right.appendChild(checkBtn);
                    if (prov === 'xai') {
                        const autoBtn = document.createElement('button');
                        autoBtn.className = 'action-button text-xs';
                        autoBtn.textContent = 'Auto-import';
                        autoBtn.title = 'Add known x.ai models to this connection';
                        right.appendChild(autoBtn);
                        autoBtn.addEventListener('click', () => {
                            const known = [
                                'grok-3-beta',
                                'grok-3-fast-beta',
                                'grok-3-mini-beta',
                                'grok-3-mini-fast-beta',
                                'grok-2-image-1212',
                                'grok-2-1212',
                                'grok-2-vision-1212'
                            ];
                            const cached = getModelsCache(conn.id);
                            const next = Array.from(new Set([...(cached||[]), ...known]))
                                .filter(id => {
                                    const caps = getModelCaps('xai', id);
                                    if (caps.unsupportedReason) return false;
                                    return !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id);
                                })
                                .sort();
                            setModelsCache(conn.id, next);
                            persistAllModelCachesToServer();
                            try {
                                const group = `${prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[group] = next;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                            renderBody();
                        });
                    }
                    actions.appendChild(left);
                    actions.appendChild(right);
                    const body = document.createElement('div');
                    body.className = 'space-y-1 text-xs';
                    const controls = document.createElement('div');
                    controls.className = 'flex items-center gap-2 mt-1 flex-wrap';
                    const addInput = document.createElement('input');
                    addInput.placeholder = 'Add model id (e.g., gpt-4o-mini or grok-3-mini-beta)';
                    addInput.className = 'form-control compact-field rounded-md text-xs flex-1';
                    const addBtn = document.createElement('button');
                    addBtn.className = 'action-button text-xs';
                    addBtn.textContent = 'Add model';
                    const bulkInput = document.createElement('textarea');
                    bulkInput.rows = 3;
                    bulkInput.placeholder = 'Bulk add: paste JSON { "data": [{"id": "..."}], "object": "list" } or comma/space-separated ids';
                    bulkInput.className = 'form-control rounded-md text-xs flex-1';
                    const bulkBtn = document.createElement('button');
                    bulkBtn.className = 'action-button text-xs';
                    bulkBtn.textContent = 'Bulk add';
                    const status = document.createElement('span');
                    status.className = 'text-[10px] font-mono';
                    controls.appendChild(addInput); controls.appendChild(addBtn);
                    controls.appendChild(bulkInput); controls.appendChild(bulkBtn);
                    controls.appendChild(status);
                    const renderBody = (state) => {
                        const cached = getModelsCache(conn.id);
                        if (state === 'loading') { body.innerHTML = '<div class="text-[--text-muted-dark]">Loading…</div>'; return; }
                        if (!cached.length) {
                            const hint = prov === 'xai' ? ' Tip: for x.ai, try model id "grok-3-mini-beta".' : '';
                            body.innerHTML = `<div class="text-[--text-muted-dark]">No models cached. Click "Load models" or add a model id manually.${S(hint)}</div>`;
                            return;
                        }
                        body.innerHTML = '';
                        cached.forEach(id => {
                            const row = document.createElement('div');
                            row.className = 'drawer-row';
                            row.innerHTML = `<div class="truncate"><span class="font-mono">${S(id)}</span></div>`;
                            body.appendChild(row);
                        });
                    };
                    renderBody();
                    loadBtn.addEventListener('click', async () => {
                        renderBody('loading');
                        try { await fetchModelsForConn(conn); setStatus(status, true, 'OK', ''); stopBlinkForConn(conn.id); } catch { body.innerHTML = '<div class="text-[--accent-red]">Failed to load models</div>'; setStatus(status, false, '', 'Fail'); return; }
                        renderBody();
                    });
                    addBtn.addEventListener('click', () => {
                        const id = (addInput.value || '').trim();
                        if (!id) return;
                        const cached = getModelsCache(conn.id);
                        if (!cached.includes(id)) {
                            if (/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id)) { addInput.value = ''; return; }
                            const next = [...cached, id].filter(x => !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(x)).sort();
                            setModelsCache(conn.id, next);
                            persistAllModelCachesToServer();
                            // update llmList grouping
                            try {
                                const prov = detectProvider(conn.base || '');
                                const group = `${prov === 'openai' ? 'openai' : prov} — ${getConnLabel(conn)}`;
                                llmList = llmList || {};
                                llmList[group] = next;
                                if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                                if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                                if (typeof populateLlmSelect === 'function') populateLlmSelect();
                                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                            } catch {}
                        }
                        addInput.value = '';
                        renderBody();
                    });
                    // Probe each cached model and color accordingly
                    checkBtn.addEventListener('click', async () => {
                        const cached = getModelsCache(conn.id);
                        if (!cached.length) return;
                        const rows = Array.from(body.querySelectorAll('.drawer-row'));
                        // Map model id -> row
                        const map = new Map();
                        cached.forEach((id, idx) => { map.set(id, rows[idx]); });
                        for (const id of cached) {
                            try {
                                const res = await probeModel(conn, id);
                                const ok = res && res.ok;
                                const row = map.get(id);
                                if (!row) continue;
                                row.style.borderLeft = `3px solid ${ok ? 'var(--accent-mint)' : 'var(--accent-red)'}`;
                                row.style.paddingLeft = '5px';
                            } catch {
                                const row = map.get(id);
                                if (!row) continue;
                                row.style.borderLeft = '3px solid var(--accent-red)';
                                row.style.paddingLeft = '5px';
                            }
                        }
                    });
                    bulkBtn.addEventListener('click', () => {
                        const raw = (bulkInput.value || '').trim();
                        if (!raw) return;
                        let ids = [];
                        // Try JSON first
                        try {
                            const obj = JSON.parse(raw);
                            const arr = (obj && (obj.data || obj.models || [])) || [];
                            ids = Array.from(new Set(arr.map(m => m.id || m.name || m.model).filter(Boolean)));
                        } catch {
                            // Fallback to delimiter-based parsing
                            ids = Array.from(new Set(raw.split(/[\s,]+/).map(s => s.trim()).filter(Boolean)));
                        }
                        if (!ids.length) return;
                        const cached = getModelsCache(conn.id);
                        const next = Array.from(new Set([...(cached||[]), ...ids]))
                            .filter(id => !/(image|audio|video|realtime|whisper|tts|transcribe)/i.test(id))
                            .sort();
                        setModelsCache(conn.id, next);
                        persistAllModelCachesToServer();
                        try {
                            const prov = detectProvider(conn.base || '');
                            const group = `${prov === 'openai' ? 'openai' : prov} — ${getConnLabel(conn)}`;
                            llmList = llmList || {};
                            llmList[group] = next;
                            if (typeof saveLlmListToStorage === 'function') saveLlmListToStorage();
                            if (typeof updateGlobalList === 'function') { try { updateGlobalList('llm_list', llmList); } catch {} }
                            if (typeof populateLlmSelect === 'function') populateLlmSelect();
                            if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                        } catch {}
                        bulkInput.value = '';
                        renderBody();
                    });
                    let expanded = false;
                    header.addEventListener('click', () => {
                        expanded = !expanded;
                        header.querySelector('.toggle-icon').textContent = expanded ? '▼' : '▶';
                        header.classList.toggle('expanded', expanded);
                        wrap.classList.toggle('hidden', !expanded);
                    });
                    wrap.appendChild(actions);
                    wrap.appendChild(body);
                    wrap.appendChild(controls);
                    llmAvailableModelsEl.appendChild(header);
                    llmAvailableModelsEl.appendChild(wrap);
                });
            }

            async function loadAvailableModels() {
                // Backward-compat: fetch models for the active connection and then render groups
                try {
                    const active = (typeof getActiveLlmConn === 'function') ? getActiveLlmConn() : null;
                    if (active) await fetchModelsForConn(active);
                } catch {}
                renderLlmModelsPerConn();
            }

            async function loadAccessibleRepos(targetEl) {
                // Load into the provided container (API Console or Dock mirror)
                const target = targetEl || ghAvailableReposEl || dockGhAvailableReposEl;
                if (!target) return;
                target.innerHTML = '<div class="text-[--text-muted-dark]">Loading…</div>';
                try {
                    // Prefer listing both personal and org repos via REST
                    const res = await githubRequest('user/repos?per_page=100', { method: 'GET' });
                    if (!res.ok) throw new Error('repos request failed');
                    const repos = await res.json();
                    target.innerHTML = '';
                    // Group by owner/org prefix before '/'
                    const byOwner = {};
                    (repos || []).forEach(r => {
                        const full = r.full_name || `${r.owner?.login || ''}/${r.name}`;
                        const owner = full.split('/')[0] || 'unknown';
                        if (!byOwner[owner]) byOwner[owner] = [];
                        byOwner[owner].push({ id: String(r.id || full), full, name: r.name || full.split('/')[1] || full, isPrivate: !!r.private });
                    });
            Object.keys(byOwner).sort().forEach(owner => {
                        const header = document.createElement('div');
                        header.className = 'prompt-group-header flex items-center gap-2';
                        header.innerHTML = `<span class="toggle-icon">▶</span><span class="text-xs font-semibold text-[--text-muted-dark]">${S(owner)}</span>`;
                        const list = document.createElement('div');
                        list.className = 'space-y-1 pl-2 mt-1 hidden';
                        let expanded = false;
                        header.addEventListener('click', () => {
                            expanded = !expanded;
                            header.querySelector('.toggle-icon').textContent = expanded ? '▼' : '▶';
                header.classList.toggle('expanded', expanded);
                            list.classList.toggle('hidden', !expanded);
                        });
                        (byOwner[owner] || []).sort((a,b) => a.full.localeCompare(b.full)).forEach(({ id, full, name, isPrivate }) => {
                            const row = document.createElement('div');
                            row.className = 'drawer-row';
                            // caret icon inline with name
                            row.innerHTML = `<div class="truncate flex items-center gap-2"><span class="toggle-icon">▶</span><span class="font-mono">${S(name)}</span>${isPrivate ? ' <span class=\"text-[--text-muted-dark]\">(private)</span>' : ''}</div>`;
                            row.dataset.repoId = id;
                            row.dataset.repoFull = full;
                            // Visual caret toggle on click
                            row.addEventListener('click', () => {
                                const icon = row.querySelector('.toggle-icon');
                                if (icon) icon.textContent = icon.textContent === '▶' ? '▼' : '▶';
                                try {
                                    // Assign selection to current prompt-level repo
                                    currentGithubRepo = { id, full };
                                    // Visually mark selected within this list
                                    target.querySelectorAll('.drawer-row').forEach(r => r.classList.remove('selected'));
                                    row.classList.add('selected');
                                } catch {}
                            });
                            list.appendChild(row);
                        });
                        target.appendChild(header);
                        target.appendChild(list);
                    });
                    if (!Object.keys(byOwner).length) target.innerHTML = '<div class="text-[--text-muted-dark]">No repositories found.</div>';
                } catch (e) {
                    target.innerHTML = '<div class="text-[--accent-red]">Failed to load repos</div>';
                }
            }

            async function loadRepoFolders() {
                if (!ghRepoFoldersEl) return;
                ghRepoFoldersEl.innerHTML = '<div class="text-[--text-muted-dark]">Loading…</div>';
                try {
                    const conn = (typeof getActiveGithubConn === 'function') ? getActiveGithubConn() : null;
                    const repo = conn?.repo;
                    if (!repo) throw new Error('No active repo');
                    // List root-level contents as folders/files
                    const res = await githubRequest(`repos/${repo}/contents/`, { method: 'GET' });
                    if (!res.ok) throw new Error('contents request failed');
                    const items = await res.json();
                    ghRepoFoldersEl.innerHTML = '';
                    // Show directories first, then files
                    const dirs = (items || []).filter(it => it.type === 'dir');
                    const files = (items || []).filter(it => it.type !== 'dir');
                    const ordered = [...dirs, ...files];
                    ordered.forEach((it) => {
                        const isDir = it.type === 'dir';
                        const row = document.createElement('div');
                        row.className = 'drawer-row';
                        row.innerHTML = `<div class="truncate"><span class="font-mono">${S(it.path)}</span>${isDir? ' <span class=\"text-[--text-muted-dark]\">(dir)</span>':''}</div>`;
                        ghRepoFoldersEl.appendChild(row);
                    });
                    if (!items || !items.length) ghRepoFoldersEl.innerHTML = '<div class="text-[--text-muted-dark]">No items found.</div>';
                } catch (e) {
                    ghRepoFoldersEl.innerHTML = '<div class="text-[--accent-red]">Failed to load folders</div>';
                }
            }

            // Global Load/Rebuild removed
            if (ghLoadReposBtn) ghLoadReposBtn.addEventListener('click', () => loadAccessibleRepos(ghAvailableReposEl));
            if (ghReposToggle) ghReposToggle.addEventListener('click', () => {
                const box = document.getElementById('github-available-repos');
                if (!box) return;
                const isHidden = box.classList.contains('hidden');
                box.classList.toggle('hidden', !isHidden);
                if (ghReposCaret) ghReposCaret.textContent = isHidden ? '▼' : '▶';
                if (isHidden) loadAccessibleRepos(ghAvailableReposEl);
            });
            if (dockGhLoadReposBtn) dockGhLoadReposBtn.addEventListener('click', () => loadAccessibleRepos(dockGhAvailableReposEl));
            if (dockGhReposToggle) dockGhReposToggle.addEventListener('click', () => {
                const box = document.getElementById('dock-github-available-repos');
                if (!box) return;
                const isHidden = box.classList.contains('hidden');
                box.classList.toggle('hidden', !isHidden);
                if (dockGhReposCaret) dockGhReposCaret.textContent = isHidden ? '▼' : '▶';
                if (isHidden) loadAccessibleRepos(dockGhAvailableReposEl);
            });
            if (ghLoadFoldersBtn) ghLoadFoldersBtn.addEventListener('click', loadRepoFolders);
            if (ghRepoFoldersToggle) ghRepoFoldersToggle.addEventListener('click', () => {
                const box = document.getElementById('github-repo-folders');
                if (!box) return;
                const isHidden = box.classList.contains('hidden');
                box.classList.toggle('hidden', !isHidden);
                if (ghRepoFoldersCaret) ghRepoFoldersCaret.textContent = isHidden ? '▼' : '▶';
                if (isHidden) loadRepoFolders();
            });

            // --- IMPORT LOGIC ---
            const openImportModal = () => {
                // populate LLM select from existing llmList
                importLlmSelect.innerHTML = '<option value="">Unspecified</option>';
                Object.keys(llmList).sort().forEach(groupName => {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = groupName;
                    (llmList[groupName] || []).sort().forEach(llm => {
                        const option = document.createElement('option');
                        option.value = llm;
                        option.textContent = llm;
                        optgroup.appendChild(option);
                    });
                    importLlmSelect.appendChild(optgroup);
                });
                // Default name from filename (without extension)
                const base = pendingImportFilename ? pendingImportFilename.replace(/\.[^.]+$/, '') : '';
                importPromptNameInput.value = base;
                importProjectInput.value = '';
                // Default LLM to current editor selection if available
                try {
                    if (llmSelect && llmSelect.value) {
                        importLlmSelect.value = llmSelect.value;
                    }
                } catch {}
                importModal.classList.remove('hidden');
                importPromptNameInput.focus();
            };
            const closeImportModal = () => {
                importModal.classList.add('hidden');
            };
            const readFileAsArrayBuffer = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
            const readFileAsText = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
            const extractTextFromPdf = async (arrayBuffer) => {
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let text = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    const strings = content.items.map(item => item.str);
                    text += strings.join(' ') + '\n\n';
                }
                return text.trim();
            };
            const extractTextFromDocx = async (arrayBuffer) => {
                const { value } = await window.mammoth.extractRawText({ arrayBuffer });
                return (value || '').trim();
            };
            
            // --- Import from Git helpers ---
            let gitSelectedRepoFull = '';
            let gitSelectedFile = null;
            let gitFilesCache = [];

            const openImportGitModal = async () => {
                gitSelectedRepoFull = (currentGithubRepo && currentGithubRepo.full) || '';
                gitSelectedFile = null;
                gitFilesCache = [];
                if (gitBrowserRepos) gitBrowserRepos.innerHTML = '<div class="text-[--text-muted-dark]">Loading repos…</div>';
                if (gitBrowserFiles) gitBrowserFiles.innerHTML = '<div class="text-[--text-muted-dark]">Select a repository to list Markdown files.</div>';
                if (gitImportConfirmBtn) gitImportConfirmBtn.disabled = true;
                if (importGitModal) importGitModal.classList.remove('hidden');
                await renderGitReposList();
                if (gitSelectedRepoFull) {
                    await listMarkdownFilesForRepo(gitSelectedRepoFull);
                }
            };

            const closeImportGitModal = () => {
                if (importGitModal) importGitModal.classList.add('hidden');
            };

            async function renderGitReposList() {
                if (!gitBrowserRepos) return;
                try {
                    gitBrowserRepos.innerHTML = '<div class="text-[--text-muted-dark]">Loading…</div>';
                    const res = await githubRequest('user/repos?per_page=100', { method: 'GET' });
                    if (!res.ok) throw new Error('repos request failed');
                    const repos = await res.json();
                    const byOwner = {};
                    (repos || []).forEach(r => {
                        const full = r.full_name || `${r.owner?.login || ''}/${r.name}`;
                        const owner = full.split('/')[0] || 'unknown';
                        if (!byOwner[owner]) byOwner[owner] = [];
                        byOwner[owner].push({ full, name: r.name || full.split('/')[1] || full });
                    });
                    gitBrowserRepos.innerHTML = '';
                    Object.keys(byOwner).sort().forEach(owner => {
                        const header = document.createElement('div');
                        header.className = 'prompt-group-header flex items-center gap-2';
                        header.innerHTML = `<span class="toggle-icon">▶</span><span class="text-xs font-semibold text-[--text-muted-dark]">${S(owner)}</span>`;
                        const list = document.createElement('div');
                        list.className = 'space-y-1 pl-2 mt-1 hidden';
                        let expanded = owner === (gitSelectedRepoFull?.split('/')[0] || '');
                        header.addEventListener('click', () => {
                            expanded = !expanded;
                            header.querySelector('.toggle-icon').textContent = expanded ? '▼' : '▶';
                            header.classList.toggle('expanded', expanded);
                            list.classList.toggle('hidden', !expanded);
                        });
                        if (expanded) {
                            header.querySelector('.toggle-icon').textContent = '▼';
                            list.classList.remove('hidden');
                        }
                        (byOwner[owner] || []).sort((a,b) => a.full.localeCompare(b.full)).forEach(({ full, name }) => {
                            const row = document.createElement('div');
                            row.className = 'drawer-row';
                            row.innerHTML = `<div class=\"truncate flex items-center gap-2\"><span class=\"toggle-icon ${full===gitSelectedRepoFull?'opacity-100':'opacity-40'}\">●</span><span class=\"font-mono\">${S(name)}</span></div>`;
                            row.addEventListener('click', async () => {
                                gitSelectedRepoFull = full;
                                gitSelectedFile = null;
                                if (gitImportConfirmBtn) gitImportConfirmBtn.disabled = true;
                                gitBrowserRepos.querySelectorAll('.drawer-row').forEach(r => r.classList.remove('selected'));
                                row.classList.add('selected');
                                await listMarkdownFilesForRepo(full);
                            });
                            if (full === gitSelectedRepoFull) row.classList.add('selected');
                            list.appendChild(row);
                        });
                        gitBrowserRepos.appendChild(header);
                        gitBrowserRepos.appendChild(list);
                    });
                    if (!Object.keys(byOwner).length) gitBrowserRepos.innerHTML = '<div class="text-[--text-muted-dark]">No repositories found.</div>';
                } catch (e) {
                    console.error(e);
                    gitBrowserRepos.innerHTML = '<div class="text-[--accent-red]">Failed to load repos</div>';
                }
            }

            async function listMarkdownFilesForRepo(repoFull) {
                if (!gitBrowserFiles) return;
                gitBrowserFiles.innerHTML = '<div class="text-[--text-muted-dark]">Scanning repository…</div>';
                gitFilesCache = [];
                try {
                    // Get default branch
                    const repoRes = await githubRequest(`repos/${repoFull}`, { method: 'GET' });
                    if (!repoRes.ok) throw new Error('repo request failed');
                    const repoInfo = await repoRes.json();
                    const defaultBranch = repoInfo.default_branch || 'main';
                    // Get ref to obtain commit sha
                    const refRes = await githubRequest(`repos/${repoFull}/git/refs/heads/${defaultBranch}`, { method: 'GET' });
                    if (!refRes.ok) throw new Error('ref request failed');
                    const refInfo = await refRes.json();
                    const commitSha = refInfo && (Array.isArray(refInfo) ? refInfo[0]?.object?.sha : refInfo.object?.sha);
                    if (!commitSha) throw new Error('no commit sha');
                    const commitRes = await githubRequest(`repos/${repoFull}/git/commits/${commitSha}`, { method: 'GET' });
                    if (!commitRes.ok) throw new Error('commit request failed');
                    const commitInfo = await commitRes.json();
                    const treeSha = commitInfo?.tree?.sha;
                    if (!treeSha) throw new Error('no tree sha');
                    const treeRes = await githubRequest(`repos/${repoFull}/git/trees/${treeSha}?recursive=1`, { method: 'GET' });
                    if (!treeRes.ok) throw new Error('tree request failed');
                    const tree = await treeRes.json();
                    const all = (tree.tree || []).filter(it => it.type === 'blob' && /\.md$/i.test(it.path || ''));
                    gitFilesCache = all.map(f => ({ path: f.path }));
                    renderGitFilesList();
                } catch (e) {
                    console.error(e);
                    gitBrowserFiles.innerHTML = '<div class="text-[--accent-red]">Failed to scan repository</div>';
                }
            }

            function renderGitFilesList() {
                if (!gitBrowserFiles) return;
                const filter = (gitFilesFilterInput?.value || '').toLowerCase();
                const filtered = gitFilesCache.filter(f => !filter || f.path.toLowerCase().includes(filter));
                if (!filtered.length) {
                    gitBrowserFiles.innerHTML = '<div class="text-[--text-muted-dark]">No markdown files found.</div>';
                    return;
                }
                gitBrowserFiles.innerHTML = '';
                filtered.forEach(({ path }) => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.innerHTML = `<div class="truncate font-mono">${S(path)}</div>`;
                    row.addEventListener('click', () => {
                        gitSelectedFile = path;
                        if (gitImportConfirmBtn) gitImportConfirmBtn.disabled = false;
                        gitBrowserFiles.querySelectorAll('.drawer-row').forEach(r => r.classList.remove('selected'));
                        row.classList.add('selected');
                        const base = path.split('/').pop().replace(/\.[^.]+$/, '');
                        if (gitImportTitleInput && !gitImportTitleInput.value) gitImportTitleInput.value = base;
                    });
                    gitBrowserFiles.appendChild(row);
                });
            }

            async function fetchMarkdownFile(repoFull, filePath) {
                const res = await githubRequest(`repos/${repoFull}/contents/${encodeURIComponent(filePath)}`, { method: 'GET' });
                if (!res.ok) throw new Error('file request failed');
                const json = await res.json();
                const b64 = (json.content || '').replace(/\n/g, '');
                return decodeBase64Utf8(b64);
            }

            function decodeBase64Utf8(b64) {
                try {
                    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
                    const decoder = new TextDecoder('utf-8');
                    return decoder.decode(bytes);
                } catch (e) {
                    try { return atob(b64); } catch { return ''; }
                }
            }
            const handleImportFile = async (file) => {
                const name = file.name.toLowerCase();
                pendingImportFilename = file.name;
                try {
                    if (name.endsWith('.txt') || name.endsWith('.md')) {
                        pendingImportedText = await readFileAsText(file);
                    } else if (name.endsWith('.pdf')) {
                        const ab = await readFileAsArrayBuffer(file);
                        pendingImportedText = await extractTextFromPdf(ab);
                    } else if (name.endsWith('.docx')) {
                        const ab = await readFileAsArrayBuffer(file);
                        pendingImportedText = await extractTextFromDocx(ab);
                    } else if (name.endsWith('.doc')) {
                        pendingImportedText = '';
                        showModal('Unsupported file', 'Please convert .doc to .docx and try again.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                        return;
                    } else {
                        pendingImportedText = '';
                        showModal('Unsupported file', 'Supported formats: .txt, .md, .pdf, .docx', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                        return;
                    }
                    openImportModal();
                } catch (e) {
                    console.error('Import error:', e);
                    showModal('Import failed', 'Could not read this file. Please try another.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                }
            };
            if (importBtn && importFileInput) {
                importBtn.addEventListener('click', () => importFileInput.click());
                importFileInput.addEventListener('change', () => {
                    const file = importFileInput.files?.[0];
                    if (file) handleImportFile(file);
                    importFileInput.value = '';
                });
            }
            if (importFromGitBtn) {
                importFromGitBtn.addEventListener('click', () => openImportGitModal());
            }
            if (closeImportGitModalBtn) closeImportGitModalBtn.addEventListener('click', closeImportGitModal);
            if (gitImportCancelBtn) gitImportCancelBtn.addEventListener('click', closeImportGitModal);
            if (gitBrowserLoadReposBtn) gitBrowserLoadReposBtn.addEventListener('click', renderGitReposList);
            if (refreshGitBrowserBtn) refreshGitBrowserBtn.addEventListener('click', async () => {
                await renderGitReposList();
                if (gitSelectedRepoFull) await listMarkdownFilesForRepo(gitSelectedRepoFull);
            });
            if (gitFilesFilterInput) gitFilesFilterInput.addEventListener('input', renderGitFilesList);
            if (gitImportConfirmBtn) gitImportConfirmBtn.addEventListener('click', async () => {
                try {
                    if (!gitSelectedRepoFull || !gitSelectedFile) return;
                    const md = await fetchMarkdownFile(gitSelectedRepoFull, gitSelectedFile);
                    if (!md) return;
                    mainEditor.value = md;
                    updateEditorStats();
                    renderVariables();
                    // Keep syntax overlay in sync when ON
                    refreshSyntaxOverlayIfOn();
                    const title = gitImportTitleInput?.value.trim();
                    const project = gitImportProjectInput?.value.trim();
                    if (title) titleInput.value = title;
                    if (project) {
                        projectInput.value = project;
                        if (!projectNames.includes(project)) {
                            projectNames.push(project);
                            saveProjectNamesToStorage();
                            updateGlobalList('projects', projectNames);
                        }
                    }
                    currentGithubRepo = { id: gitSelectedRepoFull, full: gitSelectedRepoFull };
                    lastImportedGitFilePath = gitSelectedFile;
                    closeImportGitModal();
                } catch (e) {
                    console.error(e);
                    showModal('Import error', 'Failed to fetch the selected Markdown file.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                }
            });

            // Close Import-from-Git on overlay click
            if (importGitModal) {
                importGitModal.addEventListener('click', (e) => {
                    if (e.target === importGitModal) closeImportGitModal();
                });
            }

            // --- Commit Changes logic ---
            const openCommitModal = async () => {
                if (!currentGithubRepo || !currentGithubRepo.full) {
                    showModal('GitHub repo not set', 'Select a repository in the Dock > GitHub before committing.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                    return;
                }
                if (commitRepoLabel) commitRepoLabel.textContent = currentGithubRepo.full;
                const candidatePath = (commitFilePathInput?.value?.trim()) || lastImportedGitFilePath || (selectedVersionId ? (prompts.find(p => p.id === selectedVersionId)?.githubFilePath || '') : '');
                if (commitFilePathInput) commitFilePathInput.value = candidatePath || '';
                if (commitMessageInput) commitMessageInput.value = `Update ${titleInput.value || 'prompt'}`;
                // Load branches
                await populateCommitBranches(currentGithubRepo.full);
                // Load latest commit info
                await updateLatestCommitInfo(currentGithubRepo.full, commitBranchSelect?.value);
                commitModal.classList.remove('hidden');
                commitMessageInput?.focus();
            };

            const closeCommitModal = () => commitModal.classList.add('hidden');

            async function commitFileToGitHub(repoFull, path, content, message, branch) {
                // First, try to get existing file to retrieve its SHA
                let sha = null;
                try {
                    const suffix = branch ? `?ref=${encodeURIComponent(branch)}` : '';
                    const head = await githubRequest(`repos/${repoFull}/contents/${encodeURIComponent(path)}${suffix}`, { method: 'GET' });
                    if (head.ok) {
                        const info = await head.json();
                        sha = info.sha || null;
                    }
                } catch {}
                const body = {
                    message: message || `Update ${path}`,
                    content: btoa(unescape(encodeURIComponent(content))),
                    sha: sha || undefined,
                    branch: branch || undefined
                };
                const res = await githubRequest(`repos/${repoFull}/contents/${encodeURIComponent(path)}`, { method: 'PUT', body: JSON.stringify(body) });
                return res.ok;
            }

            async function populateCommitBranches(repoFull) {
                if (!commitBranchSelect) return;
                commitBranchSelect.innerHTML = '<option>Loading…</option>';
                try {
                    const res = await githubRequest(`repos/${repoFull}/branches?per_page=100`, { method: 'GET' });
                    if (!res.ok) throw new Error('branches failed');
                    const branches = await res.json();
                    const repoRes = await githubRequest(`repos/${repoFull}`, { method: 'GET' });
                    const repoInfo = repoRes.ok ? await repoRes.json() : {};
                    const defaultBranch = repoInfo.default_branch || 'main';
                    commitBranchSelect.innerHTML = '';
                    (branches || []).forEach(b => {
                        const opt = document.createElement('option');
                        opt.value = b.name;
                        opt.textContent = b.name + (b.name === defaultBranch ? ' (default)' : '');
                        commitBranchSelect.appendChild(opt);
                    });
                    commitBranchSelect.value = defaultBranch;
                } catch (e) {
                    commitBranchSelect.innerHTML = '<option value="main">main</option>';
                }
            }

            async function updateLatestCommitInfo(repoFull, branch) {
                if (!commitLatestInfo) return;
                commitLatestInfo.textContent = 'Loading…';
                try {
                    const br = branch || 'main';
                    const res = await githubRequest(`repos/${repoFull}/commits?sha=${encodeURIComponent(br)}&per_page=1`, { method: 'GET' });
                    if (!res.ok) throw new Error('commits failed');
                    const items = await res.json();
                    const c = items[0];
                    if (!c) { commitLatestInfo.textContent = 'No commits found.'; return; }
                    const msg = c.commit?.message?.split('\n')[0] || '';
                    const sha = c.sha?.slice(0, 7) || '';
                    const author = c.commit?.author?.name || c.author?.login || 'unknown';
                    const date = c.commit?.author?.date || '';
                    commitLatestInfo.textContent = `${sha} — ${msg} · ${author} · ${new Date(date).toLocaleString()}`;
                } catch (e) {
                    commitLatestInfo.textContent = 'Failed to load latest commit.';
                }
            }

            if (commitChangesBtn) commitChangesBtn.addEventListener('click', openCommitModal);
            if (closeCommitModalBtn) closeCommitModalBtn.addEventListener('click', closeCommitModal);
            if (cancelCommitBtn) cancelCommitBtn.addEventListener('click', closeCommitModal);
            if (confirmCommitBtn) confirmCommitBtn.addEventListener('click', async () => {
                try {
                    const repoFull = currentGithubRepo?.full;
                    const path = commitFilePathInput?.value.trim();
                    const message = commitMessageInput?.value.trim() || `Update ${path}`;
                    const branch = commitBranchSelect?.value;
                    if (!repoFull || !path) {
                        showValidationAlert('Repository and file path are required.');
                        return;
                    }
                    const ok = await commitFileToGitHub(repoFull, path, mainEditor.value, message, branch);
                    if (!ok) throw new Error('Commit failed');
                    lastImportedGitFilePath = path;
                    // Persist file path to selected version in-memory (will save on next Save Changes/Version)
                    if (selectedVersionId) {
                        const idx = prompts.findIndex(p => p.id === selectedVersionId);
                        if (idx !== -1) { prompts[idx].githubFilePath = path; }
                    }
                    showModal('Committed', 'Changes committed to GitHub.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                    closeCommitModal();
                } catch (e) {
                    console.error(e);
                    showModal('Commit error', 'Failed to commit changes. Check your connection, permissions, and path.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                }
            });

            if (commitBranchSelect) commitBranchSelect.addEventListener('change', () => {
                if (currentGithubRepo?.full) updateLatestCommitInfo(currentGithubRepo.full, commitBranchSelect.value);
            });
            if (closeImportModalBtn) closeImportModalBtn.addEventListener('click', closeImportModal);
            if (cancelImportBtn) cancelImportBtn.addEventListener('click', closeImportModal);
            if (confirmImportBtn) confirmImportBtn.addEventListener('click', async () => {
                const title = importPromptNameInput.value.trim() || 'Imported Document';
                const project = importProjectInput.value.trim();
                const llm = importLlmSelect.value || '';
                if (!pendingImportedText) { closeImportModal(); return; }
                const promptId = getUUID();
                const now = new Date().toISOString();
                const newItem = {
                    id: getUUID(),
                    promptId,
                    title,
                    project,
                    llm,
                    content: pendingImportedText,
                    comments: '',
                    version: '1.0',
                    date: now,
                    status: 'idea',
                    tags: [],
                    temperature: 0.7,
                    topP: 0.9,
                    effort: 'Medium',
                    parent_id: '',
                };
                // Track new project names
                if (project && !projectNames.includes(project)) {
                    projectNames.push(project);
                    saveProjectNamesToStorage();
                    updateGlobalList('projects', projectNames);
                }
                // Save locally
                prompts.push(newItem);
                // ...salvamento local removido...
                // Try to upsert remotely
                const saved = await upsertItem('prompts', mapPromptUIToDb(newItem));
                if (!saved) console.warn('Remote save failed or offline; kept local');
                // Refresh UI bits
                renderVersionsList();
                loadVersionIntoEditor(newItem.id);
                closeImportModal();
                pendingImportedText = '';
            });

            // --- TEXT EDITOR ENHANCEMENTS ---
            // Formatting helpers and toolbar bindings removed

            // Tab/Shift+Tab indentation in textarea
            mainEditor.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = mainEditor.selectionStart;
                    const end = mainEditor.selectionEnd;
                    const value = mainEditor.value;
                    const sel = value.slice(start, end);
                    const isMulti = sel.includes('\n');
                    if (e.shiftKey) {
                        // outdent
                        if (isMulti) {
                            const pre = value.slice(0, start);
                            const post = value.slice(end);
                            const lines = sel.split('\n').map((l) => l.replace(/^(\t| {4})/, ''));
                            const result = lines.join('\n');
                            mainEditor.value = pre + result + post;
                            mainEditor.setSelectionRange(start, start + result.length);
                        } else {
                            const before = value.slice(0, start);
                            const after = value.slice(end);
                            const lineStart = before.lastIndexOf('\n') + 1;
                            const line = value.slice(lineStart, end);
                            const newLine = line.replace(/^(\t| {4})/, '');
                            const delta = line.length - newLine.length;
                            mainEditor.value = value.slice(0, lineStart) + newLine + after;
                            const newPos = start - delta;
                            mainEditor.setSelectionRange(newPos, newPos);
                        }
                    } else {
                        // indent
                        const indent = '\t';
                        if (isMulti) {
                            const pre = value.slice(0, start);
                            const post = value.slice(end);
                            const lines = sel.split('\n').map((l) => indent + l);
                            const result = lines.join('\n');
                            mainEditor.value = pre + result + post;
                            mainEditor.setSelectionRange(start + indent.length, start + result.length);
                        } else {
                            const before = value.slice(0, start);
                            const after = value.slice(end);
                            mainEditor.value = before + indent + after;
                            mainEditor.setSelectionRange(start + indent.length, start + indent.length);
                        }
                    }
                    mainEditor.dispatchEvent(new Event('input'));
                }
            });

            const renderVariables = () => {
                const content = mainEditor.value;
                const variableRegex = /\{\{([a-zA-Z0-9_]+)\}\}/g;
                let match;
                const variables = new Set();
                while ((match = variableRegex.exec(content)) !== null) {
                    variables.add(match[1]);
                }

                if (variables.size === 0) {
                    variablesSection.classList.add('hidden');
                    return;
                }

                variablesSection.classList.remove('hidden');
                variablesContainer.innerHTML = '';
                variables.forEach(varName => {
                    const varInputHTML = `
                        <div class="flex items-center gap-2">
                            <label for="var-${varName}" class="w-1/3 text-sm text-[--text-muted-dark] font-mono">${varName}:</label>
                            <input type="text" id="var-${varName}" name="${varName}" class="w-2/3 form-control rounded-md py-1 px-2 text-sm focus:ring-2 focus:ring-fuchsia-500 focus:border-fuchsia-500">
                        </div>
                    `;
                    variablesContainer.innerHTML += varInputHTML;
                });
            };
            
            const updateSlidersUI = () => {
                // Kept for backward compatibility (no-op)
            };

            // --- FUNÇÕES DE LÓGICA ---
            const showModal = (title, text, buttons, options = {}) => {
                confirmModalTitle.textContent = title;
                confirmModalText.innerHTML = text;
                confirmModalButtons.innerHTML = '';
                buttons.forEach(btn => {
                    const buttonEl = document.createElement('button');
                    buttonEl.className = btn.className;
                    buttonEl.textContent = btn.text;
                    buttonEl.onclick = btn.onClick;
                    confirmModalButtons.appendChild(buttonEl);
                });
            
                if (options.showInput) {
                    confirmModalInput.value = options.inputValue || '';
                    confirmModalInput.placeholder = options.inputPlaceholder || '';
                    confirmModalInputContainer.classList.remove('hidden');
                } else {
                    confirmModalInputContainer.classList.add('hidden');
                }
            
                confirmModal.classList.remove('hidden');
            };
            
            const hideModal = () => {
                confirmModal.classList.add('hidden');
            };
            
            const showValidationAlert = (message) => {
                showModal('Required Field', message, [
                    { text: 'OK', className: 'action-button primary', onClick: hideModal }
                ]);
            };
            
            const showDeleteModal = (type, id) => {
                itemToDelete = { type, id };
                const title = 'Confirm Deletion';
                const text = type === 'group' 
                    ? 'Are you sure you want to delete this prompt and all its versions? This action cannot be undone.'
                    : 'Are you sure you want to delete this specific version?';
            
                showModal(title, text, [
                    { text: 'Cancel', className: 'action-button', onClick: hideModal },
                    { text: 'Delete', className: 'action-button bg-[--accent-red] text-white border-[--accent-red-hover] hover:bg-[--accent-red-hover]', onClick: executeDelete }
                ]);
            };
            
            const showDependencyViewer = (dependencyId) => {
                const prompt = prompts.find(p => p.id === dependencyId);
                if (prompt) {
                    dependencyViewerTitle.textContent = `${prompt.title} (v${prompt.version})`;
                    dependencyViewerContent.textContent = prompt.content;
                    dependencyViewerModal.classList.remove('hidden');
                }
            };
            
            const showCommentsViewer = (promptId) => {
                const prompt = prompts.find(p => String(p.id) === String(promptId));
                if (prompt && prompt.comments) {
                    commentsViewerTitle.textContent = `Comments - ${prompt.title} (v${prompt.version})`;
                    commentsViewerContent.textContent = prompt.comments;
                    commentsViewerModal.classList.remove('hidden');
                }
            };
            
            const executeDelete = async () => {
                if (!itemToDelete.id) return;

                if (itemToDelete.type === 'group') {
                    await deleteItemsByPromptId(itemToDelete.id);
                    prompts = prompts.filter(p => String(p.promptId) !== String(itemToDelete.id));
                    if (selectedVersionId && !prompts.some(p => String(p.id) === String(selectedVersionId))) {
                        clearEditorForNewPrompt();
                    }
                } else if (itemToDelete.type === 'version') {
                    await deleteItem('prompts', itemToDelete.id);
                    prompts = prompts.filter(p => String(p.id) !== String(itemToDelete.id));
                    if (String(selectedVersionId) === String(itemToDelete.id)) {
                        clearEditorForNewPrompt();
                    }
                }
                hideModal();
                renderVersionsList();
            };
            
            const clearEditorForNewPrompt = () => {
                titleInput.value = '';
                projectInput.value = '';
                mainEditor.value = '';
                commentsTextarea.value = '';
                commentsSection.classList.add('hidden');
                selectedVersionId = null;
                llmSelect.value = '';
                currentGithubRepo = null;
                currentDependencies = [];
                updateStatusSelectorUI('idea');
                updateEditorStats();
                renderVariables();
                renderDynamicSettings(); // Reset dynamic settings to defaults
                renderDependencyBar([]);
                titleInput.focus();
                populateProjectDataList();
                renderVersionsList(); 
                renderPromptTags([]);
                tagsInput.value = '';
                renderNavigationMap();
                updateSnippetButtons();
                // If syntax overlay is active, reflect cleared editor immediately
                refreshSyntaxOverlayIfOn();
            };
            
            const loadVersionIntoEditor = (versionId) => {
                const promptVersion = prompts.find(p => p.id === versionId);
                if (!promptVersion) return;
                titleInput.value = promptVersion.title;
                projectInput.value = promptVersion.project;
                mainEditor.value = promptVersion.content;
                commentsTextarea.value = promptVersion.comments || '';
                llmSelect.value = promptVersion.llm || '';
                currentGithubRepo = promptVersion.githubRepo ? { id: promptVersion.githubRepo, full: promptVersion.githubRepoFull || '' } : null;
                selectedVersionId = versionId;
                updateStatusSelectorUI(normalizeStatus(promptVersion.status));
                updateEditorStats();
                renderVariables();
                renderDynamicSettings(
                    promptVersion.modelSettings || {
                        temperature: promptVersion.temperature,
                        topP: promptVersion.topP,
                        effort: (typeof promptVersion.effort === 'string') ? effortLevels.indexOf(promptVersion.effort) : undefined
                    }
                );
                expandedPromptGroups.add(String(promptVersion.promptId));
            
                const depsToShow = (promptVersion.dependencies && promptVersion.dependencies.length)
                    ? promptVersion.dependencies
                    : (promptVersion.parent_id ? [promptVersion.parent_id] : []);
                renderDependencyBar(depsToShow);
            
                populateProjectDataList();
                renderVersionsList(); 
                renderPromptTags(promptVersion.tags);
                tagsInput.value = '';
                renderNavigationMap();
                updateSnippetButtons();
                // Re-render syntax overlay to reflect newly loaded content when Syntax is ON
                refreshSyntaxOverlayIfOn();
            };
            
            const saveVersion = async (isMajor = false) => {
                const title = titleInput.value.trim();
                const project = projectInput.value.trim();
                const content = mainEditor.value.trim();
                const comments = commentsTextarea.value.trim();
                const activeStatus = normalizeStatus(document.querySelector('.status-option.active')?.dataset.status || 'idea');
                const llm = llmSelect.value;
                const selectedDepIds = currentDependencies.map(String);
                const parent_id = selectedDepIds.length === 1 ? selectedDepIds[0] : null;
                const dyn = collectDynamicSettings();
                const temperature = dyn.temperature ?? 0.7;
                const topP = dyn.topP ?? 0.9;
                const effort = dyn.effort !== undefined ? effortLevels[dyn.effort] || 'Medium' : (effortLevels[1]);

                // Only Title and Content are required to save a prompt; Project and LLM are optional
                if (!title || !content) {
                    showValidationAlert('Title and Content are required fields.');
                    return;
                }

                const currentTags = [...tagsContainer.querySelectorAll('.prompt-tag span')].map(span => span.textContent);

                let newVersionNumber;
                let promptIdToUse;

                if (selectedVersionId === null) {
                    // CASO 1: Nenhum prompt selecionado (clicou em "Add Prompt").
                    // Sempre cria um novo prompt pai, versão 1.0.
                    promptIdToUse = getUUID();
                    newVersionNumber = '1.0';
                } else {
                    // CASO 2: Um prompt existente está selecionado.
                    const currentPrompt = prompts.find(p => String(p.id) === String(selectedVersionId));
                    promptIdToUse = currentPrompt.promptId;
                    const versionsOfSamePrompt = prompts.filter(p => p.promptId === promptIdToUse);
                    
                    const latestVersion = versionsOfSamePrompt.sort((a, b) => {
                        const [majorA, minorA = 0] = a.version.split('.').map(Number);
                        const [majorB, minorB = 0] = b.version.split('.').map(Number);
                        if (majorA !== majorB) return majorB - majorA;
                        return minorB - minorA;
                    })[0];
                    
                    const [major, minor = 0] = latestVersion.version.split('.').map(Number);

                    if (isMajor) {
                        // Se for "Save Major", incrementa o número principal e zera o secundário.
                        newVersionNumber = `${major + 1}.0`;
                    } else {
                        // Se for "Save New" (minor), incrementa o número secundário.
                        newVersionNumber = `${major}.${(minor || 0) + 1}`;
                    }
                }

                const newVersion = {
                    id: getUUID(),
                    promptId: promptIdToUse, // <-- propriedade atualizada
                    title, project, content,
                    version: newVersionNumber, status: activeStatus, llm, date: new Date().toISOString(), parent_id,
                    dependencies: selectedDepIds,
                    temperature, topP, effort, tags: currentTags, comments,
                    modelSettings: dyn,
                    githubRepo: currentGithubRepo && currentGithubRepo.id ? currentGithubRepo.id : '',
                    githubRepoFull: currentGithubRepo && currentGithubRepo.full ? currentGithubRepo.full : '',
                    githubFilePath: (typeof commitFilePathInput !== 'undefined' && commitFilePathInput?.value) ? commitFilePathInput.value.trim() : (typeof lastImportedGitFilePath !== 'undefined' ? lastImportedGitFilePath : '')
                };

                const rows = await upsertItem('prompts', mapPromptUIToDb(newVersion));
                const saved = rows && rows[0] ? rows[0] : newVersion;
                prompts.push(saved);
                loadVersionIntoEditor(saved.id);
            };
            
            const forkVersion = async () => {
                if (!selectedVersionId) {
                    showValidationAlert('Please select a version to fork.');
                    return;
                }
            
                const originalPrompt = prompts.find(p => String(p.id) === String(selectedVersionId));
                if (!originalPrompt) return;
            
                const newFork = {
                    id: getUUID(),
                    promptId: getUUID(), // Cria um novo grupo (ID de prompt)
                    title: `(Fork) ${originalPrompt.title}`,
                    project: originalPrompt.project,
                    content: originalPrompt.content,
                    version: '1.0',
                    status: 'idea',
                    llm: originalPrompt.llm,
                    date: new Date().toISOString(),
                    parent_id: String(selectedVersionId), // Mantém o link com a versão original
                    temperature: originalPrompt.temperature,
                    topP: originalPrompt.topP,
                    effort: originalPrompt.effort,
                    tags: [...originalPrompt.tags], // Cria uma cópia das tags
                    comments: `Fork of version ${originalPrompt.version}. Original comment: ${originalPrompt.comments || 'None.'}`
                };
            
                const rows = await upsertItem('prompts', mapPromptUIToDb(newFork));
                const saved = rows && rows[0] ? rows[0] : newFork;
                prompts.push(saved);
                savePromptsToStorage();
                loadVersionIntoEditor(saved.id);
            };
            
            const downloadFile = (format) => {
                if (!selectedVersionId) {
                    showValidationAlert('Please select a version to download.');
                    return;
                }
                const version = prompts.find(p => String(p.id) === String(selectedVersionId));
                let content, filename, mimeType;
                if (format === 'json') {
                    content = JSON.stringify(version, null, 2);
                    filename = `${version.title.replace(/ /g, '_')}_v${version.version}.json`;
                    mimeType = 'application/json';
                } else if (format === 'md') {
                    content = `# ${version.title} (v${version.version})\n\n**Project:** ${version.project}\n**Status:** ${version.status}\n**LLM:** ${version.llm}\n**Tags:** ${version.tags.join(', ')}\n**Temperature:** ${version.temperature}\n**Top P:** ${version.topP}\n**Effort:** ${version.effort}\n\n---\n\n${version.content}`;
                    filename = `${version.title.replace(/ /g, '_')}_v${version.version}.md`;
                    mimeType = 'text/markdown';
                } else if (format === 'txt') {
                    content = `${version.title} (v${version.version})\n\nProject: ${version.project}\nStatus: ${version.status}\nLLM: ${version.llm}\nTags: ${version.tags.join(', ')}\nTemperature: ${version.temperature}\nTop P: ${version.topP}\nEffort: ${version.effort}\n\n---\n\n${version.content}`;
                    filename = `${version.title.replace(/ /g, '_')}_v${version.version}.txt`;
                    mimeType = 'text/plain';
                }
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([content], { type: mimeType }));
                a.download = filename;
                a.click();
                URL.revokeObjectURL(a.href);
            };

        const toggleReadMode = () => {
                const isHidden = readModeModal.classList.contains('hidden');
                if (isHidden) {
                    const currentContent = mainEditor.value;
                    let processedContent = currentContent;
                    document.querySelectorAll('#variables-container input').forEach(input => {
                        const varName = input.name;
                        const varValue = input.value || `{{${varName}}}`;
                        processedContent = processedContent.replace(new RegExp(`\\{\\{${varName}\\}\\}`, 'g'), varValue);
                    });

            // Header and metadata
            const currentTitle = titleInput.value || '';
            const currentProject = projectInput.value || '';
            const currentLLM = llmSelect.value || '';
            const currentComments = commentsTextarea.value || '';

            // Stats
            const charCount = processedContent.length;
            const wordCount = processedContent.trim().split(/\s+/).filter(Boolean).length;
            const tokenCount = Math.ceil(charCount / 4);

            document.getElementById('read-mode-title').textContent = currentTitle || '(Untitled)';
            const currentRepoText = (currentGithubRepo && (currentGithubRepo.full || currentGithubRepo.id)) ? (currentGithubRepo.full || currentGithubRepo.id) : 'N/A';
            document.getElementById('read-mode-meta').textContent = `Project: ${currentProject || 'N/A'} · LLM: ${currentLLM || 'N/A'} · Repo: ${currentRepoText}`;
                    document.getElementById('read-mode-stats').textContent = `${tokenCount} tokens / ${wordCount} words / ${charCount} characters`;
            document.getElementById('read-mode-comments').textContent = currentComments ? `Comments: ${currentComments}` : '';

            readModeContent.textContent = processedContent;
                    readModeModal.classList.remove('hidden');
                    mainContent.classList.add('read-mode-blur');
                    mainHeader.style.zIndex = 60; // Traz o header para frente
                    readModeIconClosed.classList.add('hidden');
                    readModeIconOpen.classList.remove('hidden');
                } else {
                    readModeModal.classList.add('hidden');
                    mainContent.classList.remove('read-mode-blur');
                    mainHeader.style.zIndex = 20; // Retorna z-index ao normal
                    readModeIconClosed.classList.remove('hidden');
                    readModeIconOpen.classList.add('hidden');
            document.getElementById('read-mode-title').textContent = '';
            document.getElementById('read-mode-meta').textContent = '';
            document.getElementById('read-mode-stats').textContent = '';
            document.getElementById('read-mode-comments').textContent = '';
                }
            };

            // --- LÓGICA DE BUSCA E SUBSTITUIÇÃO ---
            const toggleFindReplaceBar = (show) => {
                if (show) {
                    findReplaceBar.classList.add('visible');
                    findInput.focus();
                } else {
                    findReplaceBar.classList.remove('visible');
                    mainEditor.focus();
                    // Limpa o estado da busca ao fechar
                    findState = { matches: [], currentIndex: -1, query: '' };
                    updateFindUI();
                }
            };

            const executeFind = () => {
                const query = findInput.value;
                if (!query) {
                    findState = { matches: [], currentIndex: -1, query: '' };
                    updateFindUI();
                    return;
                }
                
                if (query === findState.query) return; // Não busca de novo se a query for a mesma

                const text = mainEditor.value;
                const regex = new RegExp(query, 'gi');
                let match;
                findState.matches = [];
                while ((match = regex.exec(text)) !== null) {
                    findState.matches.push({
                        index: match.index,
                        length: match[0].length
                    });
                }
                findState.query = query;
                findState.currentIndex = findState.matches.length > 0 ? 0 : -1;
                updateFindUI();
                highlightCurrentMatch();
            };

            const updateFindUI = () => {
                const { matches, currentIndex } = findState;
                const total = matches.length;
                
                if (total > 0) {
                    findCounter.textContent = `${currentIndex + 1}/${total}`;
                } else {
                    findCounter.textContent = '0/0';
                }

                nextBtn.disabled = currentIndex >= total - 1;
                prevBtn.disabled = currentIndex <= 0;
                replaceBtn.disabled = total === 0;
                replaceAllBtn.disabled = total === 0;
            };

            const highlightCurrentMatch = () => {
                mainEditor.focus();
                const { matches, currentIndex } = findState;
                if (currentIndex !== -1) {
                    const match = matches[currentIndex];
                    mainEditor.setSelectionRange(match.index, match.index + match.length);
                }
            };

            const goToNextMatch = () => {
                if (findState.currentIndex < findState.matches.length - 1) {
                    findState.currentIndex++;
                    updateFindUI();
                    highlightCurrentMatch();
                }
            };

            const goToPrevMatch = () => {
                if (findState.currentIndex > 0) {
                    findState.currentIndex--;
                    updateFindUI();
                    highlightCurrentMatch();
                }
            };

            const executeReplace = () => {
                const { matches, currentIndex } = findState;
                if (currentIndex === -1) return;

                const replaceText = replaceInput.value;
                const match = matches[currentIndex];
                const originalText = mainEditor.value;

                mainEditor.value = originalText.substring(0, match.index) + replaceText + originalText.substring(match.index + match.length);
                
                // Após substituir, refaz a busca para atualizar os índices e os botões
                executeFind();
                updateSnippetButtons();
            };

            const executeReplaceAll = () => {
                const { matches } = findState;
                if (matches.length === 0) return;

                const findText = findInput.value;
                const replaceText = replaceInput.value;
                const regex = new RegExp(findText, 'gi');
                
                mainEditor.value = mainEditor.value.replace(regex, replaceText);

                // Limpa o estado da busca e atualiza os botões
                executeFind();
                updateSnippetButtons();
            };

            const populateGraphFilters = () => {
                graphProjectFilter.innerHTML = '<option value="all">All Projects</option>';
                const existingProjects = [...new Set(prompts.map(p => p.project).filter(Boolean))].sort();
                existingProjects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project;
                    option.textContent = project;
                    graphProjectFilter.appendChild(option);
                });
            };

            // =================================================================
            // FUNÇÃO DO GRÁFICO DE DEPENDÊNCIAS
            // =================================================================
            const renderDependencyGraph = (filters = {}) => {
                const svg = d3.select("#dependency-graph-svg");
                const container = svg.node().parentElement;
                const width = container.clientWidth;
                const height = container.clientHeight;

                svg.selectAll("*").remove(); 

                let promptsToRender = [...prompts];
                if (filters.project && filters.project !== 'all') {
                    promptsToRender = prompts.filter(p => p.project === filters.project);
                }

                if (promptsToRender.length === 0) {
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height / 2)
                        .attr("text-anchor", "middle")
                        .style("fill", "var(--text-muted-dark)")
                        .text("No prompts to display for the selected filter.");
                    return;
                }

                const nodes = promptsToRender.map(p => ({
                    id: p.id,
                    title: p.title,
                    version: p.version,
                    group: p.promptId,
                    promptData: p 
                }));
                const nodeIds = new Set(nodes.map(n => n.id));

                const links = [];
                prompts.forEach(p => {
                    const depIds = (p.dependencies && p.dependencies.length) ? p.dependencies : (p.parent_id ? [p.parent_id] : []);
                    depIds.forEach(depId => {
                        if (depId !== null && nodeIds.has(p.id) && nodeIds.has(depId)) {
                            links.push({ source: depId, target: p.id });
                        }
                    });
                });

                const simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id).distance(150).strength(0.5))
                    .force("charge", d3.forceManyBody().strength(-400))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("x", d3.forceX(width / 2).strength(0.05))
                    .force("y", d3.forceY(height / 2).strength(0.05));

                const g = svg.append("g");
                
                g.append('defs').append('marker')
                    .attr('id', 'arrowhead')
                    .attr('viewBox', '-0 -5 10 10')
                    .attr('refX', 23)
                    .attr('refY', 0)
                    .attr('orient', 'auto')
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .append('svg:path')
                    .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                    .attr('fill', 'var(--border-dark)');

                const link = g.append("g")
                    .attr("class", "graph-links")
                    .selectAll("line")
                    .data(links)
                    .join("line")
                    .attr("class", "graph-link")
                    .attr("marker-end", "url(#arrowhead)");

                const node = g.append("g")
                    .attr("class", "graph-nodes")
                    .selectAll("g")
                    .data(nodes)
                    .join("g")
                    .attr("class", "graph-node")
                    .call(drag(simulation));

                const color = d3.scaleOrdinal(d3.schemeTableau10);

                node.append("circle")
                    .attr("r", 12)
                    .attr("fill", d => color(d.group));

                node.append("text")
                    .text(d => `${d.title} v${d.version}`)
                    .attr('y', -20);

                node.on('mouseover', (event, d) => {
                    const promptData = d.promptData;
                    graphTooltip.style.opacity = 1;
            graphTooltip.innerHTML = `
                        <h3 class="font-bold text-base mb-2 truncate" style="color: var(--accent-fuchsia);">${promptData.title}</h3>
                        <div class="space-y-1">
                <p><strong class="text-[--text-muted-dark] font-normal">Project:</strong> ${S(promptData.project || 'N/A')}</p>
                <p><strong class="text-[--text-muted-dark] font-normal">LLM:</strong> ${S(promptData.llm || 'N/A')}</p>
                        </div>
                        <div class="mt-3 pt-2 border-t border-[--border-dark] grid grid-cols-3 gap-2 text-center font-mono">
                <div><p class="text-[--text-muted-dark] text-xs">Temp</p><p class="font-semibold text-sm">${S(promptData.temperature)}</p></div>
                <div><p class="text-[--text-muted-dark] text-xs">Top P</p><p class="font-semibold text-sm">${S(promptData.topP)}</p></div>
                <div><p class="text-[--text-muted-dark] text-xs">Effort</p><p class="font-semibold text-sm">${S(promptData.effort)}</p></div>
                        </div>
                    `;
                    const svgRect = svg.node().getBoundingClientRect();
                    graphTooltip.style.left = (event.clientX - svgRect.left + 15) + 'px';
                    graphTooltip.style.top = (event.clientY - svgRect.top + 15) + 'px';
                })
                .on('mouseout', () => {
                    graphTooltip.style.opacity = 0;
                });

                node.on("click", async (event, d) => {
                    if (isCreatingConnection) {
                        if (!firstNodeForConnection) {
                            firstNodeForConnection = d;
                            d3.select(event.currentTarget).classed('selected-for-connection', true);
                        } else {
                            if (firstNodeForConnection.id !== d.id) {
                                const childPrompt = prompts.find(p => p.id === d.id);
                                if (childPrompt) {
                                    // Ensure dependencies array exists and add the new dependency if not present
                                    if (!Array.isArray(childPrompt.dependencies)) childPrompt.dependencies = [];
                                    if (!childPrompt.dependencies.includes(firstNodeForConnection.id)) {
                                        childPrompt.dependencies.push(firstNodeForConnection.id);
                                    }
                                    // Keep parent_id in sync if exactly one dependency
                                    childPrompt.parent_id = (childPrompt.dependencies.length === 1) ? childPrompt.dependencies[0] : null;
                                    savePromptsToStorage();
                                    renderDependencyGraph({ project: graphProjectFilter.value });
                                    await upsertItem('prompts', mapPromptUIToDb(childPrompt));
                                    if (selectedVersionId && String(selectedVersionId) === String(childPrompt.id)) {
                                        renderDependencyBar(childPrompt.dependencies);
                                    }
                                }
                            }
                            isCreatingConnection = false;
                            firstNodeForConnection = null;
                            createConnectionBtn.classList.remove('active');
                            d3.selectAll('.graph-node').classed('selected-for-connection', false);
                        }
                    } else {
                        loadVersionIntoEditor(d.id);
                        dependencyGraphModal.classList.add('hidden');
                    }
                });

                link.on('click', (event, d) => {
                    event.stopPropagation();
                    link.classed('selected', false);
                    d3.select(event.currentTarget).classed('selected', true);
                    selectedLinkForDeletion = d;
                    deleteConnectionBtn.disabled = false;
                });

                svg.on('click', () => {
                    link.classed('selected', false);
                    selectedLinkForDeletion = null;
                    deleteConnectionBtn.disabled = true;
                });

                simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node.attr("transform", d => `translate(${d.x},${d.y})`);
                });

                svg.call(d3.zoom().on("zoom", (event) => {
                    g.attr("transform", event.transform);
                }));

                function drag(simulation) {
                    function dragstarted(event, d) {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        d.fx = d.x; d.fy = d.y;
                    }
                    function dragged(event, d) {
                        d.fx = event.x; d.fy = event.y;
                    }
                    function dragended(event, d) {
                        if (!event.active) simulation.alphaTarget(0);
                        d.fx = null; d.fy = null;
                    }
                    return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
                }
            };

            // --- LÓGICA DO SNIPPET COPY (NOVO) ---
            const updateSnippetButtons = () => {
                snippetButtonsOverlay.innerHTML = '';
                snippets = [];
                const text = mainEditor.value;
                
                const openTags = [];
                const tagRegex = /<(\/)?([a-zA-Z][\w-]*)/g;
                let match;

                while ((match = tagRegex.exec(text)) !== null) {
                    const isClosing = match[1] === '/';
                    const tagName = match[2];
                    const tagIndex = match.index;

                    if (isClosing) {
                        for (let i = openTags.length - 1; i >= 0; i--) {
                            if (openTags[i].name === tagName && !openTags[i].closed) {
                                openTags[i].closed = true;
                                const blockStartIndex = openTags[i].index;
                                const blockEndIndex = tagIndex + match[0].length + 1;
                                const blockContent = text.substring(blockStartIndex, blockEndIndex);
                                
                                const textUpToStart = text.substring(0, blockStartIndex);
                                const startLineNumber = textUpToStart.split('\n').length - 1;

                                snippets.push({ content: blockContent, tagName });
                                const snippetIndex = snippets.length - 1;

                                // Holder to place both Copy and Save buttons side-by-side
                                const holder = document.createElement('div');
                                holder.className = 'snippet-btn-holder';

                                const copyBtn = document.createElement('button');
                                copyBtn.className = 'copy-snippet-btn';
                                copyBtn.title = 'Copy XML snippet';
                                copyBtn.dataset.snippetIndex = snippetIndex;
                                copyBtn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>`;

                                const saveBtn = document.createElement('button');
                                saveBtn.className = 'save-snippet-btn';
                                saveBtn.title = 'Save XML snippet';
                                saveBtn.dataset.snippetIndex = snippetIndex;
                                // Save icon (arrow into tray)
                                saveBtn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5m0 0l5-5m-5 5V4"/></svg>`;

                                // Attach buttons then position by top + right
                                holder.appendChild(copyBtn);
                                holder.appendChild(saveBtn);
                                const scrollTop = mainEditor.scrollTop;
                                const topPx = measureTopForIndex(text, blockStartIndex);
                                holder.style.top = `${topPx - scrollTop}px`;
                                // Right anchor with scrollbar compensation so the holder stays visible
                                try {
                                    const scW = Math.max(0, mainEditor.offsetWidth - mainEditor.clientWidth);
                                    holder.style.right = (16 + scW) + 'px';
                                } catch { holder.style.right = '16px'; }
                                // Ensure holder is added to the overlay
                                snippetButtonsOverlay.appendChild(holder);
                                break; 
                            }
                        }
                    } else {
                        openTags.push({ name: tagName, index: tagIndex, closed: false });
                    }
                }
            };

            const renderPromptTags = (tags = []) => {
                tagsContainer.innerHTML = '';
                const projectTag = `#${projectInput.value.trim().toLowerCase().replace(/\s+/g, '-')}`;
                const llmTag = `#${llmSelect.value.toLowerCase()}`;
                
                if (projectInput.value.trim()) {
                    tagsContainer.appendChild(createTagEl(projectTag, true));
                }
                if (llmSelect.value) {
                    tagsContainer.appendChild(createTagEl(llmTag, true));
                }

                tags.forEach(tag => {
                    if (tag !== projectTag && tag !== llmTag) {
                        const tagEl = createTagEl(tag, false);
                        tagsContainer.appendChild(tagEl);
                    }
                });
            };

            const createTagEl = (tag, isAuto) => {
                const tagEl = document.createElement('div');
                tagEl.className = isAuto ? 'prompt-tag auto-tag' : 'prompt-tag';
                let html = `<span>${S(tag)}</span>`;
                if (!isAuto) {
                    html += `<button class="remove-tag-btn" data-tag="${escapeAttr(tag)}">&times;</button>`;
                }
                tagEl.innerHTML = html;
                return tagEl;
            };

            const getAllUniqueTags = () => {
                const allTags = new Set();
                prompts.forEach(p => {
                    if (p.tags) {
                        p.tags.forEach(tag => allTags.add(tag));
                    }
                });
                return [...allTags].sort();
            }

            const renderNavigationMap = () => {
                const content = mainEditor.value;
                const xmlTagRegex = /<([a-zA-Z][\w-]*)/g;
                let match;
                const tags = [];

                while ((match = xmlTagRegex.exec(content)) !== null) {
                    tags.push({
                        name: match[1],
                        index: match.index
                    });
                }

                if (tags.length === 0) {
                    navigationMap.innerHTML = '';
                    navigationMap.classList.add('hidden');
                    return;
                }

                navigationMap.innerHTML = '<span class="text-xs font-bold text-[--text-muted-dark] self-center">Quick Nav:</span>';
                tags.forEach(tag => {
                    const tagEl = document.createElement('button');
                    tagEl.className = 'nav-map-tag';
                    tagEl.textContent = tag.name;
                    tagEl.dataset.index = tag.index;
                    navigationMap.appendChild(tagEl);
                });
                navigationMap.classList.remove('hidden');
            };

            // --- Drawer list renderers ---
            const setSelectedClass = (container, selector) => {
                if (!container) return;
                container.querySelectorAll('.drawer-row').forEach(el => el.classList.remove('selected'));
                const sel = selector ? container.querySelector(selector) : null;
                if (sel) sel.classList.add('selected');
            };

            const renderProjectListDrawer = () => {
                if (!projectListDrawer) return;
                projectListDrawer.innerHTML = '';
                const q = (document.getElementById('project-search-input')?.value || '').toLowerCase();
                const projects = Array.from(new Set(prompts.map(p => p.project).filter(Boolean).concat(projectNames)))
                    .filter(n => !q || n.toLowerCase().includes(q))
                    .sort();
                projects.forEach(name => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = name;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${S(name)}</span>`;
                    row.addEventListener('click', () => {
                        const current = projectListDrawer.querySelector('.drawer-row.selected');
                        const isSame = current && current.dataset.value === name;
                        if (isSame) {
                            projectInput.value = '';
                            setSelectedClass(projectListDrawer, null);
                        } else {
                            projectInput.value = name;
                            renderPromptTags([...tagsContainer.querySelectorAll('.prompt-tag:not(.auto-tag) span')].map(s => s.textContent));
                            setSelectedClass(projectListDrawer, `[data-value=\"${CSS.escape(name)}\"]`);
                        }
                    });
                    projectListDrawer.appendChild(row);
                });
                if (projectInput && projectInput.value) setSelectedClass(projectListDrawer, `[data-value="${CSS.escape(projectInput.value)}"]`);
            };

            // GitHub panel: repos list and project assignment
            const githubListDrawer = document.getElementById('github-list-drawer');
            const githubAssignHint = document.getElementById('github-assign-hint');
            const renderGithubListDrawer = () => {
                if (!githubListDrawer) return;
                githubListDrawer.innerHTML = '';
                let repos = [];
                try { repos = JSON.parse(localStorage.getItem('github_repo_list') || '[]'); } catch {}
                const q = (document.getElementById('github-search-input')?.value || '').toLowerCase();
                const activeProject = (document.getElementById('project-name-input-aside')?.value || '').trim();
                if (githubAssignHint) {
                    githubAssignHint.textContent = activeProject ? `Assign a repository to project: ${activeProject}` : 'Select a project first in the Project panel to assign a repository.';
                }
                repos
                    .map(r => ({ id: r.id, label: r.repo || r.id }))
                    .filter(r => !q || r.label.toLowerCase().includes(q))
                    .sort((a,b) => a.label.localeCompare(b.label))
                    .forEach(({ id, label }) => {
                        const row = document.createElement('div');
                        row.className = 'drawer-row';
                        row.dataset.value = id;
                        row.innerHTML = `<span class="truncate text-sm font-mono">${S(label)}</span>`;
                        const isSelected = activeProject && projectRepoMap[activeProject] === id;
                        if (isSelected) row.classList.add('selected');
                        row.addEventListener('click', () => {
                            if (!activeProject) return;
                            projectRepoMap[activeProject] = id;
                            saveProjectRepoMapToStorage();
                            try { updateGlobalList('project_repo_map', projectRepoMap); } catch {}
                            renderGithubListDrawer();
                        });
                        githubListDrawer.appendChild(row);
                    });
            };

            // Persisted expanded state for LLM groups
            let expandedLlmGroups = new Set();

            const renderLlmListDrawer = () => {
                if (!llmListDrawer) return;
                llmListDrawer.innerHTML = '';
                const q = (document.getElementById('llm-search-input')?.value || '').toLowerCase();
                // Helper to add a row
                const addRow = (label, value) => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = value;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${S(label)}</span>`;
                    row.addEventListener('click', () => {
                        const current = llmListDrawer.querySelector('.drawer-row.selected');
                        const isSame = current && current.dataset.value === value;
                        if (isSame) {
                            llmSelect.value = '';
                            llmSelect.dispatchEvent(new Event('change'));
                            setSelectedClass(llmListDrawer, ``);
                        } else {
                            llmSelect.value = value;
                            llmSelect.dispatchEvent(new Event('change'));
                            setSelectedClass(llmListDrawer, `[data-value=\"${CSS.escape(value)}\"]`);
                        }
                    });
                    llmListDrawer.appendChild(row);
                };

                // No special generic row; the empty selection is represented by no value

                // Groups
                const groups = Object.keys(llmList).sort();
                groups.forEach(group => {
                    const models = (llmList[group] || []).slice().sort();
                    const groupMatches = !q || group.toLowerCase().includes(q);
                    const groupModels = models.filter(m => !q || m.toLowerCase().includes(q));
                    if (!groupMatches && groupModels.length === 0) return;
                    const groupContainer = document.createElement('div');
                    groupContainer.className = 'mb-1';

                    const header = document.createElement('div');
                    header.className = 'prompt-group-header flex items-center justify-between';
                    header.innerHTML = `
                        <div class="flex items-center gap-2">
                            <span class="toggle-icon">▶</span>
                            <span class="text-xs font-semibold text-[--text-muted-dark]">${group}</span>
                        </div>
                    `;
                    groupContainer.appendChild(header);

                    const list = document.createElement('div');
                    list.className = 'space-y-1 pl-6 mt-1';
                    groupContainer.appendChild(list);

                    // Expand logic: maintain state and auto-expand when searching
                    let isExpanded = expandedLlmGroups.has(group) || (!!q && (groupMatches || groupModels.length > 0));
                    const applyExpand = () => {
                        header.classList.toggle('expanded', isExpanded);
                        header.querySelector('.toggle-icon').textContent = isExpanded ? '▼' : '▶';
                        list.style.display = isExpanded ? '' : 'none';
                    };
                    applyExpand();

                    header.addEventListener('click', () => {
                        isExpanded = !isExpanded;
                        if (isExpanded) expandedLlmGroups.add(group); else expandedLlmGroups.delete(group);
                        applyExpand();
                    });

                    groupModels.forEach(model => list.appendChild((() => { const tmp = document.createElement('div'); addRow(model, model); return llmListDrawer.lastChild; })()));

                    llmListDrawer.appendChild(groupContainer);
                });

                if (llmSelect && llmSelect.value) setSelectedClass(llmListDrawer, `[data-value=\"${CSS.escape(llmSelect.value)}\"]`);
            };

            const renderTagsListDrawer = () => {
                if (!tagsListDrawer) return;
                tagsListDrawer.innerHTML = '';
                // union of used tags and library-only general tags
                const GENERAL_TAGS_LIB_KEY = 'promptManagerApp_generalTagsLib';
                let generalTagsLib = [];
                try { generalTagsLib = JSON.parse(localStorage.getItem(GENERAL_TAGS_LIB_KEY) || '[]'); } catch {}
                const q = (document.getElementById('tags-search-input')?.value || '').toLowerCase();
                const all = Array.from(new Set([...getAllUniqueTags(), ...generalTagsLib]))
                    .filter(t => !q || t.toLowerCase().includes(q))
                    .sort();
                const currentTags = new Set([...tagsContainer.querySelectorAll('.prompt-tag:not(.auto-tag) span')].map(s => s.textContent));
                all.forEach(tag => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = tag;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${S(tag)}</span>`;
                    const isSelected = currentTags.has(tag);
                    if (isSelected) row.classList.add('selected');
                    row.addEventListener('click', () => {
                        if (currentTags.has(tag)) {
                            // remove from chips
                            const chip = Array.from(tagsContainer.querySelectorAll('.prompt-tag:not(.auto-tag)')).find(div => div.querySelector('span')?.textContent === tag);
                            if (chip) chip.remove();
                            currentTags.delete(tag);
                            row.classList.remove('selected');
                            if (currentTags.size === 0) { /* no-op: dock highlight removed */ }
                        } else {
                            const tagEl = createTagEl(tag, false);
                            tagsContainer.appendChild(tagEl);
                            currentTags.add(tag);
                            row.classList.add('selected');
                            /* dock highlight removed */
                        }
                    });
                    tagsListDrawer.appendChild(row);
                });
            };

            const renderXmlTagsListDrawer = () => {
                if (!xmlTagsListDrawer) return;
                xmlTagsListDrawer.innerHTML = '';
                const q = (document.getElementById('xml-search-input')?.value || '').toLowerCase();
                xmlTags.slice().filter(t => !q || t.toLowerCase().includes(q)).sort().forEach(tag => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = tag;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${S(tag)}</span>`;
                    row.addEventListener('click', () => {
                        const current = xmlTagsListDrawer.querySelector('.drawer-row.selected');
                        const isSame = current && current.dataset.value === tag;
                        if (isSame) {
                            setSelectedClass(xmlTagsListDrawer, null);
                        } else {
                            const start = mainEditor.selectionStart;
                            const end = mainEditor.selectionEnd;
                            const text = mainEditor.value;
                            const selectedText = text.substring(start, end);
                            const tagText = selectedText ? `<${tag}>\n${selectedText}\n</${tag}>` : `<${tag}>\n\n</${tag}>`;
                            const newCursorPosition = start + (selectedText ? tagText.length : tag.length + 3);
                            mainEditor.value = text.substring(0, start) + tagText + text.substring(end);
                            mainEditor.focus();
                            mainEditor.setSelectionRange(newCursorPosition, newCursorPosition);
                            mainEditor.dispatchEvent(new Event('input', { bubbles: true }));
                            setSelectedClass(xmlTagsListDrawer, `[data-value=\"${CSS.escape(tag)}\"]`);
                        }
                    });
                    xmlTagsListDrawer.appendChild(row);
                });
            };

            const renderVarLibraryListDrawer = () => {
                if (!varLibraryListDrawer) return;
                varLibraryListDrawer.innerHTML = '';
                const q = (document.getElementById('var-search-input')?.value || '').toLowerCase();
                varLibrary.slice().filter(v => !q || v.toLowerCase().includes(q)).sort().forEach(v => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = v;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${S(v)}</span>`;
                    row.addEventListener('click', () => {
                        const current = varLibraryListDrawer.querySelector('.drawer-row.selected');
                        const isSame = current && current.dataset.value === v;
                        if (isSame) {
                            setSelectedClass(varLibraryListDrawer, null);
                        } else {
                            const start = mainEditor.selectionStart;
                            const end = mainEditor.selectionEnd;
                            const text = mainEditor.value;
                            mainEditor.value = text.substring(0, start) + v + text.substring(end);
                            mainEditor.focus();
                            mainEditor.setSelectionRange(start + v.length, start + v.length);
                            mainEditor.dispatchEvent(new Event('input', { bubbles: true }));
                            setSelectedClass(varLibraryListDrawer, `[data-value=\"${CSS.escape(v)}\"]`);
                        }
                    });
                    varLibraryListDrawer.appendChild(row);
                });
            };

            const renderAddInputListDrawer = () => {
                if (!addInputListDrawer) return;
                addInputListDrawer.innerHTML = '';
                const q = (document.getElementById('input-search-input')?.value || '').toLowerCase();
                inputGallery.slice().filter(i => !q || i.name.toLowerCase().includes(q)).sort((a,b) => a.name.localeCompare(b.name)).forEach(item => {
                    const row = document.createElement('div');
                    row.className = 'drawer-row';
                    row.dataset.value = item.id;
                    row.innerHTML = `<span class="truncate text-sm font-mono">${S(item.name)}</span>`;
                    row.addEventListener('click', () => {
                        const current = addInputListDrawer.querySelector('.drawer-row.selected');
                        const isSame = current && current.dataset.value === String(item.id);
                        if (isSame) {
                            setSelectedClass(addInputListDrawer, null);
                        } else {
                            const content = item.content;
                            const start = mainEditor.selectionStart;
                            const end = mainEditor.selectionEnd;
                            const text = mainEditor.value;
                            mainEditor.value = text.substring(0, start) + content + text.substring(end);
                            mainEditor.focus();
                            mainEditor.setSelectionRange(start + content.length, start + content.length);
                            mainEditor.dispatchEvent(new Event('input', { bubbles: true }));
                            setSelectedClass(addInputListDrawer, `[data-value=\"${CSS.escape(item.id)}\"]`);
                        }
                    });
                    addInputListDrawer.appendChild(row);
                });
            };

            // Removed dock icon highlight behavior per request.

            // --- Drawer searches and add actions ---
            // Search inputs
            const projectSearchEl = document.getElementById('project-search-input');
            if (projectSearchEl) projectSearchEl.addEventListener('input', renderProjectListDrawer);
            const llmSearchEl = document.getElementById('llm-search-input');
            if (llmSearchEl) llmSearchEl.addEventListener('input', renderLlmListDrawer);
            const githubSearchEl = document.getElementById('github-search-input');
            if (githubSearchEl) githubSearchEl.addEventListener('input', renderGithubListDrawer);
            const tagsSearchEl = document.getElementById('tags-search-input');
            if (tagsSearchEl) tagsSearchEl.addEventListener('input', renderTagsListDrawer);
            const xmlSearchEl = document.getElementById('xml-search-input');
            if (xmlSearchEl) xmlSearchEl.addEventListener('input', renderXmlTagsListDrawer);
            const varSearchEl = document.getElementById('var-search-input');
            if (varSearchEl) varSearchEl.addEventListener('input', renderVarLibraryListDrawer);
            const inputSearchEl = document.getElementById('input-search-input');
            if (inputSearchEl) inputSearchEl.addEventListener('input', renderAddInputListDrawer);

            // Add buttons
            const projectAddBtn = document.getElementById('project-add-btn');
            if (projectAddBtn) projectAddBtn.addEventListener('click', () => {
                const name = (prompt('New project name:') || '').trim();
                if (!name) return;
                if (!projectNames.includes(name)) {
                    projectNames.push(name);
                    saveProjectNamesToStorage();
                    updateGlobalList('projects', projectNames);
                }
                // Update hidden datalist so imports and others see it immediately
                const datalist = document.getElementById('project-list-aside');
                if (datalist) {
                    const exists = [...datalist.options].some(o => o.value === name);
                    if (!exists) {
                        const opt = document.createElement('option');
                        opt.value = name;
                        datalist.appendChild(opt);
                    }
                }
                renderProjectListDrawer();
            });

            const tagsAddBtn = document.getElementById('tags-add-btn');
            if (tagsAddBtn) tagsAddBtn.addEventListener('click', () => {
                let tag = (prompt('New tag (with or without #):') || '').trim();
                if (!tag) return;
                if (!tag.startsWith('#')) tag = `#${tag}`;
                const GENERAL_TAGS_LIB_KEY = 'promptManagerApp_generalTagsLib';
                let generalTagsLib = [];
                try { generalTagsLib = JSON.parse(localStorage.getItem(GENERAL_TAGS_LIB_KEY) || '[]'); } catch {}
                if (!generalTagsLib.includes(tag)) {
                    generalTagsLib.push(tag);
                    try { localStorage.setItem(GENERAL_TAGS_LIB_KEY, JSON.stringify(generalTagsLib)); } catch {}
                    updateGlobalList('general_tags_library', generalTagsLib);
                }
                renderTagsListDrawer();
            });

            // --- LÓGICA DO GERENCIADOR DE LISTAS ---
            // Persisted expanded state for LLM groups inside List Manager
            let expandedLlmManagerGroups = new Set();

            const renderListManager = () => {
                xmlTagsManagerContainer.innerHTML = '';
                varLibraryManagerContainer.innerHTML = '';
                generalTagsManagerContainer.innerHTML = '';
                llmManagerContainer.innerHTML = '';

                const createManagerItemEl = (value, type, options = {}) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'manager-tag flex justify-between items-center';
                    itemEl.dataset.value = value;
                    itemEl.dataset.type = type;
                    if (options.category) {
                        itemEl.dataset.category = options.category;
                    }
                    itemEl.innerHTML = `
                        <span class="truncate" contenteditable="true">${S(value)}</span>
                        <button class="remove-tag-btn p-1">&times;</button>
                    `;
                    return itemEl;
                };

                xmlTags.sort().forEach(tag => xmlTagsManagerContainer.appendChild(createManagerItemEl(tag, 'xml')));
                varLibrary.sort().forEach(tag => varLibraryManagerContainer.appendChild(createManagerItemEl(tag, 'var')));
                // Combine used tags with library-only general tags so newly added appear immediately
                const GENERAL_TAGS_LIB_KEY = 'promptManagerApp_generalTagsLib';
                let generalTagsLib = [];
                try { generalTagsLib = JSON.parse(localStorage.getItem(GENERAL_TAGS_LIB_KEY) || '[]'); } catch {}
                const combinedGeneral = Array.from(new Set([...
                    getAllUniqueTags(),
                    ...generalTagsLib
                ])).sort();
                combinedGeneral.forEach(tag => generalTagsManagerContainer.appendChild(createManagerItemEl(tag, 'general')));

                Object.keys(llmList).sort().forEach(category => {
                    const categoryContainer = document.createElement('div');
                    categoryContainer.className = 'mb-3';
                    
                    const categoryHeader = document.createElement('div');
                    categoryHeader.className = 'manager-tag flex justify-between items-center font-bold bg-[#2a2a2a]';
                    categoryHeader.dataset.value = category;
                    categoryHeader.dataset.type = 'llm-category';
                    categoryHeader.innerHTML = `
                        <span class="toggle-icon">▶</span>
                        <span class="truncate" contenteditable="true">${S(category)}</span>
                        <button class="remove-tag-btn p-1">&times;</button>
                    `;
                    
                    const modelsContainer = document.createElement('div');
                    modelsContainer.className = 'pl-2 mt-2 space-y-2';
                    
                    llmList[category].sort().forEach(model => {
                        modelsContainer.appendChild(createManagerItemEl(model, 'llm-model', { category }));
                    });
                    // Toggle expand/collapse state per category
                    let isExpanded = expandedLlmManagerGroups.has(category);
                    const applyExpand = () => {
                        const caret = categoryHeader.querySelector('.toggle-icon');
                        if (caret) caret.textContent = isExpanded ? '▼' : '▶';
                        modelsContainer.style.display = isExpanded ? '' : 'none';
                    };
                    applyExpand();
                    categoryHeader.addEventListener('click', (ev) => {
                        const isRemove = ev.target && ev.target.closest('.remove-tag-btn');
                        const isEditing = ev.target && ev.target.matches('[contenteditable="true"]');
                        if (isRemove || isEditing) return; // don't toggle when deleting or editing name
                        isExpanded = !isExpanded;
                        if (isExpanded) expandedLlmManagerGroups.add(category); else expandedLlmManagerGroups.delete(category);
                        applyExpand();
                    });
                    
                    categoryContainer.appendChild(categoryHeader);
                    categoryContainer.appendChild(modelsContainer);
                    llmManagerContainer.appendChild(categoryContainer);
                });
            };

            const updateListItem = (type, oldVal, newVal, options = {}) => {
                if (!newVal || oldVal === newVal) return;

        if (type === 'xml') {
                    const index = xmlTags.indexOf(oldVal);
                    if (index > -1 && !xmlTags.includes(newVal)) {
                        xmlTags[index] = newVal;
            saveXmlTagsToStorage();
            // Persist XML tags rename to Supabase
            updateGlobalList('xml_tags', xmlTags);
                    }
                } else if (type === 'var') {
                    const index = varLibrary.indexOf(oldVal);
                    if (index > -1 && !varLibrary.includes(newVal)) {
                        varLibrary[index] = newVal;
            saveVarLibraryToStorage();
            // Persist Var Library rename to Supabase
            updateGlobalList('var_library', varLibrary);
                    }
                } else if (type === 'general') {
                    prompts.forEach(p => {
                        if (p.tags && p.tags.includes(oldVal)) {
                            p.tags = p.tags.map(t => t === oldVal ? newVal : t);
                        }
                    });
                    savePromptsToStorage();
                    try { upsertItem('prompts', prompts.map(mapPromptUIToDb)); } catch (e) { console.error('Supabase upsert failed for prompts (general rename):', e); }
                } else if (type === 'llm-category') {
                    if (llmList[oldVal] && !llmList[newVal]) {
                        llmList[newVal] = llmList[oldVal];
                        delete llmList[oldVal];
                        saveLlmListToStorage();
                        updateGlobalList('llm_list', llmList);
                        populateLlmSelect();
                    }
                } else if (type === 'llm-model') {
                    const { category } = options;
                    if (llmList[category]) {
                        const index = llmList[category].indexOf(oldVal);
                        if (index > -1 && !llmList[category].includes(newVal)) {
                            llmList[category][index] = newVal;
                            prompts.forEach(p => { if (p.llm === oldVal) p.llm = newVal; });
                            saveLlmListToStorage();
                            // Persist updated llmList to Supabase
                            updateGlobalList('llm_list', llmList);
                            savePromptsToStorage();
                            try { upsertItem('prompts', prompts.map(mapPromptUIToDb)); } catch (e) { console.error('Supabase upsert failed for prompts (llm-model rename):', e); }
                            populateLlmSelect();
                        }
                    }
                }
                renderListManager();
            };

            // --- LÓGICA DA GALERIA DE INPUTS ---
            const renderInputGallery = () => {
                inputGalleryList.innerHTML = '';
                const selectedProject = (typeof inputGalleryProjectFilter !== 'undefined' && inputGalleryProjectFilter) ? inputGalleryProjectFilter.value : 'all';
                const list = inputGallery
                    .filter(i => selectedProject === 'all' ? true : (i.project || '') === selectedProject)
                    .sort((a,b) => a.name.localeCompare(b.name));
                list.forEach(input => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'input-gallery-item';
                    itemEl.dataset.id = input.id;
                    if(input.id === selectedInputId) {
                        itemEl.classList.add('selected');
                    }
                    itemEl.innerHTML = `
                        <span class="truncate flex-grow">${S(input.name)}</span>
                        ${input.project ? `<span class=\"ml-2 text-xs text-[--text-muted-dark]\">${S(input.project)}</span>` : ''}
                        <button class="remove-btn p-1" data-action="delete-input" data-id="${escapeAttr(String(input.id))}">
                            <svg class="w-4 h-4 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    `;
                    inputGalleryList.appendChild(itemEl);
                });
            };

            const clearInputEditor = () => {
                selectedInputId = null;
                inputGalleryId.value = '';
                inputGalleryName.value = '';
                inputGalleryEditor.value = '';
                if (inputGalleryProjectAssign) populateProjectAssignList(inputGalleryProjectAssign);
                if (inputGalleryProjectAssign) {
                    const currentFilter = (inputGalleryProjectFilter && inputGalleryProjectFilter.value) ? inputGalleryProjectFilter.value : 'all';
                    inputGalleryProjectAssign.value = currentFilter === 'all' ? '' : currentFilter;
                }
                inputGalleryName.focus();
                renderInputGallery();
            };

            const loadInputForEditing = (id) => {
                const input = inputGallery.find(i => i.id === id);
                if (input) {
                    selectedInputId = id;
                    inputGalleryId.value = input.id;
                    inputGalleryName.value = input.name;
                    inputGalleryEditor.value = input.content;
                    if (inputGalleryProjectAssign) {
                        populateProjectAssignList(inputGalleryProjectAssign);
                        inputGalleryProjectAssign.value = input.project || '';
                    }
                    renderInputGallery();
                }
            };

            const saveCurrentInput = async () => {
                const name = inputGalleryName.value.trim();
                const content = inputGalleryEditor.value.trim();
                const project = inputGalleryProjectAssign ? (inputGalleryProjectAssign.value || '') : '';
                const currentId = selectedInputId;

                if (!name || !content) {
                    showModal('Error', 'Input name and content cannot be empty.', [{ text: 'OK', className: 'action-button primary', onClick: hideModal }]);
                    return;
                }

                let itemToSave;

                if (currentId) { // Editando um existente
                    const index = inputGallery.findIndex(i => i.id === currentId);
                    if (index > -1) {
                        inputGallery[index].name = name;
                        inputGallery[index].content = content;
                        inputGallery[index].project = project;
                        itemToSave = inputGallery[index];
                    }
                } else { // Criando um novo
                    const newId = getUUID();
                    itemToSave = { id: newId, name, content, project };
                    inputGallery.push(itemToSave);
                    selectedInputId = newId;
                }
                
                if (itemToSave) {
                    // Persist only supported columns to DB; keep project only in local cache/UI
                    const dbRow = { id: itemToSave.id, name: itemToSave.name, content: itemToSave.content };
                    const rows = await upsertItem('input_gallery', dbRow);
                    let ok = Array.isArray(rows) && rows.length > 0;
                    if (!ok) {
                        try { await loadDataFromSupabase(); } catch {}
                        ok = (inputGallery || []).some(i => String(i.id) === String(itemToSave.id));
                    }
                    if (!ok) {
                        showModal('Save failed', 'Could not save input to Supabase. Check your connection and authentication.', [
                            { text: 'OK', className: 'action-button primary', onClick: hideModal }
                        ]);
                        return;
                    }
                    // If rows returned, merge canonical DB row back; otherwise local item already synced via reload
                    if (Array.isArray(rows) && rows.length > 0) {
                        const saved = rows[0];
                        const idx = inputGallery.findIndex(i => i.id === saved.id);
                        if (idx !== -1) inputGallery[idx] = { ...inputGallery[idx], ...saved };
                    }
                }

                saveInputGalleryToStorage();
                // Track new project names
                if (project && !projectNames.includes(project)) {
                    projectNames.push(project);
                    saveProjectNamesToStorage();
                    updateGlobalList('projects', projectNames);
                }
                // Refresh filter options after a possible new project
                if (inputGalleryProjectFilter) {
                    const prev = inputGalleryProjectFilter.value;
                    populateProjectList(inputGalleryProjectFilter);
                    inputGalleryProjectFilter.value = prev;
                }
                renderInputGallery();
            };

            const deleteInputFromGallery = async (id) => {
                // Deleta primeiro do Supabase
                await deleteItem('input_gallery', id);

                // Depois atualiza o estado local
                inputGallery = inputGallery.filter(i => i.id !== id);
                saveInputGalleryToStorage();
                
                if (selectedInputId === id) {
                    clearInputEditor();
                } else {
                    renderInputGallery();
                }
            };

            // --- LÓGICA DO NODE FLOW ---
            // Runtime state (per open flow)
            let flowMode = 'runall'; // 'bypass' | 'runall'
            let nodeRuntime = new Map(); // nodeId -> { status: 'idle'|'pending'|'running'|'success'|'error', response: string, pinned: boolean }
            let bypassCursor = 0; // index in topologically sorted order
            const PIN_STORAGE_KEY = 'promptManagerApp_flowPins';
            function loadPins() {
                try { return JSON.parse(localStorage.getItem(PIN_STORAGE_KEY) || '{}'); } catch { return {}; }
            }
            function savePins(pins) { try { localStorage.setItem(PIN_STORAGE_KEY, JSON.stringify(pins)); } catch {} }
            function setNodeStatus(nodeId, status) {
                const el = document.querySelector(`#flow-node-${CSS.escape(nodeId)} [data-status]`);
                if (!el) return;
                el.classList.remove('idle','pending','running','success','error');
                el.classList.add(status);
                el.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                const st = nodeRuntime.get(nodeId) || {}; st.status = status; nodeRuntime.set(nodeId, st);
            }
            function getParents(nodeId) {
                return flowConnections.filter(c => c.target === nodeId).map(c => c.source);
            }
            function topologicalOrder() {
                // Kahn's algorithm
                const inDeg = new Map(flowNodes.map(n => [n.id, 0]));
                flowConnections.forEach(c => inDeg.set(c.target, (inDeg.get(c.target)||0)+1));
                const q = [];
                inDeg.forEach((deg, id) => { if (deg === 0) q.push(id); });
                const order = [];
                const adj = new Map();
                flowConnections.forEach(c => { if (!adj.has(c.source)) adj.set(c.source, []); adj.get(c.source).push(c.target); });
                while (q.length) {
                    const u = q.shift(); order.push(u);
                    (adj.get(u)||[]).forEach(v => { inDeg.set(v, inDeg.get(v)-1); if (inDeg.get(v)===0) q.push(v); });
                }
                // include isolated nodes
                flowNodes.forEach(n => { if (!order.includes(n.id)) order.push(n.id); });
                return order;
            }
            function renderNodeBadgesFromPins() {
                const pins = loadPins();
                flowNodes.forEach(n => {
                    const st = nodeRuntime.get(n.id) || { status: 'idle' };
                    st.pinned = !!pins[n.id];
                    nodeRuntime.set(n.id, st);
                    const nodeEl = document.getElementById(`flow-node-${n.id}`);
                    const pinBtn = nodeEl?.querySelector('[data-action="pin"]');
                    if (pinBtn) {
                        pinBtn.classList.toggle('text-[--accent-mint]', st.pinned);
                        pinBtn.setAttribute('aria-pressed', st.pinned ? 'true' : 'false');
                        pinBtn.title = st.pinned ? 'Unpin (Pinned)' : 'Pin';
                    }
                });
            }
            function openNodeResponseModal(nodeId) {
                const st = nodeRuntime.get(nodeId) || {};
                const node = flowNodes.find(n => n.id === nodeId);
                const prompt = node ? prompts.find(p => String(p.id) === String(node.promptId)) : null;
                nodeResponseTitle.textContent = prompt ? `${prompt.title} (v${prompt.version})` : 'Response';
                nodeResponseContent.textContent = st.response || '';
                nodeResponseModal.classList.remove('hidden');
                nodeSaveResponseBtn.onclick = async () => {
                    if (!st.response) return;
                    try {
                        const { data: userData } = await supabaseClient.auth.getUser();
                        const uid = userData?.user?.id; if (!uid) return;
                        const row = {
                            user_id: uid,
                            prompt_version_id: prompt?.id || null,
                            prompt_title: prompt?.title || '',
                            prompt_version: prompt?.version || null,
                            model: (llmSelect?.value || null),
                            response_text: st.response
                        };
                        await supabaseClient.from('prompt_responses').insert(row);
                    } catch {}
                };
                nodePinResponseBtn.onclick = () => { togglePin(nodeId, true); };
            }
            function closeNodeResponseModal() { nodeResponseModal.classList.add('hidden'); }
            if (closeNodeResponseBtn) closeNodeResponseBtn.addEventListener('click', closeNodeResponseModal);
            if (nodeResponseModal) nodeResponseModal.addEventListener('click', (e) => { if (e.target === nodeResponseModal) closeNodeResponseModal(); });
            function togglePin(nodeId, forcePin) {
                const pins = loadPins();
                const st = nodeRuntime.get(nodeId) || {};
                const nowPinned = forcePin ? true : !st.pinned;
                st.pinned = nowPinned; nodeRuntime.set(nodeId, st);
                if (nowPinned) pins[nodeId] = st.response || '[Pinned without response]'; else delete pins[nodeId];
                savePins(pins);
                renderNodeBadgesFromPins();
            }
            function canRunNode(nodeId) {
                // parents must be success OR pinned
                const parents = getParents(nodeId);
                return parents.every(pid => {
                    const st = nodeRuntime.get(pid) || {};
                    return st.pinned || st.status === 'success';
                });
            }
            async function runNode(nodeId) {
                setNodeStatus(nodeId, 'running');
                try {
                    // Load this prompt into the request builder context
                    const node = flowNodes.find(n => n.id === nodeId);
                    const version = node ? prompts.find(p => String(p.id) === String(node.promptId)) : null;
                    if (!version) throw new Error('Prompt not found');
                    // Temporarily switch editor/model context
                    const backup = { content: mainEditor.value, title: titleInput.value, llm: llmSelect.value };
                    titleInput.value = version.title;
                    mainEditor.value = version.content || '';
                    if (llmSelect && version.llm) llmSelect.value = version.llm;
                    const { body, provider } = buildRunPayload();
                    const selModel = llmSelect?.value;
                    const selConn = resolveConnForModel(selModel);
                    const capsInfo = sanitizeRequestForModel({ body, provider, model: selModel });
                    if (capsInfo.unsupportedReason) throw new Error('Unsupported model capability in flow');
                    let initialBody = capsInfo.body || body; let path = 'chat/completions';
                    if (provider === 'openai' && capsInfo.preferEndpoint === 'responses') {
                        path = 'responses';
                        const inputText = (Array.isArray(initialBody.messages) ? initialBody.messages.map(m => m.content).join('\n\n') : (initialBody.input || '')) || 'ping';
                        const out = { model: initialBody.model, input: inputText };
                        if (typeof body.max_tokens === 'number') out.max_output_tokens = body.max_tokens;
                        initialBody = out;
                    }
                    if (provider === 'openai' && capsInfo.preferEndpoint === 'embeddings') {
                        path = 'embeddings';
                        const inputText = (Array.isArray(initialBody.messages) ? initialBody.messages.map(m => m.content).join('\n\n') : (initialBody.input || '')) || 'ping';
                        const out = { model: initialBody.model, input: inputText };
                        if (typeof body.dimensions === 'number') out.dimensions = body.dimensions;
                        initialBody = out;
                    }
                    let res = await llmRequest(path, { method: 'POST', body: initialBody, connId: selConn?.id });
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const data = await res.json();
                    let text = '';
                    if (data?.choices?.length) {
                        const c = data.choices[0];
                        if (Array.isArray(c.message?.content)) text = c.message.content.map(p => typeof p==='string'?p:(p?.text||'')).filter(Boolean).join('\n'); else text = c.message?.content || c.text || '';
                    } else if (Array.isArray(data?.output_text) && data.output_text.length) {
                        text = data.output_text.join('\n');
                    } else if (data?.message?.content) {
                        const mc = data.message.content; text = Array.isArray(mc) ? mc.map(p=>p?.text||'').filter(Boolean).join('\n') : mc;
                    } else if (Array.isArray(data?.content) && data.content[0]?.text) {
                        text = data.content.map(p=>p.text).filter(Boolean).join('\n\n');
                    } else { text = data?.text || ''; }
                    const st = nodeRuntime.get(nodeId) || {}; st.response = text; nodeRuntime.set(nodeId, st);
                    setNodeStatus(nodeId, 'success');
                    // Restore editor context
                    titleInput.value = backup.title; mainEditor.value = backup.content; if (llmSelect) llmSelect.value = backup.llm; refreshSyntaxOverlayIfOn();
                } catch (e) {
                    setNodeStatus(nodeId, 'error');
                    const err = e?.message || String(e);
                    console.error('Flow node error:', err);
                    if (!flowContinueOnError?.checked) throw e;
                }
            }
            async function runFlowSequence(runAll) {
                // init statuses
                nodeRuntime = new Map(flowNodes.map(n => [n.id, { status: 'idle', response: '', pinned: false }]));
                renderNodeBadgesFromPins();
                const order = topologicalOrder();
                // Mark pending for nodes that will run
                order.forEach(id => setNodeStatus(id, 'pending'));
                const pins = loadPins();
                const shouldSkip = (id) => !!pins[id];
                if (runAll) {
                    for (const id of order) {
                        if (shouldSkip(id)) { setNodeStatus(id, 'success'); continue; }
                        while (!canRunNode(id)) await new Promise(r => setTimeout(r, 50));
                        await runNode(id);
                    }
                } else {
                    // bypass: run a single next-eligible node on each click
                    const candidates = order.filter(id => !shouldSkip(id));
                    let ran = false;
                    for (let i = bypassCursor; i < candidates.length; i++) {
                        const id = candidates[i];
                        if (!canRunNode(id)) continue;
                        await runNode(id);
                        bypassCursor = i + 1; ran = true; break;
                    }
                    if (!ran) {
                        // if none eligible yet, wait minimal dependencies
                        for (let i = bypassCursor; i < candidates.length; i++) {
                            const id = candidates[i];
                            if (canRunNode(id)) { await runNode(id); bypassCursor = i + 1; ran = true; break; }
                        }
                    }
                }
            }
            const renderNodeFlowPrompts = () => {
                nodeFlowPromptList.innerHTML = '';
                const selectedProject = nodeFlowProjectFilter.value;

                const filteredPrompts = selectedProject === 'all' 
                    ? prompts 
                    : prompts.filter(p => p.project === selectedProject);

                const groupedPrompts = filteredPrompts.reduce((acc, p) => {
                    if (!acc[p.promptId]) {
                        acc[p.promptId] = { title: p.title, project: p.project, versions: [] };
                    }
                    acc[p.promptId].versions.push(p);
                    return acc;
                }, {});

                Object.values(groupedPrompts).forEach(group => {
                    group.versions.sort((a, b) => parseFloat(b.version) - parseFloat(a.version)).forEach(version => {
                         const card = document.createElement('div');
                         card.className = 'node-flow-prompt-card p-2 rounded-md';
                         card.draggable = true;
                         card.dataset.versionId = version.id;
                         card.innerHTML = `
                             <h4 class="font-semibold text-sm truncate">${S(version.title)} (v${S(version.version)})</h4>
                             <p class="text-xs text-[--text-muted-dark] truncate">${S(version.project || 'No Project')}</p>
                         `;
                         nodeFlowPromptList.appendChild(card);
                    });
                });
            };
            
            const renderFlowNodes = () => {
                nodeFlowContent.innerHTML = '';
                flowNodes.forEach(nodeData => {
                    const nodeEl = document.createElement('div');
                    nodeEl.className = 'flow-node gallery-card standard-card bg-[--card-bg-dark] border border-[--border-dark] rounded-md p-3 flex flex-col text-xs text-[--text-dark]';
                    nodeEl.id = `flow-node-${nodeData.id}`;
                    nodeEl.style.left = `${nodeData.x}px`;
                    nodeEl.style.top = `${nodeData.y}px`;
                    nodeEl.dataset.nodeId = nodeData.id;

                    const prompt = prompts.find(p => p.id === nodeData.promptId);
                    if (prompt) {
                        let dependencyTitle = 'N/A';
                         if (prompt.parent_id) {
                             const parentPrompt = prompts.find(p => p.id === prompt.parent_id);
                             if (parentPrompt) dependencyTitle = `${parentPrompt.title} (v${parentPrompt.version})`;
                         }
                        const depCount = Array.isArray(prompt.dependencies) ? prompt.dependencies.length : (prompt.parent_id ? 1 : 0);
            nodeEl.innerHTML = `
                            <div class="flex items-center gap-2 mb-1">
                <h3 class="font-bold text-base truncate pr-2 flex-1 min-w-0" data-role="node-prompt-title" style="color: var(--accent-fuchsia);">${S(prompt.title)}</h3>
                <span class="text-xs font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5 shrink-0">v${S(prompt.version)}</span>
                            </div>
                            <div class="mb-1">
                                <span class="text-[10px] font-mono bg-[#333] text-[#ccc] rounded-full px-2 py-0.5">${depCount} ${depCount === 1 ? 'dependency' : 'dependencies'}</span>
                            </div>
                            <div class="space-y-1 flex-grow">
                <p><strong class="text-[--text-muted-dark] font-normal">Project:</strong> ${S(prompt.project || 'N/A')}</p>
                <p><strong class="text-[--text-muted-dark] font-normal">LLM:</strong> ${S(prompt.llm || 'N/A')}</p>
                            </div>
                            <div class="mt-2 flex items-center justify-between gap-2">
                                <span class="flow-status idle" data-status>Idle</span>
                                <div class="node-actions flex items-center gap-1">
                                    <button title="View Response" data-action="view" aria-label="View Response">
                                        <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M2.036 12.322a1.012 1.012 0 010-.644C3.423 7.51 7.273 4.5 12 4.5c4.727 0 8.577 3.01 9.964 7.178.07.2.07.444 0 .644C20.577 16.49 16.727 19.5 12 19.5c-4.727 0-8.577-3.01-9.964-7.178z"/>
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                                        </svg>
                                    </button>
                                    <button title="Save Response" data-action="save" aria-label="Save Response">
                                        <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M7.5 11.25L12 15.75l4.5-4.5M12 15.75V3"/>
                                        </svg>
                                    </button>
                                    <button title="Load Saved" data-action="load" aria-label="Load Saved">
                                        <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12.75V8.25A2.25 2.25 0 014.5 6h3.879a2.25 2.25 0 001.59-.659l1.06-1.06A2.25 2.25 0 0112.62 3h6.88A2.25 2.25 0 0121.75 5.25V9M3 9.75h18V18.75A2.25 2.25 0 0118.75 21H5.25A2.25 2.25 0 013 18.75V9.75z"/>
                                        </svg>
                                    </button>
                                    <button title="Pin/Unpin" data-action="pin" aria-label="Pin" aria-pressed="false">
                                        <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                            <circle cx="12" cy="6" r="2" />
                                            <path d="M9 9h6l-3 5-3-5z" fill="currentColor" stroke="none" />
                                            <path d="M12 14v7" stroke-linecap="round" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div class="mt-3 pt-2 border-t border-[--border-dark] grid grid-cols-3 gap-2 text-center font-mono">
                <div><p class="text-[--text-muted-dark] text-xs">Temp</p><p class="font-semibold text-sm">${S(prompt.temperature)}</p></div>
                <div><p class="text-[--text-muted-dark] text-xs">Top P</p><p class="font-semibold text-sm">${S(prompt.topP)}</p></div>
                <div><p class="text-[--text-muted-dark] text-xs">Effort</p><p class="font-semibold text-sm">${S(prompt.effort)}</p></div>
                            </div>
                            <div class="connector output" data-node-id="${escapeAttr(String(nodeData.id))}"></div>
                        `;
                        nodeEl.dataset.promptId = String(prompt.id);
                        nodeEl.dataset.version = String(prompt.version || '');
                    } else {
                         nodeEl.innerHTML = `Prompt not found`;
                    }
                    nodeFlowContent.appendChild(nodeEl);
                });
            }

            const renderFlowConnections = () => {
                const svg = d3.select("#connections-group");
                svg.selectAll("path").remove();
                
                // Pega a posição do canvas para converter as coordenadas do viewport
                const canvasRect = nodeFlowCanvas.getBoundingClientRect();
            
                flowConnections.forEach(conn => {
                    const sourceNodeEl = document.getElementById(`flow-node-${conn.source}`);
                    const targetNodeEl = document.getElementById(`flow-node-${conn.target}`);
                    if (sourceNodeEl && targetNodeEl) {
                        const sourceRect = sourceNodeEl.getBoundingClientRect();
                        const targetRect = targetNodeEl.getBoundingClientRect();
            
                        const startX = sourceRect.right - canvasRect.left;
                        const startY = sourceRect.top + (sourceRect.height / 2) - canvasRect.top;
                        const endX = targetRect.left - canvasRect.left;
                        const endY = targetRect.top + (targetRect.height / 2) - canvasRect.top;
            
                        svg.append('path')
                            .attr('d', `M ${startX} ${startY} C ${startX + 60} ${startY} ${endX - 60} ${endY} ${endX} ${endY}`)
                            .attr('class', 'connection-line')
                            .attr('data-source', String(conn.source))
                            .attr('data-target', String(conn.target));
                    }
                });
            }
            
            const renderSavedFlowsList = () => {
                savedFlowsDropdown.innerHTML = '<option value="">Load a saved flow...</option>';
                savedFlows.forEach(flow => {
                    const option = document.createElement('option');
                    option.value = flow.name;
                    option.textContent = flow.name;
                    savedFlowsDropdown.appendChild(option);
                });
            };

            const loadFlow = (flowName) => {
                const flow = savedFlows.find(f => f.name === flowName);
                if (flow) {
                    flowNodes = flow.nodes;
                    flowConnections = flow.connections;
                    renderFlowNodes();
                    renderFlowConnections();
                    // Update delete button based on content loaded
                    if (typeof refreshDeleteFlowState === 'function') refreshDeleteFlowState();
                }
            };

            // --- MANIPULADORES DE EVENTOS ---
            versionsHistoryList.addEventListener('click', (e) => {
                const target = e.target;
                const item = target.closest('.version-item');
                const header = target.closest('.prompt-group-header');
                const deleteGroupBtn = target.closest('[data-action="delete-group"]');

                if (deleteGroupBtn) {
                    e.stopPropagation();
                    const promptId = deleteGroupBtn.dataset.promptId;
                    showDeleteModal('group', promptId);
                } else if (header) {
                    const promptId = header.dataset.promptId;
                    if (expandedPromptGroups.has(promptId)) {
                        expandedPromptGroups.delete(promptId);
                    } else {
                        expandedPromptGroups.add(promptId);
                    }
                    renderVersionsList();
                } else if (target.matches('input[type="checkbox"]')) {
                    const versionId = target.dataset.id;
                    const promptId = target.dataset.promptId;
                    
                    if (target.checked) {
                        if (activeComparisonPromptId !== null && activeComparisonPromptId !== promptId) {
                            versionsToCompare.clear();
                            activeComparisonPromptId = null;
                        }
                        
                        versionsToCompare.add(versionId);
                        activeComparisonPromptId = promptId;

                        if (versionsToCompare.size > 2) {
                            const firstId = versionsToCompare.values().next().value;
                            versionsToCompare.delete(firstId);
                        }
                    } else {
                        versionsToCompare.delete(versionId);
                        if (versionsToCompare.size === 0) {
                            activeComparisonPromptId = null;
                        }
                    }

                    document.querySelectorAll('#versions-history-list input[type="checkbox"]').forEach(cb => {
                        const cbVersionId = cb.dataset.id;
                        const cbPromptId = cb.dataset.promptId;
                        cb.checked = versionsToCompare.has(cbVersionId);
                        if (activeComparisonPromptId !== null) {
                            cb.disabled = String(cbPromptId) !== String(activeComparisonPromptId);
                        } else {
                            cb.disabled = false;
                        }
                    });

                    compareVersionsBtn.disabled = versionsToCompare.size !== 2;

                } else if (item) {
                    const actionTarget = target.closest('[data-action="select"]') || item;
                    if (actionTarget && actionTarget.dataset && actionTarget.dataset.id) {
                        loadVersionIntoEditor(actionTarget.dataset.id);
                    }
                }
            });

            statusContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.status-option');
                if(target) updateStatusSelectorUI(normalizeStatus(target.dataset.status));
            });

            const statusFilterSelect = document.getElementById('status-filter-select');
            if (statusFilterSelect) {
                statusFilterSelect.addEventListener('change', (e) => {
                    const val = (e.target.value || 'all').toLowerCase();
                    activeStatusFilter = (val === 'all') ? 'all' : normalizeStatus(val);
                    updateStatusFilterUI();
                    renderVersionsList();
                });
            }

            mainEditor.addEventListener('input', () => {
                updateEditorStats();
                renderVariables();
                renderNavigationMap();
                updateSnippetButtons();
            });
            mainEditor.addEventListener('scroll', updateSnippetButtons);

            // Debounce search input to reduce re-renders while typing
            let _versionsSearchTmr = null;
            searchInput.addEventListener('input', () => {
                if (_versionsSearchTmr) clearTimeout(_versionsSearchTmr);
                _versionsSearchTmr = setTimeout(() => { renderVersionsList(); }, 150);
            });

            copyPromptBtn.addEventListener('click', () => {
                let textToCopy = mainEditor.value;
                document.querySelectorAll('#variables-container input').forEach(input => {
                    const varName = input.name;
                    const varValue = input.value;
                    textToCopy = textToCopy.replace(new RegExp(`\\{\\{${varName}\\}\\}`, 'g'), varValue);
                });
                
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                textArea.style.position = 'fixed';
                textArea.style.top = '-9999px';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        copyPromptBtn.classList.add('text-green-500');
                        setTimeout(() => {
                            copyPromptBtn.classList.remove('text-green-500');
                        }, 2000);
                    }
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
                document.body.removeChild(textArea);
            });

            deleteVersionBtn.addEventListener('click', () => {
                if (selectedVersionId) showDeleteModal('version', selectedVersionId);
                else showValidationAlert('No version selected to delete.');
            });

            addPromptBtn.addEventListener('click', clearEditorForNewPrompt);
            addMajorVersionBtn.addEventListener('click', () => saveVersion(true));
            addMinorVersionBtn.addEventListener('click', () => saveVersion(false));
            forkVersionBtn.addEventListener('click', forkVersion);
            if (llmSelect) llmSelect.addEventListener('change', () => {
                // When model changes, re-render model-specific settings using dynamic schema
                const current = selectedVersionId ? prompts.find(p => p.id === selectedVersionId)?.modelSettings : {};
                renderDynamicSettings(current || {});
            });
            const saveChanges = async () => {
                if (!selectedVersionId) {
                    showValidationAlert('No prompt selected to save changes.');
                    return;
                }
                const promptIndex = prompts.findIndex(p => p.id === selectedVersionId);
                if (promptIndex === -1) return;

                const promptToUpdate = { ...prompts[promptIndex] }; // Cria uma cópia para editar

                promptToUpdate.title = titleInput.value.trim();
                promptToUpdate.project = projectInput.value.trim();
                promptToUpdate.content = mainEditor.value;
                promptToUpdate.comments = commentsTextarea.value;
                promptToUpdate.llm = llmSelect.value;
                promptToUpdate.status = normalizeStatus(document.querySelector('.status-option.active')?.dataset.status || promptToUpdate.status);
                // Temperature/TopP/Effort now come from dynamic settings below
                promptToUpdate.date = new Date().toISOString();
                promptToUpdate.tags = [...tagsContainer.querySelectorAll('.prompt-tag span')].map(span => span.textContent);
                // Persist dependencies edited via the bottom bar
                promptToUpdate.dependencies = currentDependencies.map(String);
                promptToUpdate.parent_id = (promptToUpdate.dependencies.length === 1) ? promptToUpdate.dependencies[0] : null;
                // Persist GitHub repo selection at prompt level
                if (currentGithubRepo && currentGithubRepo.id) {
                    promptToUpdate.githubRepo = currentGithubRepo.id;
                    promptToUpdate.githubRepoFull = currentGithubRepo.full || '';
                } else {
                    promptToUpdate.githubRepo = '';
                    promptToUpdate.githubRepoFull = '';
                }
                // Persist GitHub file path if set
                if (typeof commitFilePathInput !== 'undefined' && commitFilePathInput?.value) {
                    promptToUpdate.githubFilePath = commitFilePathInput.value.trim();
                } else if (lastImportedGitFilePath) {
                    promptToUpdate.githubFilePath = lastImportedGitFilePath;
                }

                // Merge dynamic settings back into legacy fields
                const dyn = collectDynamicSettings();
                promptToUpdate.temperature = dyn.temperature ?? promptToUpdate.temperature;
                promptToUpdate.topP = dyn.topP ?? promptToUpdate.topP;
                if (dyn.effort !== undefined) promptToUpdate.effort = effortLevels[dyn.effort] || promptToUpdate.effort;
                promptToUpdate.modelSettings = dyn;

                // Require only Title and Content when saving changes
                if (!promptToUpdate.title || !promptToUpdate.content) {
                    showValidationAlert('Title and Content are required fields.');
                    return;
                }

                await upsertItem('prompts', mapPromptUIToDb(promptToUpdate)); // Save to Supabase

                prompts[promptIndex] = promptToUpdate; // Atualiza o estado local
                renderVersionsList();
                updateSnippetButtons();
            };

            document.getElementById('save-changes-btn').addEventListener('click', saveChanges);
            // Dependency manager events
            if (editDependenciesBtn) {
                editDependenciesBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (dependenciesDropdown.classList.contains('hidden')) openDependenciesDropdown();
                    else closeDependenciesDropdown();
                });
            }
            if (depsCancelBtn) depsCancelBtn.addEventListener('click', closeDependenciesDropdown);
            if (depsApplyBtn) depsApplyBtn.addEventListener('click', () => {
                const checked = [...dependenciesList.querySelectorAll('input[type="checkbox"]:checked')].map(cb => cb.dataset.id);
                renderDependencyBar(checked);
                updateSnippetButtons();
                closeDependenciesDropdown();
            });
            if (dependenciesSearch) dependenciesSearch.addEventListener('input', () => renderDependenciesDropdown(dependenciesSearch.value));
            // Close dropdown on outside click
            document.addEventListener('click', (e) => {
                const pop = document.getElementById('dependencies-popover');
                if (!pop) return;
                if (!pop.contains(e.target)) closeDependenciesDropdown();
            });
            downloadJsonBtn.addEventListener('click', () => downloadFile('json'));
            downloadMdBtn.addEventListener('click', () => downloadFile('md'));
            downloadTxtBtn.addEventListener('click', () => downloadFile('txt'));

            // Legacy sliders removed; dynamic settings UI handles values now
            
            // --- Eventos da Galeria e Modais ---
            if (dashboardBtn) dashboardBtn.addEventListener('click', () => {
                if (dashboardModal) dashboardModal.classList.remove('hidden');
            });
            galleryBtn.addEventListener('click', () => {
                renderGallery();
                galleryModal.classList.remove('hidden');
            });

            closeGalleryBtn.addEventListener('click', () => galleryModal.classList.add('hidden'));
            galleryModal.addEventListener('click', (e) => {
                if (e.target === galleryModal) galleryModal.classList.add('hidden');
            });

            projectsBtn.addEventListener('click', () => {
                renderProjectsView();
                projectsModal.classList.remove('hidden');
            });
            closeProjectsBtn.addEventListener('click', () => projectsModal.classList.add('hidden'));
            projectsModal.addEventListener('click', (e) => {
                if (e.target === projectsModal) projectsModal.classList.add('hidden');
            });
            projectsListContainer.addEventListener('click', (e) => {
                const rowTarget = e.target.closest('tr[data-id]');
                const commentBtn = e.target.closest('[data-action="view-comments"]');

                if (commentBtn) {
                    e.stopPropagation(); // Impede que o clique na linha seja disparado
                    const promptId = commentBtn.dataset.id;
                    showCommentsViewer(promptId);
                } else if (rowTarget) {
                    const promptId = rowTarget.dataset.id;
                    loadVersionIntoEditor(promptId);
                    projectsModal.classList.add('hidden');
                }
            });

            templatesBtn.addEventListener('click', () => {
                if (templatesProjectFilter) {
                    const prev = templatesProjectFilter.value;
                    populateProjectList(templatesProjectFilter);
                    templatesProjectFilter.value = prev || 'all';
                }
                renderTemplatesGrid();
                templatesModal.classList.remove('hidden');
            });
            closeTemplatesBtn.addEventListener('click', () => templatesModal.classList.add('hidden'));
            templatesModal.addEventListener('click', (e) => {
                if (e.target === templatesModal) templatesModal.classList.add('hidden');
            });
            if (templatesProjectFilter) templatesProjectFilter.addEventListener('change', renderTemplatesGrid);
            // Project filter (Versions panel)
            populateProjectFilter();
            const projectFilterSelect = document.getElementById('project-filter-select');
            if (projectFilterSelect) {
                projectFilterSelect.addEventListener('change', (e) => {
                    activeProjectFilter = (e.target.value || 'all');
                    updateProjectFilterUI();
                    renderVersionsList();
                });
            }
            
            templatesGridContainer.addEventListener('click', (e) => {
                const card = e.target.closest('.gallery-card');
                if (!card) return;

                const actionButton = e.target.closest('[data-action]');
                const templateId = card.dataset.id;
                const template = templates.find(t => String(t.id) === String(templateId));
                if (!template) return;

                const action = actionButton ? actionButton.dataset.action : 'load-template';

                if (action === 'load-template') {
                    clearEditorForNewPrompt();
                    titleInput.value = template.title;
                    projectInput.value = template.project;
                    mainEditor.value = template.content;
                    llmSelect.value = template.llm;
                    // Apply dependencies from template (multi) or parent_id
                    const tDeps = (template.dependencies && template.dependencies.length) ? template.dependencies : (template.parent_id ? [template.parent_id] : []);
                    renderDependencyBar(tDeps);
                    updateSlidersUI(template);
                    updateEditorStats();
                    renderVariables();
                    renderPromptTags(template.tags);
                    templatesModal.classList.add('hidden');
                    updateSnippetButtons();
                    refreshSyntaxOverlayIfOn();
                } else if (action === 'delete-template') {
                    showModal(
                        'Confirm Deletion',
                        `Are you sure you want to delete the template "${template.name}"?`,
                        [
                            { text: 'Cancel', className: 'action-button', onClick: hideModal },
                            { 
                                text: 'Delete', 
                                className: 'action-button bg-[--accent-red] text-white border-[--accent-red-hover] hover:bg-[--accent-red-hover]', 
                                onClick: async () => {
                                    templates = templates.filter(t => t.id !== templateId);
                                    saveTemplatesToStorage();
                                    await deleteItem('templates', templateId);
                                    renderTemplatesGrid();
                                    hideModal();
                                }
                            }
                        ]
                    );
                }
            });

            saveAsTemplateBtn.addEventListener('click', async () => {
                const content = mainEditor.value.trim();
                if (!content) {
                    showValidationAlert('The editor is empty. Write something to save as a template.');
                    return;
                }
                // Require authentication to save to Supabase
                try {
                    if (!window.dataService || !(await window.dataService.getSessionUserId())) {
                        if (typeof window.openLoginModal === 'function') window.openLoginModal();
                        showValidationAlert('Please sign in to save templates to the cloud.');
                        return;
                    }
                } catch {}

                const currentTags = [...tagsContainer.querySelectorAll('.prompt-tag span')].map(span => span.textContent);

                const dynNow = collectDynamicSettings();
                const templateData = {
                    title: titleInput.value.trim(),
                    project: projectInput.value.trim(),
                    content: content,
                    llm: llmSelect.value,
                    temperature: dynNow.temperature ?? 0.7,
                    topP: dynNow.topP ?? 0.9,
                    effort: dynNow.effort !== undefined ? effortLevels[dynNow.effort] : 'Medium',
                    parent_id: (currentDependencies.length === 1) ? currentDependencies[0] : null,
                    dependencies: currentDependencies.map(String),
                    tags: currentTags
                };

                showModal(
                    'Save as Template',
                    'Enter a name for this template:',
                    [
                        { text: 'Cancel', className: 'action-button', onClick: hideModal },
                        { 
                            text: 'Save', 
                            className: 'action-button primary', 
                            onClick: async () => {
                                const templateName = document.getElementById('confirm-modal-input').value.trim();
                                if (templateName) {
                                    const newTemplate = { ...templateData, name: templateName, id: String(Date.now()) };
                                    const rows = await upsertItem('templates', mapTemplateUIToDb(newTemplate));
                                    let ok = Array.isArray(rows) && rows.length > 0;
                                    if (!ok) {
                                        // Some setups may not return rows even on success; reload and verify
                                        try { await loadDataFromSupabase(); } catch {}
                                        ok = (templates || []).some(t => String(t.id) === String(newTemplate.id));
                                    }
                                    if (!ok) {
                                        showModal('Save failed', 'Could not save template to Supabase. Check your connection and authentication.', [
                                            { text: 'OK', className: 'action-button primary', onClick: hideModal }
                                        ]);
                                        return;
                                    }
                                    // Ensure latest state and refresh UI
                                    try { await loadDataFromSupabase(); } catch {}
                                    renderTemplatesGrid();
                                    hideModal();
                                    setTimeout(() => {
                                        showModal('Success', `Template "${templateName}" saved.`, [
                                            { text: 'OK', className: 'action-button primary', onClick: hideModal }
                                        ]);
                                    }, 300);
                                }
                            } 
                        }
                    ],
                    { showInput: true, inputPlaceholder: 'Template name...' }
                );
            });

            dependencyTagContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.dependency-tag');
                if (target) {
                    const dependencyId = target.dataset.dependencyId;
                    showDependencyViewer(dependencyId);
                }
            });

            closeDependencyViewerBtn.addEventListener('click', () => dependencyViewerModal.classList.add('hidden'));
            dependencyViewerModal.addEventListener('click', (e) => {
                if (e.target === dependencyViewerModal) dependencyViewerModal.classList.add('hidden');
            });
            
            closeCommentsViewerBtn.addEventListener('click', () => commentsViewerModal.classList.add('hidden'));
            commentsViewerModal.addEventListener('click', (e) => {
                if (e.target === commentsViewerModal) commentsViewerModal.classList.add('hidden');
            });

            readModeBtn.addEventListener('click', toggleReadMode);
            readModeModal.addEventListener('click', (e) => {
                if (e.target === readModeModal) {
                    toggleReadMode();
                }
            });
            
            compareVersionsBtn.addEventListener('click', () => {
                if (!hasDiff) {
                    showModal('Unavailable', 'Diff engine not loaded. Connect to the internet and reload to compare versions.', [
                        { text: 'OK', className: 'action-button primary', onClick: hideModal }
                    ]);
                    return;
                }
                const [id1, id2] = Array.from(versionsToCompare);
                let version1 = prompts.find(p => String(p.id) === String(id1));
                let version2 = prompts.find(p => String(p.id) === String(id2));

                if (version1 && version2) {
                    // Garante que a versão 1 seja sempre a mais antiga
                    if (parseFloat(version1.version) > parseFloat(version2.version)) {
                        [version1, version2] = [version2, version1];
                    }

                    const dmp = new diff_match_patch();
                    
                    const diff1 = dmp.diff_main(version1.content, version2.content);
                    dmp.diff_cleanupSemantic(diff1);
                    
                    const diff2 = dmp.diff_main(version2.content, version1.content);
                    dmp.diff_cleanupSemantic(diff2);
                    
                    const cleanHtml = (html) => {
                        return html
                            .replace(/&para;/g, '')
                            .replace(/ style="background:(#e6ffe6|#ffe6e6);"/gi, '');
                    };

                    diffModalTitle.textContent = `Comparing v${version1.version} vs v${version2.version}`;
                    diffTitleA.textContent = `Version ${version1.version}`;
                    diffTitleB.textContent = `Version ${version2.version}`;
                    const metaA = `LLM: ${version1.llm || 'N/A'} · Temp: ${version1.temperature ?? 'N/A'} · Top P: ${version1.topP ?? 'N/A'} · Effort: ${version1.effort || 'N/A'} · Repo: ${version1.githubRepoFull || version1.githubRepo || 'N/A'}`;
                    const metaB = `LLM: ${version2.llm || 'N/A'} · Temp: ${version2.temperature ?? 'N/A'} · Top P: ${version2.topP ?? 'N/A'} · Effort: ${version2.effort || 'N/A'} · Repo: ${version2.githubRepoFull || version2.githubRepo || 'N/A'}`;
                    document.getElementById('diff-meta-a').textContent = metaA;
                    document.getElementById('diff-meta-b').textContent = metaB;
                    document.getElementById('diff-comments-a').textContent = (version1.comments && version1.comments.trim()) ? `Comments: ${version1.comments}` : '';
                    document.getElementById('diff-comments-b').textContent = (version2.comments && version2.comments.trim()) ? `Comments: ${version2.comments}` : '';
                    diffPanelA.innerHTML = cleanHtml(dmp.diff_prettyHtml(diff1));
                    diffPanelB.innerHTML = cleanHtml(dmp.diff_prettyHtml(diff2));

                    diffModal.classList.remove('hidden');
                }
            });
            closeDiffModalBtn.addEventListener('click', () => diffModal.classList.add('hidden'));
            diffModal.addEventListener('click', (e) => {
                if (e.target === diffModal) {
                    diffModal.classList.add('hidden');
                }
            });

            // --- EVENTOS DE BUSCA E SUBSTITUIÇÃO ---
            findBtn.addEventListener('click', () => toggleFindReplaceBar(true));
            closeFindBtn.addEventListener('click', () => toggleFindReplaceBar(false));
            findInput.addEventListener('input', executeFind);
            findInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    goToNextMatch();
                }
            });
            nextBtn.addEventListener('click', goToNextMatch);
            prevBtn.addEventListener('click', goToPrevMatch);
            replaceBtn.addEventListener('click', executeReplace);
            replaceAllBtn.addEventListener('click', executeReplaceAll);

            // --- EVENTOS DO GRÁFICO ---
            graphViewBtn.addEventListener('click', () => {
                if (!hasD3) {
                    showModal('Unavailable', 'Graph requires D3 which is not loaded (offline).', [
                        { text: 'OK', className: 'action-button primary', onClick: hideModal }
                    ]);
                    return;
                }
                dependencyGraphModal.classList.remove('hidden');
                populateGraphFilters();
                // Pequeno delay para garantir que o container tenha as dimensões corretas antes de renderizar
                setTimeout(() => renderDependencyGraph({ project: graphProjectFilter.value }), 50); 
            });
            closeDependencyGraphBtn.addEventListener('click', () => dependencyGraphModal.classList.add('hidden'));
            dependencyGraphModal.addEventListener('click', e => {
                if (e.target === dependencyGraphModal) {
                    dependencyGraphModal.classList.add('hidden');
                }
            });
            graphProjectFilter.addEventListener('change', () => {
                const selectedProject = graphProjectFilter.value;
                renderDependencyGraph({ project: selectedProject });
            });
            createConnectionBtn.addEventListener('click', (e) => {
                isCreatingConnection = !isCreatingConnection;
                e.currentTarget.classList.toggle('active', isCreatingConnection);
                // Se o modo de conexão for desativado, reseta o estado
                if (!isCreatingConnection) {
                    firstNodeForConnection = null;
                    d3.selectAll('.graph-node').classed('selected-for-connection', false);
                }
            });
            deleteConnectionBtn.addEventListener('click', async () => {
                if (selectedLinkForDeletion) {
                    const childId = String(selectedLinkForDeletion.target.id);
                    const parentIdToRemove = String(selectedLinkForDeletion.source.id);
                    const childPrompt = prompts.find(p => String(p.id) === childId);
                    if (childPrompt) {
                        if (!Array.isArray(childPrompt.dependencies)) childPrompt.dependencies = childPrompt.parent_id ? [childPrompt.parent_id] : [];
                        childPrompt.dependencies = childPrompt.dependencies.filter(id => String(id) !== parentIdToRemove);
                        childPrompt.parent_id = (childPrompt.dependencies.length === 1) ? childPrompt.dependencies[0] : null;
                        savePromptsToStorage();
                        await upsertItem('prompts', mapPromptUIToDb(childPrompt));
                        renderDependencyGraph({ project: graphProjectFilter.value });
                        if (selectedVersionId && String(selectedVersionId) === String(childPrompt.id)) {
                            renderDependencyBar(childPrompt.dependencies);
                        }
                        selectedLinkForDeletion = null;
                        deleteConnectionBtn.disabled = true;
                    }
                }
            });

            // --- EVENTOS DAS TAGS ---
            tagsContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.remove-tag-btn');
                if (target) {
                    target.parentElement.remove();
                }
            });
            
            projectInput.addEventListener('input', () => renderPromptTags([...tagsContainer.querySelectorAll('.prompt-tag:not(.auto-tag) span')].map(s => s.textContent)));
            llmSelect.addEventListener('change', () => renderPromptTags([...tagsContainer.querySelectorAll('.prompt-tag:not(.auto-tag) span')].map(s => s.textContent)));

            // --- EVENTOS DA BIBLIOTECA DE VARIÁVEIS E XML ---
            const setupDropdown = (input, dropdown, library, onSelect, onAdd) => {
                const renderDropdown = (showAll = false) => {
                    const filter = input.value.toLowerCase();
                    const items = library(); // Get the items from the provided function
                    const itemsToShow = (showAll) ? items : items.filter(item => item.toLowerCase().includes(filter));
                    
                    dropdown.innerHTML = '';
                    if (itemsToShow.length > 0) {
                        itemsToShow.forEach(item => {
                            const itemEl = document.createElement('div');
                            itemEl.className = 'custom-dropdown-item';
                            itemEl.textContent = item;
                            itemEl.addEventListener('mousedown', (e) => { 
                                e.preventDefault();
                                onSelect(item);
                                input.value = '';
                                dropdown.classList.add('hidden');
                            });
                            dropdown.appendChild(itemEl);
                        });
                        dropdown.classList.remove('hidden');
                    } else {
                        dropdown.classList.add('hidden');
                    }
                };

                input.addEventListener('focus', () => renderDropdown(true));
                input.addEventListener('input', () => renderDropdown(false));
                input.addEventListener('blur', () => setTimeout(() => dropdown.classList.add('hidden'), 150));
                if(onAdd) {
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            onAdd();
                        }
                    });
                }
            };

            // Setup header Add actions (inputs removed, we prompt)
            const headerAddXmlBtn = document.getElementById('add-xml-tag-btn');
            const headerAddVarBtn = document.getElementById('add-var-library-btn');
            if (headerAddXmlBtn) headerAddXmlBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showModal('Add XML Tag', 'Enter a new XML tag name:', [
                    { text: 'Cancel', className: 'action-button', onClick: hideModal },
                    { text: 'Add', className: 'action-button primary', onClick: () => { addCurrentXmlTag(); hideModal(); renderXmlTagsListDrawer(); } }
                ], { showInput: true, inputPlaceholder: 'tag-name' });
            });
            if (headerAddVarBtn) headerAddVarBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showModal('Add Variable', 'Enter a new variable name (with or without {{}}):', [
                    { text: 'Cancel', className: 'action-button', onClick: hideModal },
                    { text: 'Add', className: 'action-button primary', onClick: () => { addCurrentVarToLibrary(); hideModal(); renderVarLibraryListDrawer(); } }
                ], { showInput: true, inputPlaceholder: '{{var_name}}' });
            });
            
            // --- EVENTOS DO GERENCIADOR DE LISTAS ---
            listManagerBtn.addEventListener('click', () => {
                renderListManager();
                listManagerModal.classList.remove('hidden');
            });

            closeListManagerBtn.addEventListener('click', () => {
                listManagerModal.classList.add('hidden');
            });
            
            listManagerModal.addEventListener('click', (e) => {
                if (e.target === listManagerModal) {
                    listManagerModal.classList.add('hidden');
                }
            });

            listManagerModal.addEventListener('focusout', (e) => {
                const span = e.target;
                if (span.matches('.manager-tag span[contenteditable="true"]')) {
                    const parent = span.parentElement;
                    const oldVal = parent.dataset.value;
                    const newVal = span.textContent.trim();
                    const type = parent.dataset.type;
                    const category = parent.dataset.category;

                    if (newVal !== oldVal) {
                        updateListItem(type, oldVal, newVal, { category });
                    }
                }
            });

            listManagerModal.addEventListener('keydown', (e) => {
                const span = e.target;
                if (span.matches('.manager-tag span[contenteditable="true"]') && e.key === 'Enter') {
                    e.preventDefault();
                    span.blur();
                }
            });

            listManagerModal.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-tag-btn');

                if (removeBtn) {
                    const parent = removeBtn.parentElement;
                    const value = parent.dataset.value;
                    const type = parent.dataset.type;
                    const category = parent.dataset.category;

                    showModal(
                        'Confirm Deletion',
                        `Are you sure you want to delete the item "${value}"? This action cannot be undone.`,
                        [
                            { text: 'Cancel', className: 'action-button', onClick: async () => await hideModal },
                            { 
                                text: 'Delete', 
                                className: 'action-button bg-[--accent-red] text-white border-[--accent-red-hover] hover:bg-[--accent-red-hover]', 
                                onClick: async () => {
                                    let updatePrompts = false;
                                    switch (type) {
                                        case 'xml':
                                            xmlTags = xmlTags.filter(t => t !== value);
                                            saveXmlTagsToStorage();
                                            // Persist XML tags delete to Supabase
                                            updateGlobalList('xml_tags', xmlTags);
                                            break;
                                        case 'var':
                                            varLibrary = varLibrary.filter(t => t !== value);
                                            saveVarLibraryToStorage();
                                            // Persist Var Library delete to Supabase
                                            updateGlobalList('var_library', varLibrary);
                                            break;
                                        case 'llm-category': delete llmList[value]; saveLlmListToStorage(); populateLlmSelect(); break;
                                        case 'llm-model':
                                            if (llmList[category]) {
                                                llmList[category] = llmList[category].filter(m => m !== value);
                                                saveLlmListToStorage();
                                                updateGlobalList('llm_list', llmList);
                                                populateLlmSelect();
                                                updatePrompts = true;
                                            }
                                            break;
                                        case 'general':
                                            // Remove from all prompts and from general tags library cache
                                            updatePrompts = true;
                                            try {
                                                const GENERAL_TAGS_LIB_KEY = 'promptManagerApp_generalTagsLib';
                                                let generalTagsLib = JSON.parse(localStorage.getItem(GENERAL_TAGS_LIB_KEY) || '[]');
                                                if (generalTagsLib.includes(value)) {
                                                    generalTagsLib = generalTagsLib.filter(t => t !== value);
                                                    localStorage.setItem(GENERAL_TAGS_LIB_KEY, JSON.stringify(generalTagsLib));
                                                    updateGlobalList('general_tags_library', generalTagsLib);
                                                }
                                            } catch {}
                                            break;
                                    }

                                    if (updatePrompts) {
                                        prompts.forEach(p => {
                                            if (type === 'llm-model' && p.llm === value) p.llm = '';
                                            if (type === 'general' && p.tags) p.tags = p.tags.filter(t => t !== value);
                                        });
                                        savePromptsToStorage();
                                        await upsertItem('prompts', prompts.map(mapPromptUIToDb));
                                        if (selectedVersionId) loadVersionIntoEditor(selectedVersionId);
                                        
                                    }
                                    
                                    renderListManager();
                                    hideModal();
                                }
                            }
                        ]
                    );
                }
            });

        addXmlTagManagerBtn.addEventListener('click', () => {
                const tagName = addXmlTagManagerInput.value.trim();
                if (tagName && !xmlTags.includes(tagName)) {
                    xmlTags.push(tagName);
                    saveXmlTagsToStorage();
            // Persist XML tags add to Supabase
            updateGlobalList('xml_tags', xmlTags);
                    addXmlTagManagerInput.value = '';
                    renderListManager();
                }
            });

            addVarLibraryManagerBtn.addEventListener('click', () => {
                let varName = addVarLibraryManagerInput.value.trim();
                if (varName) {
                    if (!varName.startsWith('{{') || !varName.endsWith('}}')) {
                        varName = `{{${varName.replace(/{{|}}/g, '')}}}`;
                    }
                    if (!varLibrary.includes(varName)) {
                        varLibrary.push(varName);
                        saveVarLibraryToStorage();
                        // Persist Var Library add to Supabase
                        updateGlobalList('var_library', varLibrary);
                        addVarLibraryManagerInput.value = '';
                        renderListManager();
                    }
                }
            });

            addLlmCategoryManagerBtn.addEventListener('click', () => {
                // Open API Console focused on LLM tab
                const modal = document.getElementById('api-console-modal');
                if (modal) {
                    modal.classList.remove('hidden');
                    try { loadApiSettings(); } catch {}
                    try {
                        const targetTab = document.querySelector('.api-tab-btn[data-api-tab="llm"]');
                        if (targetTab) targetTab.click();
                    } catch {}
                    try { renderLlmModelsPerConn(); } catch {}
                    // Close List Manager so only API Console stays open
                    try {
                        const listMgr = document.getElementById('list-manager-modal');
                        if (listMgr) listMgr.classList.add('hidden');
                    } catch {}
                }
            });

            // Add new General Tag (applies globally, adds to prompts only when used; here we maintain a synthetic list via union of prompts tags)
            addGeneralTagManagerBtn.addEventListener('click', () => {
                let tagName = addGeneralTagManagerInput.value.trim();
                if (!tagName) return;
                if (!tagName.startsWith('#')) tagName = `#${tagName}`;

                // If tag already exists among all prompts, just clear input and refresh list
                const existing = getAllUniqueTags();
                if (existing.includes(tagName)) {
                    addGeneralTagManagerInput.value = '';
                    renderListManager();
                    return;
                }

                // Otherwise, we add it to no prompt by default, but to keep it visible we can persist it in a pseudo library list in global_lists
                // Approach: store a dedicated list 'general_tags_library' to maintain available general tags not yet used
                // First, try to fetch from localStorage (mirroring global list cache if any), else start with []
                const GENERAL_TAGS_LIB_KEY = 'promptManagerApp_generalTagsLib';
                let generalTagsLib = [];
                try { generalTagsLib = JSON.parse(localStorage.getItem(GENERAL_TAGS_LIB_KEY) || '[]'); } catch {}
                if (!generalTagsLib.includes(tagName)) generalTagsLib.push(tagName);
                localStorage.setItem(GENERAL_TAGS_LIB_KEY, JSON.stringify(generalTagsLib));
                // Persist to Supabase if available using global_lists
                updateGlobalList('general_tags_library', generalTagsLib);

                addGeneralTagManagerInput.value = '';
                renderListManager();
            });

            // --- EVENTOS DO INPUT GALLERY ---
            inputGalleryBtn.addEventListener('click', () => {
                if (inputGalleryProjectFilter) populateProjectList(inputGalleryProjectFilter);
                if (inputGalleryProjectAssign) populateProjectAssignList(inputGalleryProjectAssign);
                renderInputGallery();
                clearInputEditor(); // Começa com um editor limpo
                inputGalleryModal.classList.remove('hidden');
            });

            closeInputGalleryBtn.addEventListener('click', () => {
                inputGalleryModal.classList.add('hidden');
            });

            inputGalleryModal.addEventListener('click', (e) => {
                if (e.target === inputGalleryModal) {
                    inputGalleryModal.classList.add('hidden');
                }
            });

            addNewInputBtn.addEventListener('click', clearInputEditor);
            saveInputGalleryBtn.addEventListener('click', saveCurrentInput);
            if (inputGalleryProjectFilter) inputGalleryProjectFilter.addEventListener('change', renderInputGallery);

            inputGalleryList.addEventListener('click', (e) => {
                const item = e.target.closest('.input-gallery-item');
                const deleteBtn = e.target.closest('[data-action="delete-input"]');

                if (deleteBtn) {
                    e.stopPropagation();
                    const idToDelete = deleteBtn.dataset.id;
                    deleteInputFromGallery(idToDelete);
                } else if (item) {
                    const idToLoad = item.dataset.id;
                    loadInputForEditing(idToLoad);
                }
            });
            
            // Add Input now uses the in-drawer list; dropdown removed

            // --- EVENTOS DO SNIPPET: COPIAR e SALVAR ---
            snippetButtonsOverlay.addEventListener('click', (e) => {
                const copyBtn = e.target.closest('.copy-snippet-btn');
                const saveBtn = e.target.closest('.save-snippet-btn');
                if (copyBtn) {
                    const index = parseInt(copyBtn.dataset.snippetIndex, 10);
                    const snip = snippets[index];
                    if (!snip) return;
                    // Use execCommand fallback for broader compatibility as before
                    const textArea = document.createElement('textarea');
                    textArea.value = snip.content;
                    textArea.style.position = 'fixed';
                    textArea.style.opacity = '0';
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        copyBtn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>`;
                        copyBtn.classList.add('copied');
                        setTimeout(() => {
                            copyBtn.innerHTML = `<svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\"></path></svg>`;
                            copyBtn.classList.remove('copied');
                        }, 1500);
                    } catch (err) {
                        console.error('Failed to copy snippet:', err);
                    }
                    document.body.removeChild(textArea);
                    return;
                }
                if (saveBtn) {
                    const index = parseInt(saveBtn.dataset.snippetIndex, 10);
                    const snip = snippets[index];
                    if (!snip) return;
                    // Etapa 1: escolha do tipo de salvamento
                    showModal('Save snippet', 'How do you want to save this snippet?', [
                        { text: 'Template', className: 'action-button', onClick: () => {
                            const defName = (snip.tagName ? `${snip.tagName} snippet` : 'Snippet template');
                            showModal('Save as Template', 'Enter a name for this template snippet:', [
                                { text: 'Cancel', className: 'action-button', onClick: hideModal },
                                { text: 'Save', className: 'action-button primary', onClick: async () => {
                                    const name = document.getElementById('confirm-modal-input').value.trim() || defName;
                                    const dyn = collectDynamicSettings();
                                    const newTemplate = {
                                        id: getUUID(),
                                        name,
                                        title: titleInput.value.trim(),
                                        project: projectInput.value.trim(),
                                        content: snip.content,
                                        llm: llmSelect.value,
                                        temperature: dyn.temperature ?? 0.7,
                                        topP: dyn.topP ?? 0.9,
                                        effort: dyn.effort !== undefined ? effortLevels[dyn.effort] : 'Medium',
                                        parent_id: (currentDependencies.length === 1) ? currentDependencies[0] : null,
                                        dependencies: currentDependencies.map(String),
                                        tags: [...tagsContainer.querySelectorAll('.prompt-tag span')].map(s => s.textContent)
                                    };
                                    try { await upsertItem('templates', mapTemplateUIToDb(newTemplate)); await loadDataFromSupabase(); } catch (e) { console.error(e); }
                                    hideModal();
                                } }
                            ], { showInput: true, inputPlaceholder: 'Template name...' });
                        } },
                        { text: 'Input', className: 'action-button', onClick: () => {
                            const defName = (snip.tagName ? `${snip.tagName} snippet` : 'Snippet input');
                            showModal('Save as Input', 'Enter a name for this input:', [
                                { text: 'Cancel', className: 'action-button', onClick: hideModal },
                                { text: 'Save', className: 'action-button primary', onClick: async () => {
                                    const name = document.getElementById('confirm-modal-input').value.trim() || defName;
                                    const row = { id: getUUID(), name, content: snip.content };
                                    try { await upsertItem('input_gallery', row); await loadDataFromSupabase(); } catch (e) { console.error(e); }
                                    hideModal();
                                } }
                            ], { showInput: true, inputPlaceholder: 'Input name...' });
                        } },
                        { text: 'Prompt', className: 'action-button primary', onClick: () => {
                            const defTitle = (snip.tagName ? `${snip.tagName} snippet` : 'Snippet prompt');
                            showModal('Save as Prompt', 'Enter a title for this prompt:', [
                                { text: 'Cancel', className: 'action-button', onClick: hideModal },
                                { text: 'Save', className: 'action-button primary', onClick: async () => {
                                    const title = document.getElementById('confirm-modal-input').value.trim() || defTitle;
                                    const now = new Date().toISOString();
                                    const newItem = {
                                        id: getUUID(),
                                        promptId: getUUID(),
                                        title,
                                        project: projectInput.value.trim(),
                                        llm: llmSelect.value,
                                        content: snip.content,
                                        comments: '',
                                        version: '1.0',
                                        date: now,
                                        status: 'idea',
                                        tags: [...tagsContainer.querySelectorAll('.prompt-tag span')].map(s => s.textContent),
                                        temperature: 0.7,
                                        topP: 0.9,
                                        effort: 'Medium',
                                        parent_id: (currentDependencies.length === 1) ? currentDependencies[0] : null,
                                    };
                                    prompts.push(newItem);
                                    try { await upsertItem('prompts', mapPromptUIToDb(newItem)); await loadDataFromSupabase(); } catch (e) { console.error(e); }
                                    renderVersionsList();
                                    hideModal();
                                } }
                            ], { showInput: true, inputPlaceholder: 'Prompt title...' });
                        } },
                        { text: 'Cancel', className: 'action-button', onClick: hideModal }
                    ]);
                }
            });


            // --- Evento do Mapa de Navegação ---
            navigationMap.addEventListener('click', (e) => {
                const target = e.target.closest('.nav-map-tag');
                if (target) {
                    const index = parseInt(target.dataset.index, 10);
                    mainEditor.focus();
                    mainEditor.setSelectionRange(index, index);
                }
            });

            // --- EVENTOS DO NODE FLOW ---
            const zoom = hasD3 ? d3.zoom()
                .scaleExtent([0.2, 2])
                .on("zoom", (event) => {
                    currentTransform = event.transform;
                    nodeFlowContent.style.transform = `translate(${currentTransform.x}px, ${currentTransform.y}px) scale(${currentTransform.k})`;
                    if (hasD3) d3.select("#connections-group").attr("transform", null); // Remove transform do grupo!
                    renderFlowConnections();
                }) : null;
                
            if (hasD3) {
                d3.select("#node-flow-canvas").call(zoom);
            }

            nodeFlowBtn.addEventListener('click', () => {
                if (!hasD3) {
                    showModal('Unavailable', 'Node Flow requires D3 which is not loaded (offline).', [
                        { text: 'OK', className: 'action-button primary', onClick: hideModal }
                    ]);
                    return;
                }
                populateProjectList(nodeFlowProjectFilter);
                renderNodeFlowPrompts();
                renderSavedFlowsList();
                // Always open empty: reset working canvas state
                flowNodes = [];
                flowConnections = [];
                renderFlowNodes();
                renderFlowConnections();
                nodeRuntime = new Map();
                bypassCursor = 0;
                if (deleteFlowBtn) deleteFlowBtn.disabled = true;
                nodeFlowModal.classList.remove('hidden');
            });
            closeNodeFlowBtn.addEventListener('click', () => nodeFlowModal.classList.add('hidden'));
            nodeFlowModal.addEventListener('click', (e) => {
                if (e.target === nodeFlowModal) {
                    nodeFlowModal.classList.add('hidden');
                }
            });
            nodeFlowProjectFilter.addEventListener('change', renderNodeFlowPrompts);

        saveFlowBtn.addEventListener('click', () => {
                showModal('Save Flow', 'Enter a name for this flow:', [
                    { text: 'Cancel', className: 'action-button', onClick: hideModal },
            { text: 'Save', className: 'action-button primary', onClick: async () => {
                        const flowName = confirmModalInput.value.trim();
                        if (flowName) {
                            const existing = savedFlows.findIndex(f => f.name === flowName);
                            const flowData = { name: flowName, nodes: flowNodes, connections: flowConnections };
                            if (existing > -1) {
                                savedFlows[existing] = flowData;
                            } else {
                                savedFlows.push(flowData);
                            }
                            saveFlowsToStorage();
                await upsertItem('node_flows', flowData);
                            renderSavedFlowsList();
                            savedFlowsDropdown.value = flowName;
                            hideModal();
                        }
                    }}
                ], { showInput: true, inputPlaceholder: 'My awesome flow...' });
            });

            savedFlowsDropdown.addEventListener('change', (e) => {
                const flowName = e.target.value;
                if (flowName) {
                    loadFlow(flowName);
                    // Enable delete even if no nodes (so user can remove saved record)
                    if (typeof refreshDeleteFlowState === 'function') refreshDeleteFlowState();
                    nodeRuntime = new Map();
                    bypassCursor = 0;
                }
            });

            nodeFlowPromptList.addEventListener('dragstart', (e) => {
                const target = e.target.closest('.node-flow-prompt-card');
                if(target) {
                    e.dataTransfer.setData('text/plain', target.dataset.versionId);
                    e.dataTransfer.effectAllowed = 'copy';
                }
            });

            nodeFlowCanvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });

            nodeFlowCanvas.addEventListener('drop', (e) => {
                e.preventDefault();
                const versionId = e.dataTransfer.getData('text/plain');
                const canvasRect = nodeFlowCanvas.getBoundingClientRect();
                
                const x = (e.clientX - canvasRect.left - currentTransform.x) / currentTransform.k;
                const y = (e.clientY - canvasRect.top - currentTransform.y) / currentTransform.k;

                const newNode = {
                    id: getUUID(),
                    promptId: versionId,
                    x: x - 140, // Centraliza o card no drop
                    y: y - 80,
                };
                flowNodes.push(newNode);
                renderFlowNodes();
                if (typeof refreshDeleteFlowState === 'function') refreshDeleteFlowState();
            });
            
            nodeFlowCanvas.addEventListener('mousedown', (e) => {
                if (e.target.closest('.flow-node')) return;
                nodeFlowCanvas.style.cursor = 'grabbing';
            });
            
            nodeFlowCanvas.addEventListener('mouseup', () => {
                 nodeFlowCanvas.style.cursor = 'grab';
            });

            nodeFlowContent.addEventListener('mousedown', (e) => {
                const nodeEl = e.target.closest('.flow-node');
                const connectorEl = e.target.closest('.connector');

                if (connectorEl) {
                    e.stopPropagation(); 
                    isDrawingConnection = true;
                    connectionStartNodeId = connectorEl.dataset.nodeId;
                    
                    const startNodeEl = document.getElementById(`flow-node-${connectionStartNodeId}`);
                    const startNodeData = flowNodes.find(n => n.id == connectionStartNodeId);

                    if (startNodeData) {
                        const sourceX = startNodeData.x + startNodeEl.offsetWidth;
                        const sourceY = startNodeData.y + startNodeEl.offsetHeight / 2;
                        const [startX, startY] = currentTransform.apply([sourceX, sourceY]);

                        tempLine = d3.select("#node-flow-connections")
                            .append('path')
                            .attr('d', `M ${startX} ${startY} C ${startX} ${startY} ${startX} ${startY} ${startX} ${startY}`)
                            .attr('class', 'connection-line')
                            .style('stroke-dasharray', '5, 5');
                    }

                } else if (nodeEl) {
                    e.stopPropagation(); 
                    isDraggingNode = true;
                    const nodeId = nodeEl.dataset.nodeId;
                    const nodeData = flowNodes.find(n => n.id == nodeId);

                    const moveHandler = (moveEvent) => {
                        if (!isDraggingNode) return;
                        nodeData.x += moveEvent.movementX / currentTransform.k;
                        nodeData.y += moveEvent.movementY / currentTransform.k;
                        nodeEl.style.left = `${nodeData.x}px`;
                        nodeEl.style.top = `${nodeData.y}px`;
                        renderFlowConnections();
                    };

                    const upHandler = () => {
                        isDraggingNode = false;
                        document.removeEventListener('mousemove', moveHandler);
                        document.removeEventListener('mouseup', upHandler);
                    };

                    document.addEventListener('mousemove', moveHandler);
                    document.addEventListener('mouseup', upHandler);
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDrawingConnection || !tempLine) return;
                const canvasRect = nodeFlowCanvas.getBoundingClientRect();
                const startNodeEl = document.getElementById(`flow-node-${connectionStartNodeId}`);
                const startNodeData = flowNodes.find(n => n.id == connectionStartNodeId);

                if (startNodeData && startNodeEl) {
                    const sourceX = startNodeData.x + startNodeEl.offsetWidth;
                    const sourceY = startNodeData.y + startNodeEl.offsetHeight / 2;
                    const [startX, startY] = currentTransform.apply([sourceX, sourceY]);

                    const endX = e.clientX - canvasRect.left;
                    const endY = e.clientY - canvasRect.top;
                    
                    tempLine.attr('d', `M ${startX} ${startY} C ${startX + 60} ${startY} ${endX - 60} ${endY} ${endX} ${endY}`);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (isDrawingConnection) {
                    const targetNodeEl = e.target.closest('.flow-node');
                    if (targetNodeEl && targetNodeEl.dataset.nodeId !== connectionStartNodeId) {
                        const targetNodeId = targetNodeEl.dataset.nodeId;
                        const exists = flowConnections.some(c => c.source == connectionStartNodeId && c.target == targetNodeId);
                        if (!exists) {
                            flowConnections.push({ source: connectionStartNodeId, target: targetNodeId });
                        }
                    }
                    if(tempLine) tempLine.remove();
                    isDrawingConnection = false;
                    connectionStartNodeId = null;
                    tempLine = null;
                    renderFlowConnections();
                }
            });

            // Node card actions
            nodeFlowContent.addEventListener('click', async (e) => {
                const nodeEl = e.target.closest('.flow-node');
                if (!nodeEl) return;
                const nodeId = nodeEl.dataset.nodeId;
                // Clicking the prompt title opens Prompt Viewer modal
                const titleEl = e.target.closest('[data-role="node-prompt-title"]');
                if (titleEl && nodeEl.contains(titleEl)) {
                    const node = flowNodes.find(n => n.id === nodeId);
                    const prompt = node ? prompts.find(p => String(p.id) === String(node.promptId)) : null;
                    if (prompt) {
                        nodePromptTitle.textContent = `Prompt: ${prompt.title} (v${prompt.version || ''})`;
                        nodePromptContent.textContent = prompt.content || '';
                        nodePromptModal.classList.remove('hidden');
                    }
                    return;
                }
                const btn = e.target.closest('[data-action]');
                if (!btn) return;
                const action = btn.dataset.action;
                if (action === 'view') { openNodeResponseModal(nodeId); }
                else if (action === 'save') {
                    const st = nodeRuntime.get(nodeId) || {}; if (!st.response) return;
                    try {
                        const node = flowNodes.find(n => n.id === nodeId);
                        const prompt = node ? prompts.find(p => String(p.id) === String(node.promptId)) : null;
                        const { data: userData } = await supabaseClient.auth.getUser();
                        const uid = userData?.user?.id; if (!uid) return;
                        const row = { user_id: uid, prompt_version_id: prompt?.id || null, prompt_title: prompt?.title || '', prompt_version: prompt?.version || null, model: (llmSelect?.value || null), response_text: st.response };
                        await supabaseClient.from('prompt_responses').insert(row);
                    } catch {}
                }
                else if (action === 'load') {
                    // Load latest saved response for this prompt as current and pin it
                    try {
                        const node = flowNodes.find(n => n.id === nodeId);
                        const prompt = node ? prompts.find(p => String(p.id) === String(node.promptId)) : null;
                        if (!prompt) return;
                        const { data: userData } = await supabaseClient.auth.getUser();
                        const uid = userData?.user?.id; if (!uid) return;
                        const { data } = await supabaseClient.from('prompt_responses').select('*').eq('prompt_version_id', prompt.id).eq('user_id', uid).order('run_at', { ascending: false }).limit(1);
                        if (data && data[0]) {
                            const st = nodeRuntime.get(nodeId) || {}; st.response = data[0].response_text; nodeRuntime.set(nodeId, st);
                            togglePin(nodeId, true);
                            openNodeResponseModal(nodeId);
                        }
                    } catch {}
                }
                else if (action === 'pin') {
                    togglePin(nodeId);
                    // Update pin button state for accessibility and styling
                    const st = nodeRuntime.get(nodeId) || {};
                    btn.setAttribute('aria-pressed', st.pinned ? 'true' : 'false');
                    btn.title = st.pinned ? 'Unpin (Pinned)' : 'Pin';
                    btn.classList.toggle('text-[--accent-mint]', !!st.pinned);
                }
            });

            // Prompt Viewer modal close
            if (closeNodePromptBtn) closeNodePromptBtn.addEventListener('click', () => nodePromptModal.classList.add('hidden'));

            // Toolbar controls
            if (flowModeBypassBtn && flowModeRunAllBtn) {
                const syncModeUI = () => {
                    flowModeBypassBtn.classList.toggle('active', flowMode === 'bypass');
                    flowModeRunAllBtn.classList.toggle('active', flowMode === 'runall');
                };
                flowModeBypassBtn.addEventListener('click', () => { flowMode = 'bypass'; syncModeUI(); });
                flowModeRunAllBtn.addEventListener('click', () => { flowMode = 'runall'; syncModeUI(); });
                syncModeUI();
            }
            if (runFlowBtn) runFlowBtn.addEventListener('click', async () => {
                const runAll = flowMode === 'runall';
                try { await runFlowSequence(runAll); } catch (e) { /* already handled via status */ }
            });

            // Helper: enable/disable Delete Flow button
            // Enable if there are nodes on canvas OR a saved flow is selected in dropdown
            const refreshDeleteFlowState = () => {
                if (!deleteFlowBtn) return;
                const hasNodes = flowNodes.length > 0;
                const hasSelectedSaved = savedFlowsDropdown && savedFlowsDropdown.value;
                deleteFlowBtn.disabled = !(hasNodes || hasSelectedSaved);
            };

            // Delete entire flow (nodes + connections) and any saved record
            const deleteFlow = async () => {
                // If a saved flow is selected, remove it from savedFlows and Supabase
                const selectedName = savedFlowsDropdown ? savedFlowsDropdown.value : '';
                if (selectedName) {
                    // Remove locally
                    savedFlows = savedFlows.filter(f => f.name !== selectedName);
                    saveFlowsToStorage();
                    renderSavedFlowsList();
                    if (savedFlowsDropdown) savedFlowsDropdown.value = '';
                    // Try to remove from Supabase (if online)
                    try { await deleteNodeFlowByName(selectedName); } catch (e) { console.error(e); }
                }

                // Clear working canvas state
                flowNodes = [];
                flowConnections = [];
                renderFlowNodes();
                renderFlowConnections();
                refreshDeleteFlowState();
            };

            // Toolbar button to delete whole flow with confirmation
            if (deleteFlowBtn) {
                deleteFlowBtn.addEventListener('click', () => {
                    // Allow deletion if canvas has nodes or a saved flow is selected
                    const canDelete = flowNodes.length > 0 || (savedFlowsDropdown && savedFlowsDropdown.value);
                    if (!canDelete) return;
                    showModal(
                        'Delete Flow',
                        'Delete the entire flow (all nodes and connections)? This cannot be undone.',
                        [
                            { text: 'Cancel', className: 'action-button', onClick: hideModal },
                            { text: 'Delete', className: 'action-button bg-[--accent-red] text-white border-[--accent-red-hover] hover:bg-[--accent-red-hover]', onClick: async () => { hideModal(); await deleteFlow(); } }
                        ]
                    );
                });
            }

            nodeFlowContent.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const nodeEl = e.target.closest('.flow-node');
                if (nodeEl) {
                    const nodeId = nodeEl.dataset.nodeId;
                    flowNodes = flowNodes.filter(n => n.id != nodeId);
                    flowConnections = flowConnections.filter(c => c.source != nodeId && c.target != nodeId);
                    renderFlowNodes();
                    renderFlowConnections();
                    if (typeof refreshDeleteFlowState === 'function') refreshDeleteFlowState();
                }
            });
            
            nodeFlowConnections.addEventListener('contextmenu', (e) => {
                 e.preventDefault();
                 const lineEl = e.target.closest('.connection-line');
                 if (lineEl) {
                    const source = lineEl.dataset.source;
                    const target = lineEl.dataset.target;
                    flowConnections = flowConnections.filter(c => !(c.source == source && c.target == target));
                    renderFlowConnections();
                 }
            });


            // --- Atalhos do teclado ---
            document.addEventListener('keydown', (e) => {
                // Atalho para abrir/fechar busca
                if (e.ctrlKey && e.key === 'f') {
                    e.preventDefault();
                    const isVisible = findReplaceBar.classList.contains('visible');
                    toggleFindReplaceBar(!isVisible);
                }
                // Atalho para fechar modais e busca com ESC
                if (e.key === "Escape") {
                    if (!readModeModal.classList.contains('hidden')) {
                        toggleReadMode();
                    }
                    if (findReplaceBar.classList.contains('visible')) {
                        toggleFindReplaceBar(false);
                    }
                    if (!dependencyGraphModal.classList.contains('hidden')) {
                        dependencyGraphModal.classList.add('hidden');
                    }
                    if (!listManagerModal.classList.contains('hidden')) {
                        listManagerModal.classList.add('hidden');
                    }
                    if (!inputGalleryModal.classList.contains('hidden')) {
                        inputGalleryModal.classList.add('hidden');
                    }
                    if (!nodeFlowModal.classList.contains('hidden')) {
                        nodeFlowModal.classList.add('hidden');
                    }
                }
            });

            toggleCommentsBtn.addEventListener('click', () => {
                commentsSection.classList.toggle('hidden');
            });

            // --- INICIALIZAÇÃO ---
                        const initializeApp = async () => {
                                try {
                                    if (supabaseClient) {
                                        const { data } = await supabaseClient.auth.getSession();
                                        if (!data?.session && typeof window.openLoginModal === 'function') {
                                            window.openLoginModal();
                                        }
                                    }
                                } catch {}
                                await loadDataFromSupabase(); // Espera os dados do Supabase carregarem
                populateLlmSelect();
                // Initialize Chat model list
                try { populateChatModelSelect(); } catch {}
                // Auto-run Diagnostics: verify and filter models to only OK ones
                try { await verifyAndFilterModels(); } catch {}
                // After filtering, repopulate model UIs
                populateLlmSelect();
                try { populateChatModelSelect(); } catch {}
                try { bindChatEvents(); } catch {}
                if (typeof renderLlmListDrawer === 'function') renderLlmListDrawer();
                // Ensure dynamic settings reflect the selected model's capabilities
                try { renderDynamicSettings(); } catch {}
                clearEditorForNewPrompt();
            };

            initializeApp();
        });

  
    </script>
</body>
</html>